<body>
  <div class="container">
<link rel="stylesheet" href="style.css">

<h1 id="android-fundamentals">Android Fundamentals</h1>
<link rel="stylesheet" href="style.css">
<h2 id="about-android">About Android</h2>
<hr>
<p>Android is a mobile operating system created for touchscreen devices like phones and tablets. Based on a modified version of the Linux Kernel, it was developed by the Open Handset Alliance consortium and commercially sponsored by Google. Most Android devices come pre-installed with Google Mobile Services (GMS), a proprietary software suite that includes apps like Google Play and Google Chrome. Google collaborates with various vendors, such as Samsung and HTC, to allow customization of user interfaces and software features. Beyond smartphones and tablets, Android OS is also used in smart TVs and wearables developed by Google. Android applications are distributed through various app stores, including Google Play Store, Amazon Appstore, Samsung Galaxy Store, Huawei AppGallery, and open-source platforms such as Aptoide, F-Droid, APKPure, and APKMirror.</p>
<hr>
<h3 id="history">History</h3>
<p>In October 2003, Andy Rubin, Rich Miner, Nick Sears, and Chris White founded Android Incorporated in Palo Alto, California. In 2005, after Rubin&#39;s efforts to attract investors, Google acquired the company for the reported price of around $50 million. After some time, Rubin&#39;s team at Google developed the first mobile device powered by the Linux kernel. In 2007, an early prototype with no touchscreen and a physical QWERTY keyboard was created, followed by the HTC Dream (also known as T-Mobile G1, the first commercial Android device released in September 2008.) Android&#39;s major releases before version 10 were named after desserts. For example, the first Android versions were called <code>Cupcake</code>, <code>Donut</code>, <code>Eclair</code>, and <code>Froyo</code>.</p>
<p>In 2010, Google launched the Nexus series, and in May 2013, it announced a special version of the Samsung Galaxy S4 that included Google Play, followed by the HTC One Google Play edition and the Moto G Google Play edition. In June 2014, Google introduced Android One, a program aimed at enabling third-party manufacturers to produce high-quality smartphones easily and at low cost. In October 2016, Google replaced the Nexus series with the Pixel and Pixel XL smartphones, the first phones designed and marketed entirely by Google. On September 3, 2019, Google released Android 10 (initially referred to as Android Q) for Pixel devices, officially ending the tradition of naming major Android versions after desserts.</p>
<hr>
<h3 id="versions">Versions</h3>
<p>Below is a table showing the correlation between Android codenames, versions, API levels, and release dates.</p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Version</strong></th>
<th><strong>API Level</strong></th>
<th><strong>Release Date</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Android 1.0</td>
<td>1.0</td>
<td>1</td>
<td>September 23, 2008</td>
</tr>
<tr>
<td>Android 1.1</td>
<td>1.1</td>
<td>2</td>
<td>February 9, 2009</td>
</tr>
<tr>
<td>Android Cupcake</td>
<td>1.5</td>
<td>3</td>
<td>April 27, 2009</td>
</tr>
<tr>
<td>Android Donut</td>
<td>1.6</td>
<td>4</td>
<td>September 15, 2009</td>
</tr>
<tr>
<td>Android Eclair</td>
<td>2.0</td>
<td>5</td>
<td>October 27, 2009</td>
</tr>
<tr>
<td>Android Eclair</td>
<td>2.0.1</td>
<td>6</td>
<td>December 3, 2009</td>
</tr>
<tr>
<td>Android Eclair</td>
<td>2.1</td>
<td>7</td>
<td>January 11, 2010</td>
</tr>
<tr>
<td>Android Froyo</td>
<td>2.2 – 2.2.3</td>
<td>8</td>
<td>May 20, 2010</td>
</tr>
<tr>
<td>Android Gingerbread</td>
<td>2.3 – 2.3.2</td>
<td>9</td>
<td>December 6, 2010</td>
</tr>
<tr>
<td>Android Gingerbread</td>
<td>2.3.3 – 2.3.7</td>
<td>10</td>
<td>February 9, 2011</td>
</tr>
<tr>
<td>Android Honeycomb</td>
<td>3.0</td>
<td>11</td>
<td>February 22, 2011</td>
</tr>
<tr>
<td>Android Honeycomb</td>
<td>3.1</td>
<td>12</td>
<td>May 10, 2011</td>
</tr>
<tr>
<td>Android Honeycomb</td>
<td>3.2 – 3.2.6</td>
<td>13</td>
<td>July 15, 2011</td>
</tr>
<tr>
<td>Android Ice Cream Sandwich</td>
<td>4.0 – 4.0.2</td>
<td>14</td>
<td>October 18, 2011</td>
</tr>
<tr>
<td>Android Ice Cream Sandwich</td>
<td>4.0.3 – 4.0.4</td>
<td>15</td>
<td>December 16, 2011</td>
</tr>
<tr>
<td>Android Jelly Bean</td>
<td>4.1 – 4.1.2</td>
<td>16</td>
<td>July 9, 2012</td>
</tr>
<tr>
<td>Android Jelly Bean</td>
<td>4.2 – 4.2.2</td>
<td>17</td>
<td>November 13, 2012</td>
</tr>
<tr>
<td>Android Jelly Bean</td>
<td>test</td>
<td>18</td>
<td>July 24, 2013</td>
</tr>
<tr>
<td>Android KitKat</td>
<td>4.4 – 4.4.4</td>
<td>19</td>
<td>October 31, 2013</td>
</tr>
<tr>
<td>Android KitKat</td>
<td>4.4W – 4.4W.2</td>
<td>20</td>
<td>June 25, 2014</td>
</tr>
<tr>
<td>Android Lollipop</td>
<td>5.0 – 5.0.2</td>
<td>21</td>
<td>November 4, 2014</td>
</tr>
<tr>
<td>Android Lollipop</td>
<td>5.1 – 5.1.1</td>
<td>22</td>
<td>March 2, 2015</td>
</tr>
<tr>
<td>Android Marshmallow</td>
<td>6.0 – 6.0.1</td>
<td>23</td>
<td>October 2, 2015</td>
</tr>
<tr>
<td>Android Nougat</td>
<td>7.0</td>
<td>24</td>
<td>August 22, 2016</td>
</tr>
<tr>
<td>Android Nougat</td>
<td>7.1 – 7.1.2</td>
<td>25</td>
<td>October 4, 2016</td>
</tr>
<tr>
<td>Android Oreo</td>
<td>8.0</td>
<td>26</td>
<td>August 21, 2017</td>
</tr>
<tr>
<td>Android Oreo</td>
<td>8.1</td>
<td>27</td>
<td>December 5, 2017</td>
</tr>
<tr>
<td>Android Pie</td>
<td>9</td>
<td>28</td>
<td>August 6, 2018</td>
</tr>
<tr>
<td>Android 10</td>
<td>10</td>
<td>29</td>
<td>September 3, 2019</td>
</tr>
<tr>
<td>Android 11</td>
<td>11</td>
<td>30</td>
<td>September 8, 2020</td>
</tr>
<tr>
<td>Android 12</td>
<td>12</td>
<td>31</td>
<td>October 4, 2021</td>
</tr>
<tr>
<td>Android 12L</td>
<td>12.1</td>
<td>32</td>
<td>March 7, 2022</td>
</tr>
<tr>
<td>Android 13</td>
<td>13</td>
<td>33</td>
<td>August 15, 2022</td>
</tr>
<tr>
<td>Android 14</td>
<td>14</td>
<td>34</td>
<td>October 4, 2023</td>
</tr>
<tr>
<td>Android 15</td>
<td>15</td>
<td>35</td>
<td>September 3, 2024</td>
</tr>
<tr>
<td>Android 16</td>
<td>16 Beta</td>
<td>36</td>
<td>March 13, 2025</td>
</tr>
</tbody>
</table>
<p>The Android version of the device, along with other information, can be found under <code>Settings</code> -&gt; <code>About emulated device</code> -&gt; <code>Android version</code>.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/android_version_transparent-1.png" alt="Android version 13 details: Security update November 5, 2022; Google Play update October 1, 2022; Baseband 1.0.0.0; Kernel 5.15.41; Build number 9302419."></p>
<hr>
<h3 id="hardware">Hardware</h3>
<p>Although Android supports a range of hardware architectures, the majority of devices use the ARM (AArch64) architecture. Architectures such as x86 and x86-64 have also been supported, primarily in later Android versions that included Intel processors. The unofficial project Android-x86 provided support for the x86 architecture even before it was officially supported by Android. Non-native architectures like x86 can also run on the Android Emulator included with the SDK, as well as on various third-party emulators. Android devices typically include a variety of hardware components, such as video cameras, GPS, orientation sensors, dedicated gaming controls, accelerometers, gyroscopes, barometers, magnetometers, proximity sensors, pressure sensors, thermometers, and touchscreens. Moving on to the next section, we will discuss the main components of the Android operating system and their attributes.</p>
<hr>
<h2 id="android-operating-system">Android Operating System</h2>
<hr>
<p>As we mentioned in the previous section, Android is a Linux-Based OS, and once someone gains access to a shell on the device, Linux commands can be executed. The Linux shell, as we will see in the upcoming sections, will provide a text-based I/O (input/output) interface between users and the system kernel. The example below shows how to navigate the file system and list the contents of the directory <code>/sdcard/</code>.</p>
<p><strong>Android Shell</strong></p>
<p>&#x20; Android Operating System</p>
<pre><code class="lang-shell-session">emu64x:/ <span class="hljs-comment"># cd /sdcard/</span>
emu64x:/sdcard <span class="hljs-comment"># ls -l</span>

total 104
drwxrws---<span class="hljs-number"> 2 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:48 Alarms
drwxrws--x<span class="hljs-number"> 5 </span>media_rw media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:47 Android
drwxrws---<span class="hljs-number"> 2 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:48 Audiobooks
drwxrws---<span class="hljs-number"> 2 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:48 DCIM
drwxrws---<span class="hljs-number"> 2 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:48 Documents
drwxrws---<span class="hljs-number"> 2 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2023-04-19 01:18 Download
drwxrws---<span class="hljs-number"> 3 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:48 Movies
drwxrws---<span class="hljs-number"> 3 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:48 Music
drwxrws---<span class="hljs-number"> 2 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:48 Notifications
drwxrws---<span class="hljs-number"> 4 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-30 15:09 Pictures
drwxrws---<span class="hljs-number"> 2 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:48 Podcasts
drwxrws---<span class="hljs-number"> 2 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:48 Recordings
drwxrws---<span class="hljs-number"> 2 </span>u0_a143  media_rw<span class="hljs-number"> 4096 </span>2022-12-28 11:48 Ringtones
</code></pre>
<hr>
<h3 id="android-software-stack">Android Software Stack</h3>
<p>The Android platform consists of six components, which we will analyze in the following paragraphs. The image below shows the Linux-based software stack Android uses, which contains these components.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/fundamentals_android_stack_transparent_2.png" alt="Android architecture layers: System Apps, Java API Framework, Native C/C++ Libraries, Android Runtime, Hardware Abstraction Layer (HAL), Linux Kernel."></p>
<p><a href="https://developer.android.com/guide/platform">Platform architecture</a>\</p>
<p><strong>Linux Kernel</strong></p>
<p>The Linux kernel is the foundation of the Android platform, and is responsible for managing device hardware such as the display, camera, bluetooth, wifi, audio, USB, and more. Android Runtime also relies on this layer to perform functionalities like threading and memory management.</p>
<p>Additionally, the Linux kernel allows Android to take advantage of numerous security features (like a user-based permissions model and process isolation) that:</p>
<table>
<thead>
<tr>
<th><strong>Kernel-Level Security Features</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Prevent users from reading each other&#39;s files.</td>
</tr>
<tr>
<td>Prevent users from exhausting each other&#39;s memory.</td>
</tr>
<tr>
<td>Prevent users from exhausting CPU resources.</td>
</tr>
<tr>
<td>Prevent users from exhausting devices resources, like telephony, GPS, and Bluetooth.</td>
</tr>
</tbody>
</table>
<p><strong>Hardware Abstraction Layer (HAL)</strong></p>
<p>The Hardware Abstraction Layer (HAL) is a software layer that provides the Android operating system with a standardized interface for interacting with hardware components, such as cameras, Bluetooth, sensors, and input devices. Acting as a bridge between hardware and the higher-level software layers, HAL ensures consistency in how software accesses hardware features. Because different hardware components may have unique requirements and capabilities, writing portable software that works across devices can be challenging. HAL addresses this by isolating hardware-specific implementation details from the Android framework. It is implemented as a collection of shared libraries that are dynamically loaded by the Android framework at runtime. This architecture allows device manufacturers to implement custom support for their hardware while maintaining compatibility with the broader Android platform.</p>
<p><strong>Android Runtime</strong></p>
<p>Android Runtime (ART) is the managed runtime environment used by the Android operating system to execute applications. Introduced in Android 5.0 Lollipop as a replacement for the Dalvik virtual machine, ART brought significant architectural improvements to app execution. The primary distinction between ART and Dalvik lies in their compilation strategies: ART uses Ahead-of-Time (AOT) compilation, while Dalvik relied on Just-in-Time (JIT) compilation. With AOT, application code is compiled into native machine code at install time, resulting in faster app launch times and improved runtime performance.</p>
<p>ART is capable of running multiple virtual machines concurrently, even on low-memory devices, and it executes applications packaged in the DEX (Dalvik Executable) format. Importantly, ART maintains backward compatibility with applications originally built for Dalvik. Some of the core features and benefits of Android Runtime include:</p>
<table>
<thead>
<tr>
<th><strong>ART Features</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Improved garbage collection.</td>
</tr>
<tr>
<td>Better memory management.</td>
</tr>
<tr>
<td>Better debugging support.</td>
</tr>
<tr>
<td>Optimized compression of the DEX file.</td>
</tr>
</tbody>
</table>
<p><strong>Native C/C++ Libraries</strong></p>
<p>The Native C/C++ Libraries component is a set of libraries written in the C and C++ programming languages, and are included in the Android operating system. Developers generally use these libraries to achieve high performance or write low-level code to interact directly with the hardware. Hardening techniques for increasing security can also be implemented using native C++ code.</p>
<p>Android components like ART and HAL are created using native code, and in order for these components to work, access to native libraries is needed. Applications can access these libraries through the Java Native Interface (JNI), while programmers can use the <a href="https://developer.android.com/ndk">Android NDK</a> to access native libraries directly from their native code.</p>
<p><strong>Java API Framework</strong></p>
<p>Another essential part of the Android platform architecture is Java API Framework. This component provides software tools and interfaces for building Android applications. Below are some of the components tha Java API Framework provides.</p>
<table>
<thead>
<tr>
<th><strong>Components</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>View System</td>
</tr>
<tr>
<td>Resource Manager</td>
</tr>
<tr>
<td>Notification Manager</td>
</tr>
<tr>
<td>Activity Manager</td>
</tr>
<tr>
<td>Content Providers</td>
</tr>
<tr>
<td>Location Manager</td>
</tr>
<tr>
<td>Package Manager</td>
</tr>
</tbody>
</table>
<p><strong>System Apps</strong></p>
<p>System Apps is the top layer core component of the platform architecture. This component includes all the pre-installed applications that come with the Android operating system. Such apps include:</p>
<table>
<thead>
<tr>
<th><strong>Apps</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Contacts</td>
</tr>
<tr>
<td>Messaging</td>
</tr>
<tr>
<td>Camera</td>
</tr>
<tr>
<td>Browser</td>
</tr>
<tr>
<td>Calendar</td>
</tr>
<tr>
<td>Maps</td>
</tr>
<tr>
<td>Settings</td>
</tr>
</tbody>
</table>
<p>Pre-installed apps can only be modified on rooted devices. However, developers can use them in their applications using the provided APIs. For example, a developer could create an app that uses the camera to scan a QR code.</p>
<hr>
<h3 id="dalvik-vm">Dalvik VM</h3>
<p>The Dalvik Virtual Machine (DVM) was developed by Google and introduced with the first version of Android in 2008. Android applications written in Java or Kotlin are compiled into Java bytecode and then transformed into Dalvik bytecode, packaged in .dex (Dalvik Executable) or .odex (Optimized Dalvik Executable) file formats. Unlike the Java Virtual Machine (JVM), which is stack-based, the Dalvik VM is a register-based virtual machine. This architectural difference allows for more efficient execution on devices with limited CPU and memory resources, which is ideal for mobile environments.</p>
<p>Dalvik was the default runtime environment in Android versions prior to API level 21 (Lollipop). It was eventually replaced by the Android Runtime (ART), which was introduced as a preview in Android 4.4 (KitKat) and became the default in Android 5.0. ART maintains compatibility by using the same .dex bytecode format as Dalvik, but differs significantly in its execution model. While Dalvik used Just-in-Time (JIT) compilation, ART initially used Ahead-of-Time (AOT) compilation — compiling bytecode into native machine code at install time, resulting in faster startup and improved performance. In later Android versions, ART evolved to include hybrid JIT + AOT and Profile-Guided Optimizations (PGO), further enhancing runtime efficiency and battery performance.</p>
<hr>
<h3 id="rooting">Rooting</h3>
<p>Android separates the flash storage into the following two main partitions.</p>
<ul>
<li><code>/system/</code></li>
<li><code>/data/</code></li>
</ul>
<p>The partition <code>/system/</code> is used by the operating system, and the partition <code>/data/</code> is used for user data and application installations. In Android, users don&#39;t have root access to the operating system, and some partitions (like <code>/system/</code>) are <code>read-only</code>. However, rooting the device can be achieved by exploiting security flaws. Having a rooted device enhances the capabilities and customizability of the device, and helps with debugging and overall security assessments. Rooted Android devices are also more susceptible to malicious viruses and malware, since the rooting process disables some of the built-in security features of the operating system. In some models like Google Pixel and OnePlus, rooting can also be achieved by unlocking the bootloader via the OEM Unlocking option.</p>
<hr>
<h3 id="important-directories">Important Directories</h3>
<p>Android&#39;s file structure is very similar to other Linux distributions. The directories listed below are some of the most important to consider while conducting Android app assessments.</p>
<table>
<thead>
<tr>
<th><strong>Directory</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/data/data</code></td>
<td>Contains all the applications that are installed by the user</td>
</tr>
<tr>
<td><code>/data/user/0</code></td>
<td>Contains data that only the app can access</td>
</tr>
<tr>
<td><code>/data/app</code></td>
<td>Contains the APKs of the applications that are installed by the user</td>
</tr>
<tr>
<td><code>/system/app</code></td>
<td>Contains the pre-installed applications of the device</td>
</tr>
<tr>
<td><code>/system/bin</code></td>
<td>Contains binary files</td>
</tr>
<tr>
<td><code>/data/local/tmp</code></td>
<td>A world-writable directory</td>
</tr>
<tr>
<td><code>/data/system</code></td>
<td>Contains system configuration files</td>
</tr>
<tr>
<td><code>/etc/apns-conf.xml</code></td>
<td>Contains the default Access Point Name (APN) configurations. APN is used in order for the device to connect with our current carrier’s network</td>
</tr>
<tr>
<td><code>/data/misc/wifi</code></td>
<td>Contains WiFi configuration files</td>
</tr>
<tr>
<td><code>/data/misc/user/0/cacerts-added</code></td>
<td>User certificate store. It contains certificates added by the user</td>
</tr>
<tr>
<td><code>/etc/security/cacerts/</code></td>
<td>System certificate store. Permission to non-root users is not permitted</td>
</tr>
<tr>
<td><code>/sdcard</code></td>
<td>Contains a symbolic link to the directories DCIM, Downloads, Music, Pictures, etc.</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="android-security-features">Android Security Features</h2>
<hr>
<p>Kotlin and Java are the two primary languages used to develop Android applications. The Android SDK tools compile application source code along with resource files and assets into an Android Package (APK). An APK is an archive file with a <code>.apk</code> extension that contains all the components needed to install and run an Android app, including compiled bytecode (<code>.dex</code>), manifest metadata, resources, and native libraries.</p>
<p>Each Android application runs within its own isolated security sandbox, enforced by the underlying Linux-based architecture. This sandboxing model is supported by several core Android security features:</p>
<table>
<thead>
<tr>
<th><strong>Security Features</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Android is a multi-user Linux system where each application is treated as a separate user.</td>
</tr>
<tr>
<td>By default, the system assigns each app a unique Linux user ID (UID). This UID is used by the system for access control, but is not exposed to the app itself.</td>
</tr>
<tr>
<td>File system permissions ensure that only the app assigned a particular UID can access its own files.</td>
</tr>
<tr>
<td>Each app runs in its own process, and each process runs in a separate instance of the Android Runtime (ART) virtual machine, ensuring memory isolation.</td>
</tr>
<tr>
<td>The system launches the app&#39;s process as needed and terminates it when no longer required or when reclaiming system resources.</td>
</tr>
<tr>
<td>Android enforces the principle of least privilege, meaning apps only receive the permissions necessary to perform their core functionality. Additional privileges must be explicitly declared in the app&#39;s manifest and approved by the user (or system, depending on the API level).</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="application-sandbox">Application Sandbox</h3>
<p>Android uses Linux’s user-based security model to isolate applications by assigning each app a unique user ID (UID) and running it in its own process. This creates a kernel-level application sandbox that enforces strict boundaries between apps and the system, preventing unauthorized data access or code execution across app boundaries. Apps cannot interact with each other or access system resources beyond their privileges unless explicit permissions are granted. Because the sandbox is enforced by the Linux kernel, these protections apply uniformly to all code running above the kernel, including native binaries, OS services, libraries, and user applications. Escaping this sandbox requires compromising the kernel itself, typically through a privilege escalation exploit.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/app_sandbox_custom_1.png" alt="Processes 1466 and 1732 run App1 and App2 with Dalvik VM/Android Runtime, accessing filesystems at /data/data/com.example.myapp1 and /data/data/com.example.myapp2."></p>
<p>Executing the following command, we can see that all applications have a different <code>UID</code>.</p>
<p><strong>Android Shell</strong></p>
<p>&#x20; Android Security Features</p>
<pre><code class="lang-shell-session">root:/<span class="hljs-comment"># ls -l /data/data/</span>

&lt;SNIP&gt;
drwx------ <span class="hljs-number"> 4 </span>system         system        <span class="hljs-number"> 4096 </span>2022-12-28 11:47 android
drwx------ <span class="hljs-number"> 4 </span>bluetooth      bluetooth     <span class="hljs-number"> 4096 </span>2022-12-28 11:47 com.android.bluetooth
drwx------ <span class="hljs-number"> 5 </span>radio          radio         <span class="hljs-number"> 4096 </span>2022-12-28 11:48 com.android.ons
drwx------ <span class="hljs-number"> 5 </span>shell          shell         <span class="hljs-number"> 4096 </span>2022-12-28 11:49 com.android.shell
drwx------<span class="hljs-number"> 11 </span>u0_a114        u0_a114       <span class="hljs-number"> 4096 </span>2022-12-30 12:41 com.android.chrome
drwx------ <span class="hljs-number"> 5 </span>u0_a119        u0_a119       <span class="hljs-number"> 4096 </span>2022-12-28 11:49 com.android.camera2
</code></pre>
<p>In addition to the UID-based discretionary access control (DAC) sandboxing that Android uses, many other protections have been introduced to strengthen app and system isolation. The following protections were introduced in previous Android releases.</p>
<table>
<thead>
<tr>
<th><strong>Additional Protections</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>SELinux Mandatory Access Control (MAC): Separates the system from the apps.</td>
</tr>
<tr>
<td>SELinux sandbox extension: Isolates apps across physical users.</td>
</tr>
<tr>
<td>Filter <code>seccomp-bpf</code>: Sets a limit to the <code>syscalls</code> that apps are allowed to use.</td>
</tr>
<tr>
<td>Individual SELinux sandboxes and Mandatory Access Control (MAC): Exists for all non-privileged apps with <code>targetSdkVersion &gt;= 28</code>.</td>
</tr>
<tr>
<td>Limited raw view of the filesystem: No direct access to paths like <code>/sdcard/DCIM</code>.</td>
</tr>
</tbody>
</table>
<p>Sharing files between applications also requires strong security practices and implementation. Setting app data as world accessible has been disallowed since <code>targetSdkVersion &gt;= 28</code> due to the inability to specify the desired recipient, and thus, malicious apps could potentially gain access to sensitive information from other apps.</p>
<hr>
<h3 id="application-signing">Application Signing</h3>
<p>To install an application on a device or upload it to the Play Store, the APK file must be signed. Signing the APK is crucial for security, as it protects the package from malicious modifications. Devices running Android 7.0 and earlier support JAR signing (v1), but this method does not offer complete protection—certain parts of the APK, such as ZIP metadata, are not covered by the signature.</p>
<p>Signature Scheme v2 was introduced in Android 7.0 and later to improve APK integrity and guard against unauthorized changes. Signature Scheme v3, introduced in Android 9, added support for including additional metadata in the signing block. Starting with Android 11, APK Signature Scheme v4 is used, which employs a Merkle hash tree calculated over all bytes of the APK and follows the structure of an fs-verity hash tree. The v4 signature is stored in a separate file and requires a corresponding v2 or v3 signature. The image below shows the flow of signature validation when an application is installed.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/apk_validation_process-5.png" alt="Flowchart for APK verification: Open APK, check for v3, v2, v1 signatures. Verify using respective rules. If verified, install APK; if not, reject APK."></p>
<p>Signature v2 and v3 perform checks that invalidate the APK file if there are any modifications. This way, attacks like injecting DEX files into the APK file are prevented. Signature Scheme v1, however, is vulnerable to this kind of attack. The Janus vulnerability (CVE-2017-13156) allows malicious actors to inject DEX files into the APK-without affecting the signatures-in cases where the APK is signed using the Signature Scheme v1. As a result, they can install and run the modified app.</p>
<p>The malicious DEX file is prepended to the APK file, and the Android runtime accepts it as a valid update made to the earlier, legitimate version of the app. Then, the Dalvik VM will load the code of the DEX file. Android devices 5.0 &lt; 8.1 that are signed using Signature Scheme v1 are affected by Janus.</p>
<p>Application signing can be performed in several ways:</p>
<table>
<thead>
<tr>
<th><strong>Signing Ways</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Android Studio, via the <code>Generate Signed App Bundle / APK</code> build option.</td>
</tr>
<tr>
<td>The <code>jarsigner</code> / <code>apksigner</code> tools.</td>
</tr>
<tr>
<td><a href="https://support.google.com/googleplay/android-developer/answer/9842756?sjid=14772812161089830777-NC#zippy=%2Cwhat-is-play-app-signing%2Cwhy-should-i-use-play-app-signing%2Chow-does-play-app-signing-work%2Cwhat-are-the-benefits-of-using-play-app-signing%2Cwhat-are-the-requirements-for-using-play-app-signing%2Chow-do-i-enroll-in-play-app-signing%2Cwhat-happens-if-i-cancel-my-play-app-signing-subscription%2Cwhat-if-i-have-questions-about-play-app-signing">Play App Signing</a>.</td>
</tr>
</tbody>
</table>
<p>The certificates that are used to sign an application are self-signed. One can sign an APK file with <code>apksigner</code> tool (Signature Scheme v4) using the following commands:</p>
<p><strong>Signing an APK File</strong></p>
<p>&#x20; Android Security Features</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ echo -e <span class="hljs-string">"password<span class="hljs-subst">\n</span>password<span class="hljs-subst">\n</span>john doe<span class="hljs-subst">\n</span>test<span class="hljs-subst">\n</span>test<span class="hljs-subst">\n</span>test<span class="hljs-subst">\n</span>test<span class="hljs-subst">\n</span>test<span class="hljs-subst">\n</span>yes"</span> &gt; params.txt
root@htb[/htb]$ cat params.txt | keytool -genkey -keystore <span class="hljs-type">key</span>.keystore -validity <span class="hljs-number">1000</span> -keyalg RSA -alias john
root@htb[/htb]$ zipalign -p -f -v <span class="hljs-number">4</span> myapp.apk myapp_signed.apk
root@htb[/htb]$ echo password | apksigner sign --ks <span class="hljs-type">key</span>.keystore myapp_signed.apk
</code></pre>
<p>These commands accomplish the following for us:</p>
<table>
<thead>
<tr>
<th><strong>APK Signing Steps</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Creates a file, <code>params.txt</code>, with the necessary input data for <code>keytool</code> to generate a keypair.</td>
</tr>
<tr>
<td>Pipes the contents of <code>params.txt</code> into <code>keytool</code> to automate the key generation process, storing the key in <code>key.keystore</code>.</td>
</tr>
<tr>
<td><code>zipalign</code> allows uncompressed files within <code>myapp.apk</code> to be accessed directly via <a href="https://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a>, creating an optimized application named <code>myapp_signed.apk</code></td>
</tr>
<tr>
<td>The final app is signed with <code>apksigner</code>, using the key stored in <code>key.keystore</code> and the password being echoed through the pipe</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="verified-boot">Verified Boot</h3>
<p>Verified Boot is an Android security feature that ensures the integrity of the operating system. This is achieved using a unique set of cryptographic keys to sign and verify the boot image and ensure that only the authorized parties can modify the system. While Android is booting up, each stage verifies the integrity and authenticity of the next stage, and if the signature is valid, then the device boots up normally. Otherwise, the device either won&#39;t boot, or it will provide the user with a message updating them that the device is tampered with. Apart from this, Verified Boot utilizes Rollback Protection to prevent exploits from becoming persistent. This is done by ensuring that Android is only updating to the newest versions. The recommended boot flow for a device is as follows:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/verified_boot_flow-1.png" alt="Flowchart for device boot process: Start, check if device is locked. If valid OS found, verify root of trust. If not, cannot boot. Warn about custom OS or unverified OS. Update rollback protection or boot OS based on user confirmation and eio mode."></p>
<p>Before proceeding with the questions, ensure that you have followed the steps provided in the sections <code>Android Studio</code> and <code>Android Emulators -&gt; Android Studio AVD</code>, and have set up a virtual Android device. This device will be used throughout the remainder of the module and subsequent challenge questions.</p>
<hr>
<h2 id="apk-structure">APK Structure</h2>
<hr>
<p>The Android Package Kit file—commonly known as an APK—is the file format used by the Android operating system to distribute and install applications. An APK is essentially an archive that contains all the components needed for an Android app to run. Among its contents is the application&#39;s compiled code, stored in a single DEX (Dalvik Executable) file. When an Android application is compiled, the Java (or Kotlin) source code is first converted into Java bytecode, which is then transformed and optimized into a DEX file. These DEX files are executable and can be interpreted by the Dalvik Virtual Machine (DVM) or the Android Runtime (ART), depending on the device and Android version.</p>
<p>In addition to compiled code, APK files include resources such as assets, images, UI layouts, and the AndroidManifest.xml file—all of which are necessary for the application to function. APK files use the <code>.apk</code> extension and, since they are ZIP-based archives, they can be unpacked with standard tools such as the <code>unzip</code> command in Linux.</p>
<p>&#x20; APK Structure</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ unzip myapp.apk
root@htb[/htb]$ ls -l

total 27584
-rw-r--r--   <span class="hljs-number"> 1 </span>bertolis  bertolis    <span class="hljs-number"> 4220 </span>Jan <span class="hljs-number"> 1 </span><span class="hljs-number"> 1981 </span>AndroidManifest.xml
drwxr-xr-x  <span class="hljs-number"> 49 </span>bertolis  bertolis    <span class="hljs-number"> 1568 </span>May<span class="hljs-number"> 10 </span>13:36 META-INF
drwxr-xr-x   <span class="hljs-number"> 3 </span>bertolis  bertolis      <span class="hljs-number"> 96 </span>May<span class="hljs-number"> 10 </span>13:36 assets
-rw-r--r--   <span class="hljs-number"> 1 </span>bertolis  bertolis <span class="hljs-number"> 8285624 </span>Jan <span class="hljs-number"> 1 </span><span class="hljs-number"> 1981 </span>classes.dex
drwxr-xr-x   <span class="hljs-number"> 9 </span>bertolis  bertolis     <span class="hljs-number"> 288 </span>May<span class="hljs-number"> 10 </span>13:36 kotlin
drwxr-xr-x   <span class="hljs-number"> 6 </span>bertolis  bertolis     <span class="hljs-number"> 192 </span>May<span class="hljs-number"> 10 </span>13:36 lib
drwxr-xr-x <span class="hljs-number"> 545 </span>bertolis  bertolis   <span class="hljs-number"> 17440 </span>May<span class="hljs-number"> 10 </span>13:36 res
-rw-r--r--   <span class="hljs-number"> 1 </span>bertolis  bertolis  <span class="hljs-number"> 922940 </span>Jan <span class="hljs-number"> 1 </span><span class="hljs-number"> 1981 </span>resources.arsc
</code></pre>
<p>The files extracted from the APK are encoded, and neither the source code nor the configuration files are human-readable.</p>
<p>&#x20; APK Structure</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ vim AndroidManifest.xml
</code></pre>
<p><img src="https://academy.hackthebox.com/storage/modules/195/encoded_manifest.png" alt="A screen displaying a sequence of random symbols and characters, starting with &quot;1 ^C^@^H^@^D^N^...&quot;."></p>
<p>The image below shows the unzipped structure of an APK file:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/apk_structure_1.png" alt="Diagram of APK structure: META-INF (certificates), assets (application assets), lib (native code), res (resources), AndroidManifest.xml (app info), classes.dex (compiled code), resources.arsc (resources info)."></p>
<p><strong>META-INF</strong></p>
<p>This folder is generated when the application is signed, and it contains verification information. Any modification made to the APK file will lead to invalidation, and the APK will need to be resigned. Listing the content of this directory reveals the following files.</p>
<p>&#x20; APK Structure</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ls -l META-INF/

total <span class="hljs-number">664</span>
-rw-r--r--  <span class="hljs-number">1</span> bertolis  bertolis   <span class="hljs-number">1103</span> Jan  <span class="hljs-number">1</span>  <span class="hljs-number">1981</span> CERT.RSA
-rw-r--r--  <span class="hljs-number">1</span> bertolis  bertolis  <span class="hljs-number">77917</span> Jan  <span class="hljs-number">1</span>  <span class="hljs-number">1981</span> CERT.SF
-rw-r--r--  <span class="hljs-number">1</span> bertolis  bertolis  <span class="hljs-number">77843</span> Jan  <span class="hljs-number">1</span>  <span class="hljs-number">1981</span> MANIFEST.MF
&lt;SNIP&gt;
</code></pre>
<table>
<thead>
<tr>
<th><strong>File</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CERT.RSA</code></td>
<td>Contains the public key and the signature of CERT.SF.</td>
</tr>
<tr>
<td><code>CERT.SF</code></td>
<td>Contains a list of names/hashes of the corresponding lines in the MANIFEST.MF file.</td>
</tr>
<tr>
<td><code>MANIFEST.MF</code></td>
<td>Contains a list of names/hashes (usually SHA256 in Base64) for all the files of the APK, and is used to invalidate the APK if any of the files are modified.</td>
</tr>
</tbody>
</table>
<p><strong>assets</strong></p>
<p>This folder contains assets that developers bundle with the application, and can be retrieved by the AssetManager. These assets can be images, videos, documents, databases, and other raw files. Xamarin, Cordova, and React-Native applications will use this folder to save code and DLL&#39;s as well.</p>
<p><strong>lib</strong></p>
<p>This folder contains native libraries with compiled code targeting different device architectures. Android applications that use the Native Development Kit (NDK) may include components written in C or C++. When an app includes native libraries, they are stored in the <code>lib</code> directory as shared object files with the <code>.so</code> extension. Separate SO files are generated for each supported architecture, typically organized under subdirectories following this structure.</p>
<p>&#x20; APK Structure</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ls -l lib/

total 0
drwxr-xr-x <span class="hljs-number"> 3 </span>bertolis  bertolis <span class="hljs-number"> 96 </span>May<span class="hljs-number"> 10 </span>13:36 arm64-v8a
drwxr-xr-x <span class="hljs-number"> 3 </span>bertolis  bertolis <span class="hljs-number"> 96 </span>May<span class="hljs-number"> 10 </span>13:36 armeabi-v7a
drwxr-xr-x <span class="hljs-number"> 3 </span>bertolis  bertolis <span class="hljs-number"> 96 </span>May<span class="hljs-number"> 10 </span>13:36 x86
drwxr-xr-x <span class="hljs-number"> 3 </span>bertolis  bertolis <span class="hljs-number"> 96 </span>May<span class="hljs-number"> 10 </span>13:36 x86_64
</code></pre>
<p><strong>res</strong></p>
<p>This folder contains predefined application resources that cannot be modified by the user at runtime, unlike assets. These resources include XML files defining color state lists, UI layouts, fonts, values, configurations for OS versions, screen orientations, network settings, and more.</p>
<p>&#x20; APK Structure</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ls -l res/

&lt;SNIP&gt;
drwxr-xr-x<span class="hljs-number"> 1 </span>bertolis bertolis<span class="hljs-number"> 10762 </span>Jan<span class="hljs-number"> 27 </span>16:05 color
drwxr-xr-x<span class="hljs-number"> 1 </span>bertolis bertolis <span class="hljs-number"> 6624 </span>Jan<span class="hljs-number"> 27 </span>16:05 drawable
drwxr-xr-×<span class="hljs-number"> 1 </span>bertolis bertolis   <span class="hljs-number"> 30 </span>Jan<span class="hljs-number"> 27 </span>16:05 raw
drwxr-xr-×<span class="hljs-number"> 1 </span>bertolis bertolis  <span class="hljs-number"> 466 </span>Jan<span class="hljs-number"> 27 </span>16:05 xml
</code></pre>
<p><strong>AndroidManifest.xml</strong></p>
<p>The manifest file contains metadata about the application. It defines essential attributes and components that the system uses to manage the app, including:</p>
<table>
<thead>
<tr>
<th><strong>Components</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Package name</td>
</tr>
<tr>
<td>SDK Version</td>
</tr>
<tr>
<td>Build Version</td>
</tr>
<tr>
<td>Permissions</td>
</tr>
<tr>
<td>NetworkSecurityConfig</td>
</tr>
<tr>
<td>Activities</td>
</tr>
<tr>
<td>Providers</td>
</tr>
<tr>
<td>Services</td>
</tr>
</tbody>
</table>
<p><strong>classes.dex</strong></p>
<p>This file contains all compiled Java (or Kotlin) classes in DEX (Dalvik Executable) format, which are executed by the Android Runtime (ART) on devices running Android 5.0 or higher, or by the Dalvik VM on earlier versions. Large applications may include multiple DEX files (enabled via multidex), named sequentially as <code>classes2.dex</code>, <code>classes3.dex</code>, and so on.</p>
<p><strong>resources.arsc</strong></p>
<p>This file contains precompiled resources that are used by the app at runtime. It maps resource identifiers in the code (e.g., <code>R.string.app_name</code>) to their actual values, such as strings, colors, layouts, and styles. It also includes a binary representation of XML resources. In some APKs, you may also find a <code>kotlin/</code> folder, which exists in apps written in Kotlin and contains Kotlin-specific metadata used by the runtime and tooling.</p>
<hr>
<h2 id="android-studio">Android Studio</h2>
<hr>
<p>Android Studio is an Integrated Development Environment (IDE) based on JetBrains&#39; IntelliJ IDEA and is the official IDE for Android application development. Familiarity with the Android Studio project structure can provide valuable insight during reverse engineering. Android Studio is available for Windows, Linux, and macOS. On Windows and macOS, you can <a href="https://developer.android.com/studio#get-android-studio">download</a> the <code>.exe</code> and <code>.dmg</code> installers respectively, and follow the Setup Wizard to complete the installation. In this example, we will demonstrate how to install Android Studio on a Debian-based Linux distribution. Replace the version number in the link with the latest one, if necessary.</p>
<p>&#x20; Android Studio</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ wget https:/</span><span class="hljs-regexp">/redirector.gvt1.com/</span>edgedl<span class="hljs-regexp">/android/</span>studio<span class="hljs-regexp">/ide-zips/</span><span class="hljs-number">2024.3</span><span class="hljs-number">.1</span><span class="hljs-number">.14</span>/android-studio<span class="hljs-number">-2024.3</span><span class="hljs-number">.1</span><span class="hljs-number">.14</span>-linux.tar.gz
root<span class="hljs-meta">@htb</span>[/htb]$ tar xvzf android-studio<span class="hljs-number">-2024.3</span><span class="hljs-number">.1</span><span class="hljs-number">.14</span>-linux.tar.gz
root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ sh android-studio/</span>bin/studio.sh
</code></pre>
<p>Once the Setup Wizard starts, click <code>Next</code> on the first four windows to download the SDK and accept the License Agreement. Then, wait for the components to download and click <code>Finish</code>.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/android_studio_setup_components-3.png" alt="Android Studio Setup Wizard downloading components. URL: https://dl.google.com/android/repository/sys-img/google\_apis\_playst...36\_r05.zip. Options: Show Details, Cancel."></p>
<p>On the next window, click on the <code>Create Project</code> button to create a new project.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/android_studio_new_project-3.png" alt="Welcome screen of Android Studio Meerkat 2024.3.1 Patch 1. Options: New Project, Open, Clone Repository. Menu: Projects, Customize, Plugins, Learn."></p>
<p>Select <code>Empty Views Activity</code> and choose <code>Groovy DSL (build.gradle)</code> in the <code>Build configuration language</code> option, and click Next.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/android_studio_empty_activity-4.png" alt="New Project screen in Android Studio. Templates for Phone and Tablet: No Activity, Empty Activity, Gemini API Starter, Basic Views Activity, Bottom Navigation Views Activity, Empty Views Activity. Options: Next, Cancel, Finish."></p>
<p>Finally, we give the app a name, select the programming language (Java in our case) and click <code>Finish</code>.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/android_studio_app_name-4.png" alt="New Project setup for Empty Views Activity. Fields: Name &quot;My Application&quot;, Package &quot;com.example.myapplication&quot;, Save location, Language &quot;Java&quot;, Minimum SDK &quot;API 24 (Nougat)&quot;, Build configuration &quot;Groovy DSL&quot;. Options: Finish, Cancel."></p>
<p>After clicking &#39;Finish&#39;, we wait for the indexing process to complete before proceeding with the following steps. The above setup configures the project to use Java as the default programming language.</p>
<hr>
<h3 id="project-structure">Project Structure</h3>
<p>Once the project is created, we see the project structure.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/android_studio_project_structure-2.png" alt="Android Studio interface showing: Toolbar Menu, Project Explorer with &quot;MainActivity.kt&quot; open, Editor Window with Kotlin code, Tool Window, Navigation Bar, and Status Bar."></p>
<p>Understanding the Android Studio project structure is essential for reverse engineering, as it provides insight into how the app is organized during development.</p>
<p>The project contains the following folders.</p>
<p><strong>app</strong></p>
<table>
<thead>
<tr>
<th><strong>Files</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>manifest</code></td>
<td>Contains essential metadata about the app, including the package name, components (activities, services, etc.), permissions, network configuration, API level, and more.</td>
</tr>
<tr>
<td><code>java</code></td>
<td>Contains the application&#39;s Java source code.</td>
</tr>
<tr>
<td><code>res</code></td>
<td>Contains app resources such as UI strings, images, layout XML files, and other static assets used by the app.</td>
</tr>
</tbody>
</table>
<p><strong>Gradle Scripts</strong></p>
<table>
<thead>
<tr>
<th><strong>Files</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>build.gradle</code></td>
<td>Defines build configurations for the project or module, including dependencies, build types, and whether code optimization tools (such as ProGuard) are enabled.</td>
</tr>
<tr>
<td><code>proguard-rules.pro</code></td>
<td>Specifies custom rules for ProGuard</td>
</tr>
</tbody>
</table>
<p>While we won&#39;t explore <code>Gradle Scripts</code> in detail in this module, it&#39;s important to understand that they form the foundation of Android Studio’s build system. For instance, Gradle can be configured to generate multiple APKs from a single project, each offering different features.</p>
<hr>
<h3 id="types-of-applications">Types of Applications</h3>
<p>Depending on the technologies used, Mobile applications can be categorized into three basic types.</p>
<p><strong>Native apps</strong></p>
<p>Native apps are built specifically for a particular operating system. Android native apps are typically developed using Kotlin or Java. They are generally considered more secure than hybrid apps because they have direct access to platform-level security features and system APIs.</p>
<p><strong>Web apps</strong></p>
<p>Web apps, while similar in appearance to native apps, are developed to be responsive and accessible from mobile web browsers. They are typically built using HTML, CSS, and JavaScript. Web apps can be vulnerable to web-based attacks due to their reliance on web technologies and browser security.</p>
<p><strong>Hybrid apps</strong></p>
<p>Hybrid apps combine elements of both native and web apps and are designed to be cross-platform. They use WebViews to display web content within a native app container. While offering the flexibility of web apps, hybrid apps can also be vulnerable to web-based attacks, including cross-site scripting (XSS) attacks, weak SSL implementations, and more.</p>
<p>In the following sections, we&#39;ll see some examples of creating native and hybrid Android applications.</p>
<hr>
<h2 id="native-apps">Native Apps</h2>
<hr>
<p>Native apps are software applications written in a specific programming language and tailored to run on a particular platform. In the context of Android, native apps are primarily developed using Java or Kotlin and built with Android Studio, typically leveraging components from the Android Software Development Kit (SDK).</p>
<p>Google, the tech giant who owns and develops Android, is using <a href="https://developer.android.com/kotlin/first">Kotlin as the default programming language</a> for app development. However, Java is still a popular choice and many users prefer it over Kotlin. In the following steps, we will show how to create a simple application in Java. Since we have already created a new project, let&#39;s examine how the app layout is created and connected with the Java code and other resources. On the left side section under <code>app/res/layout</code> we select the <code>activity_main.xml</code> file.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/java_hello_world_layout_file-5.png" alt="Project Explorer showing app structure: manifests with AndroidManifest.xml, java with MainActivity, res with layout containing activity\_main.xml, and values with colors.xml, strings.xml, themes."></p>
<p>Layouts define the structure of the user interface of the application, and Android uses XML to create such layouts. In this file, <code>activity_main.xml</code>, we can add text, buttons, images, and other things that will be displayed to the user. The following snippet will create the layout of an application that prints a message on the screen when the button is tapped.</p>
<p>Code: xml</p>
<pre><code class="lang-xml">&lt;?xml <span class="hljs-keyword">version</span>=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    xmlns:<span class="hljs-keyword">app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>
    xmlns:tools=<span class="hljs-string">"http://schemas.android.com/tools"</span>
    android:layout_width=<span class="hljs-string">"match_parent"</span>
    android:layout_height=<span class="hljs-string">"match_parent"</span>
    tools:context=<span class="hljs-string">".MainActivity"</span>&gt;

    &lt;TextView
        android:id=<span class="hljs-string">"@+id/title"</span>
        android:layout_width=<span class="hljs-string">"wrap_content"</span>
        android:layout_height=<span class="hljs-string">"wrap_content"</span>
        android:text=<span class="hljs-string">"My Application"</span>
        android:textSize=<span class="hljs-string">"32sp"</span>
        <span class="hljs-keyword">app</span>:layout_constraintBottom_toBottomOf=<span class="hljs-string">"parent"</span>
        <span class="hljs-keyword">app</span>:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>
        <span class="hljs-keyword">app</span>:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>
        <span class="hljs-keyword">app</span>:layout_constraintTop_toTopOf=<span class="hljs-string">"parent"</span>
        <span class="hljs-keyword">app</span>:layout_constraintVertical_bias=<span class="hljs-string">"0.097"</span> /&gt;

    &lt;Button
        android:id=<span class="hljs-string">"@+id/button"</span>
        android:layout_width=<span class="hljs-string">"wrap_content"</span>
        android:layout_height=<span class="hljs-string">"wrap_content"</span>
        android:text=<span class="hljs-string">"Button"</span>
        <span class="hljs-keyword">app</span>:layout_constraintBottom_toBottomOf=<span class="hljs-string">"parent"</span>
        <span class="hljs-keyword">app</span>:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>
        <span class="hljs-keyword">app</span>:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>
        <span class="hljs-keyword">app</span>:layout_constraintTop_toBottomOf=<span class="hljs-string">"@+id/title"</span>
        <span class="hljs-keyword">app</span>:layout_constraintVertical_bias=<span class="hljs-string">"0.403"</span> /&gt;

    &lt;TextView
        android:id=<span class="hljs-string">"@+id/message"</span>
        android:layout_width=<span class="hljs-string">"380dp"</span>
        android:layout_height=<span class="hljs-string">"31dp"</span>
        android:text=<span class="hljs-string">"@string/message"</span>
        android:textSize=<span class="hljs-string">"20sp"</span>
        android:textAlignment=<span class="hljs-string">"center"</span>
        android:textIsSelectable=<span class="hljs-string">"true"</span>
        <span class="hljs-keyword">app</span>:layout_constraintBottom_toBottomOf=<span class="hljs-string">"parent"</span>
        <span class="hljs-keyword">app</span>:layout_constraintEnd_toEndOf=<span class="hljs-string">"parent"</span>
        <span class="hljs-keyword">app</span>:layout_constraintStart_toStartOf=<span class="hljs-string">"parent"</span>
        <span class="hljs-keyword">app</span>:layout_constraintTop_toBottomOf=<span class="hljs-string">"@+id/button"</span>
        <span class="hljs-keyword">app</span>:layout_constraintVertical_bias=<span class="hljs-string">"0.25"</span> /&gt;

&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>
<p>The above snippet consists of three objects: two <code>TextView</code> and one <code>Button</code>. It is worth noticing the following attributes.</p>
<table>
<thead>
<tr>
<th><strong>Attribute</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tools:context=&quot;.MainActivity</code></td>
<td>Defines the Activity in which the layout will be used. This is primarily used in the layout editor for preview purposes and does not affect the runtime behavior of the app.</td>
</tr>
<tr>
<td><code>android:id</code></td>
<td>Assigns a unique identifier to the object, allowing it to be referenced in Java code (such as<code>MainActivity.java</code>) and other resources. The <code>@+id</code> prefix indicates it will be created as a new resource, whereas <code>@id</code> would be used if the resource were already defined.</td>
</tr>
<tr>
<td><code>android:text</code></td>
<td>Sets the text content of the TextView or Button. The value can be a hardcoded string, like <code>android:text=&quot;My Application&quot;</code>, or a reference to a string resource from the relative to the project file <code>res/values/strings.xml</code>. Referencing string resources is the recommended approach for localization and maintainability. The example below shows the contents of the <code>strings.xml</code> file used in this project.</td>
</tr>
</tbody>
</table>
<p>Code: xml</p>
<pre><code class="lang-xml">&lt;resources&gt;
    &lt;<span class="hljs-built_in">string</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"app_name"</span>&gt;My Application&lt;/<span class="hljs-built_in">string</span>&gt;
    &lt;<span class="hljs-built_in">string</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">"message"</span>&gt;Hello World!&lt;/<span class="hljs-built_in">string</span>&gt;
&lt;/resources&gt;
</code></pre>
<p>These values can also be accessed from the Java code using the <code>R</code> class. The <code>R</code> class, which is auto-generated by Android, contains the IDs of all the resources in the <code>res/</code> directory. Familiarity with these procedures will give us a better understanding of the app during the process of reverse engineering. Let&#39;s now see the content of the file <code>MainActivity.java</code>, which contains the Java code of the app.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-keyword">package</span> com.example.myapplication;

<span class="hljs-keyword">import</span> androidx.appcompat.app.<span class="hljs-type">AppCompatActivity</span>;

<span class="hljs-keyword">import</span> android.os.<span class="hljs-type">Bundle</span>;
<span class="hljs-keyword">import</span> android.view.<span class="hljs-type">View</span>;
<span class="hljs-keyword">import</span> android.widget.<span class="hljs-type">Button</span>;
<span class="hljs-keyword">import</span> android.widget.<span class="hljs-type">TextView</span>;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>{
    <span class="hljs-type">TextView</span> message;
    <span class="hljs-type">Button</span> button;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="hljs-type">R</span>.layout.activity_main);

        message = (<span class="hljs-type">TextView</span>)findViewById(<span class="hljs-type">R</span>.id.message);
        button = (<span class="hljs-type">Button</span>)findViewById(<span class="hljs-type">R</span>.id.button);

        button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-type">View</span>.<span class="hljs-type">OnClickListener</span>() {
            <span class="hljs-meta">@Override</span>
            public void onClick(<span class="hljs-type">View</span> v) {
                message.setText(<span class="hljs-string">"Hello from Java!"</span>);
            }
        });
    }
}
</code></pre>
<p>The class <code>MainActivity</code> includes the method <code>OnCreate()</code>. This method is called when the activity is starting, thus everything inside will run automatically. The line <code>setContentView(R.layout.activity_main);</code> indicates that the <code>activity_main.xml</code> file will be used to set the layout of this activity. Method <code>OnCreate()</code> is also used for initializations since it runs when the activity starts. The variables <code>message</code> and <code>button</code> are initialized to point to the corresponding objects found in the <code>activity_main.xml</code> file.</p>
<p>Code: java</p>
<pre><code class="lang-java">message = (<span class="hljs-name">TextView</span>)findViewById(<span class="hljs-name">R</span>.id.message)<span class="hljs-comment">;</span>
button = (<span class="hljs-name">Button</span>)findViewById(<span class="hljs-name">R</span>.id.button)<span class="hljs-comment">;</span>
</code></pre>
<p>Using the <code>R.java</code> file, the <code>R.id.message</code> points to the <code>android:id=&quot;@+id/message&quot;</code> attribute in the <code>activity_main.xml</code> file we saw earlier. Finally, the line <code>message.setText(&quot;Hello from Java!&quot;);</code> will be executed as soon as the button is clicked, like the line <code>button.setOnClickListener</code> indicates. Once it&#39;s tapped, the text <code>Hello from Java!</code> will be set in the TextView.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/java_hello_start_app_transparent_1.png" alt="Mobile app screen titled &quot;My Application&quot; with a purple button labeled &quot;BUTTON&quot; and text &quot;Hello from Java!&quot; below."></p>
<p>The snippet below shows the same app written in Kotlin. To configure the project to use <code>Kotlin</code> as the default programming language, we must select <code>Kotlin</code> in the <code>Language</code> field on the <code>New Project</code> window while creating a new project in Android Studio. Then, optionally, we can also select <code>Kotlin DSL (build.gradle.kts)</code> in the <code>Build configuration language</code> field to utilize Kotlin syntax for Gradle build scripts.</p>
<p>Code: kotlin</p>
<pre><code class="lang-kotlin"><span class="hljs-keyword">package</span> com.example.myapplication

<span class="hljs-keyword">import</span> androidx.appcompat.app.AppCompatActivity
<span class="hljs-keyword">import</span> android.os.Bundle
<span class="hljs-keyword">import</span> android.widget.Button
<span class="hljs-keyword">import</span> android.widget.TextView

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        <span class="hljs-keyword">val</span> message = findViewById&lt;TextView&gt;(R.id.message)
        <span class="hljs-keyword">val</span> button = findViewById&lt;Button&gt;(R.id.button)

        button.setOnClickListener {
            message.text = <span class="hljs-string">"Hello from Java!"</span>
        }
    }
}
</code></pre>
<p>Although Kotlin and Java use different syntax, most tools will generate the same pseudocode when reverse engineering the app. This means that it&#39;s not necessary for us to master both programming languages. Once the app is developed, we can export a signed APK file ready for installation. Under <code>Build</code> -&gt; <code>Generate Signed Bundle / APK...</code>, we select <code>APK</code> and click <code>Next</code>.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/java_hello_sign_1-3.png" alt="Generate Signed Bundle or APK screen. Options: Android App Bundle (smaller size, on-demand features) or APK. Buttons: Help, Cancel, Next."></p>
<p>On the next window, we click <code>Create new...</code> to create a new key.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/java_hello_sign_2-3.png" alt="Generate Signed Bundle or APK screen. Fields: Module, Key store path, Key store password, Key alias, Key password. Options: Create new, Choose existing, Remember passwords. Buttons: Help, Cancel, Next."></p>
<p>Then, we set the <code>Key store path</code>, <code>Password</code>, <code>Alias,</code> and <code>First and Last Name</code>, and click <code>OK</code>.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/java_hello_sign_3-3.png" alt="New Key Store screen. Fields: Key store path, Password, Key alias, Key password, Validity (25 years), Certificate details (Name: John Doe, Organizational Unit, Organization, City, State, Country Code). Buttons: Cancel, OK."></p>
<p>Once the key is created, we click <code>Next</code>.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/java_hello_sign_4-3.png" alt="Generate Signed Bundle or APK screen. Fields: Module, Key store path, Key store password, Key alias, Key password. Options: Create new, Choose existing, Remember passwords. Buttons: Help, Cancel, Next."></p>
<p>Finally, we select the option <code>release</code> and click on <code>Finish</code>.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/java_hello_sign_5-3.png" alt="Generate Signed Bundle or APK screen. Destination Folder: /Users/bertolis/AndroidStudioProjects/MyApplication/app. Build Variants: debug, release. Buttons: Help, Cancel, Finish."></p>
<p>The signed APK file can be found under the directory <code>~/AndroidStudioProjects/MyApplication/app/release/</code>, with the name <code>app-release.apk</code>.</p>
<p>&#x20; Native Apps</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ls -l ~/AndroidStudioProjects/MyApplication/app/release/

total 8856
-rw-r--r--@<span class="hljs-number"> 1 </span>bertolis  bertolis <span class="hljs-number"> 4527105 </span>May <span class="hljs-number"> 3 </span>01:44 app-release.apk
-rw-r--r--@<span class="hljs-number"> 1 </span>bertolis  bertolis     <span class="hljs-number"> 379 </span>May <span class="hljs-number"> 3 </span>01:44 output-metadata.json
</code></pre>
<p>We can rename and install the exported APK file directly on the device.</p>
<hr>
<h2 id="native-code">Native Code</h2>
<hr>
<p>Native code is compiled to run on a specific processor architecture, which can give apps written in native code a performance advantage on compatible hardware. Android Studio supports the inclusion of native code through the Native Development Kit (NDK), which allows developers to write portions of the app in C or C++. This is often done to reduce latency, optimize for hardware capabilities, or in some cases harden the security of an application.</p>
<p>Native code is typically included in the application as shared libraries (<code>.so</code> files). These libraries can then be invoked from Java or Kotlin using the <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">Java Native Interface</a> (JNI). JNI is a framework that defines how managed code (Java/Kotlin) interacts with unmanaged native code (C/C++), enabling cross-language method calls and data exchange.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/jni-java-c-interaction_custom_1.png" alt="Diagram showing interaction between C++ Native Code and Java App via JNI. C++ Function calls Java Method through JNI, which handles function calls and returns results."></p>
<p>Let&#39;s create a Native C++ project to get more familiar with the way it works. To accomplish this, first launch Android Studio and navigate to <code>New Project</code> -&gt; <code>Native C++</code>. Proceed to name your app, then in the following window under the <code>C++ Standard</code> section, select <code>Toolchain Default</code> from the dropdown menu. Finally, click Finish.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/native_new_project-2.png" alt="New Project screen in Android Studio. Templates for Phone and Tablet: Primary/Detail Flow, Navigation Drawer Activity, Responsive Activity, Settings Activity, Scrolling Activity, Tabbed Activity, Fragment + ViewModel, Game Activity (C++), Native C++. Options: Cancel, Next, Finish."></p>
<p>Once the project is created, we notice the <code>native-lib.cpp</code> file found under the <code>App</code> -&gt; <code>cpp</code> folder in the left side section of Android Studio.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/native_cpp_file-2.png" alt="Project Explorer showing app structure: manifests with AndroidManifest.xml, java with MainActivity, cpp with native-lib.cpp, res with layout containing activity\_main.xml, and values with colors.xml, strings.xml, themes."></p>
<p>The following snippet of C++ code shows a function that returns the string <code>Hello from C++</code>.</p>
<p>Code: c</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;jni.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>

<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function">JNIEXPORT jstring JNICALL
<span class="hljs-title">Java_com_example_myapplication_MainActivity_stringFromJNI</span><span class="hljs-params">(
        JNIEnv* env,
        jobject <span class="hljs-comment">/* this */</span>)</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> hello = <span class="hljs-string">"Hello from C++"</span>;
    <span class="hljs-keyword">return</span> env-&gt;NewStringUTF(hello.c_str());
}
</code></pre>
<p>The function name <code>Java_com_example_myapplication_MainActivity_stringFromJNI</code> follows the JNI naming convention and indicates that it will be called from the <code>MainActivity</code> class. The line <code>return env-&gt;NewStringUTF(hello.c_str());</code> returns a string to the Java layer. It&#39;s important to understand how this function handles calls from Java, as this pattern frequently appears during reverse engineering. Let’s also take a look at the <code>MainActivity.java</code> file to see how the <code>native-lib.cpp</code> library is loaded and how the native function is called.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-keyword">package</span> com.example.myapplication;

<span class="hljs-keyword">import</span> androidx.appcompat.app.<span class="hljs-type">AppCompatActivity</span>;
<span class="hljs-keyword">import</span> android.os.<span class="hljs-type">Bundle</span>;
<span class="hljs-keyword">import</span> android.view.<span class="hljs-type">View</span>;
<span class="hljs-keyword">import</span> android.widget.<span class="hljs-type">TextView</span>;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>{
    <span class="hljs-type">TextView</span> message;

    <span class="hljs-comment">// Used to load the 'myapplication' library on application startup.</span>
    static {
        <span class="hljs-type">System</span>.loadLibrary(<span class="hljs-string">"myapplication"</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="hljs-type">R</span>.layout.activity_main);

        message = (<span class="hljs-type">TextView</span>)findViewById(<span class="hljs-type">R</span>.id.sample_text);
        message.setText(stringFromJNI());
    }

    <span class="hljs-comment">/**
     * A native method that is implemented by the 'myapplication' native library,
     * which is packaged with this application.
     */</span>
    public native <span class="hljs-type">String</span> stringFromJNI();
}
</code></pre>
<p>Inside the <code>MainActivity</code> class we can see the line <code>System.loadLibrary(&quot;myapplication&quot;);</code>. This is where the library is loaded statically, defined by the name <code>myapplication</code>. Listing the content of the file <code>App</code> -&gt; <code>cpp</code> -&gt; <code>CMakeLists.txt</code> reveals the following snippet.</p>
<p>Code: cmake</p>
<pre><code class="lang-cmake">add_library( <span class="hljs-comment"># Sets the name of the library.</span>
        myapplication

        <span class="hljs-comment"># Sets the library as a shared library.</span>
        SHARED

        <span class="hljs-comment"># Provides a relative path to your source file(s).</span>
        native-<span class="hljs-class"><span class="hljs-keyword">lib</span>.<span class="hljs-title">cpp</span>)</span>
</code></pre>
<p>As we can see, the name of the file <code>native-lib.cpp</code> is set to <code>myapplication</code>. The <code>CMakeLists.txt</code> is used to describe the files of the native C++ project. Back to the <code>MainActivity.java</code> we can also see the line <code>public native String stringFromJNI();</code>, which indicates the declaration of the native method <code>stringFromJNI()</code>. This method returns the string <code>Hello from C++</code> that we saw earlier in the <code>native-lib.cpp</code> file, and it is then printed on the screen through the <code>TextView message</code> object.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/native_start_app_transparent_4.png" alt="Mobile app screen titled &quot;My Application&quot; with text &quot;Hello from C++&quot; centered on a white background."></p>
<p>We are not limited to only loading a library statically. Libraries can be loaded while the application is running as well. The following snippet of code shows a class that loads the library while the app is running.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Update {
    <span class="hljs-comment">// Method declaration</span>
    <span class="hljs-keyword">public</span> native <span class="hljs-keyword">String</span> stringFromJNI();

    <span class="hljs-comment">// Copy the file locally and load it</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> update(<span class="hljs-keyword">String</span> path_sd_card, <span class="hljs-keyword">String</span> filesDir){
        FileOutputStream outputStream;
        FileInputStream inputStream;

        <span class="hljs-built_in">try</span> {
            inputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(path_sd_card + <span class="hljs-string">"/Download/libupgrade.so"</span>));
            outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(filesDir + <span class="hljs-string">"/libupgrade.so"</span>));

            FileChannel inChannel = inputStream.getChannel();
            FileChannel outChannel = outputStream.getChannel();
            inChannel.transferTo(<span class="hljs-number">0</span>, inChannel.<span class="hljs-built_in">size</span>(), outChannel);
            inputStream.<span class="hljs-built_in">close</span>();
            outputStream.<span class="hljs-built_in">close</span>();
        } <span class="hljs-built_in">catch</span> (IOException e) {
            e.printStackTrace();
        }

        System.load(filesDir + <span class="hljs-string">"/libupgrade.so"</span>);

        <span class="hljs-comment">// Returns the value of the function stringFromJNI() from the libupgrade.so file</span>
        <span class="hljs-built_in">return</span> stringFromJNI();
    }
}
</code></pre>
<p>After the file is copied into the application&#39;s home directory, the line <code>System.load(filesDir + &quot;/libupgrade.so&quot;);</code> loads the library. Bad code implementation could lead to remote command execution, a scenario we will see in a later module.</p>
<hr>
<h2 id="javascript-webviews">Javascript &amp; WebViews</h2>
<hr>
<p>WebViews are components that allow developers to embed and display web content directly within an Android application. While powerful, improper use of WebView features can introduce serious security risks-a common issue in Android apps. Poor WebView implementation can expose the app to a wide range of vulnerabilities, such cross-site scripting (XSS) and local file inclusion (LFI). Because of this, the official Android documentation recommends using the system&#39;s default browser to deliver web content whenever possible, instead of embedding it with a WebView.</p>
<p>In recent Android versions, the default WebView configuration has become more restrictive, mitigating many common attacks by default. However, developers often enable advanced features (such as JavaScript execution or file access) that must be handled with extreme care to avoid introducing vulnerabilities.</p>
<p>In the next section, we’ll walk through creating a simple application using WebViews, HTML, CSS, and JavaScript to better understand how WebViews function. Before we begin, make sure to create a new project as described in the Android Studio section. The following XML snippet will define a WebView element inside the <code>activity_main.xml</code> layout file.</p>
<p>Code: xml</p>
<pre><code class="lang-xml">&lt;WebView
        android:<span class="hljs-built_in">id</span>=<span class="hljs-string">"@+id/webview"</span>
        android:layout_width=<span class="hljs-string">"match_parent"</span>
        android:layout_height=<span class="hljs-string">"match_parent"</span> /&gt;
</code></pre>
<p>Let&#39;s now create a reference that points to this object, in the <code>MainActivity.java</code> file.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-keyword">package</span> com.example.myapplication;

<span class="hljs-keyword">import</span> androidx.appcompat.app.<span class="hljs-type">AppCompatActivity</span>;

<span class="hljs-keyword">import</span> android.os.<span class="hljs-type">Bundle</span>;
<span class="hljs-keyword">import</span> android.webkit.<span class="hljs-type">WebView</span>;

public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="hljs-type">R</span>.layout.activity_main);

        <span class="hljs-type">WebView</span> webview = (<span class="hljs-type">WebView</span>) findViewById(<span class="hljs-type">R</span>.id.webview);
        webview.getSettings().setJavaScriptEnabled(<span class="hljs-literal">true</span>);
        webview.loadUrl(<span class="hljs-string">"file:///android_asset/html/index.html"</span>);
    }
}
</code></pre>
<p>The above code will create a reference to the WebView object and load the <code>index.html</code> file, which we are going to create next. The line <code>webview.getSettings().setJavaScriptEnabled(true);</code> means that the WebView is allowed to execute Javascript code, and this is where vulnerabilities can occur. Android Studio displays the following message if this feature is used in the code.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/javascript_webview_warning-2.png" alt="Code snippet enabling JavaScript in a WebView with a warning about potential XSS vulnerabilities. Details: setJavaScriptEnabled(true), API level 1, default is false. Options to suppress warning or view more actions."></p>
<p>The HTML and Javascript files are usually placed under the folder <code>app/assets</code> (or from the Project view: <code>app/src/main/assets</code>). If the folder is missing, we can simply right-click on <code>app</code> and create a new folder named <code>assets</code>. The following is an example of a project structure that includes HTML, CSS, and Javascript.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/javascript_file_stracture-3.png" alt="Project Explorer showing app structure: manifests, java, generated java, assets with css (style.css), html (index.html), js (script.js)."></p>
<p>Here are the snippets of the <code>index.html</code> and the <code>script.js</code> files. The HTML code calls the Javascript function <code>printMessage()</code> which then prints the message <code>Hello from Javascript</code> to the screen.</p>
<p>Code: html</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"../css/style.css"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/script.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="undefined">printMessage()</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>Code: javascript</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printMessage</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">"Hello from Javascript"</span>);
}
</code></pre>
<p><img src="https://academy.hackthebox.com/storage/modules/195/javascript_start_app_transparent_2.png" alt="Mobile app screen titled &quot;My Application&quot; with text &quot;Hello from Javascript&quot; centered on a white background."></p>
<p>WebViews can also load content from sources outside the local project. Assuming we want to load Google&#39;s home page in the app we just created, then the <code>webview.loadUrl(&quot;file:///android_asset/html/index.html&quot;);</code> will change to <code>webview.loadUrl(&quot;https://www.google.com/&quot;);</code>.</p>
<p>The permission <code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code> also needs to be added to the <code>AndroidManifest.xml</code> file, before the <code>&lt;application&gt; &lt;/application&gt;</code> tags.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/javascript_permissions-2.png" alt="XML code snippet for Android manifest. Includes permission for internet access: \&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;."></p>
<p>The picture below shows the Google page embedded in the app we created.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/javascript_webview_google_transparent_2.png" alt="Mobile app screen titled &quot;My Application&quot; displaying the Google logo with a search bar below."></p>
<p>\</p>
<hr>
<h2 id="application-frameworks">Application Frameworks</h2>
<hr>
<p>Building Android applications from scratch can be challenging as it requires knowledge of multiple languages and tools. Consequently, Android developers often use frameworks to develop applications faster, with better code quality, and simpler maintainability. An application framework is a set of libraries that provides developers with a structured way to build applications using pre-built components and tools. These often include UI elements, security and authentication mechanisms, error handling, logging systems, and more. Different application frameworks are used across various IDEs (Integrated Development Environments) and programming languages, which increases the overall attack surface. As a result, different methodologies are required when performing application penetration testing. In the following sections, we’ll explore some examples of using the most popular application frameworks for Android development. These examples are only provided to enhance our understanding of the concepts, and you are not required to reproduce the steps.</p>
<hr>
<h3 id="flutter">Flutter</h3>
<p>Flutter is an open-source mobile application framework developed by Google. With Flutter, developers can build applications in the Dart programming language, using customizable widgets that can be combined to create complex user interfaces. As a cross-platform application framework, development is possible for Android, iOS, Web, and Desktop applications providing high performance through compiled native code.</p>
<p>Flutter application development can be done by downloading the Flutter SDK from the official <a href="https://flutter.dev/">website</a> and setting up an IDE (like Android Studio) with the Flutter and Dart plugins. In the following example, we will see a simple app created with Flutter and discuss the project&#39;s structure, so we can better understand it while performing static analysis in later sections. The following snippet is a simple <code>Hello World</code> application written in Dart.</p>
<p>Code: dart</p>
<pre><code class="lang-dart"><span class="hljs-keyword">import</span> <span class="hljs-symbol">'package</span>:flutter/material.dart';

void main() =&gt; runApp(<span class="hljs-type">MyApp</span>());

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  <span class="hljs-type">Widget</span> build(<span class="hljs-type">BuildContext</span> context) {
    <span class="hljs-keyword">return</span> <span class="hljs-type">MaterialApp</span>(
      title: <span class="hljs-symbol">'Hello</span> <span class="hljs-type">World</span> <span class="hljs-type">App</span>',
      home: <span class="hljs-type">Scaffold</span>(
        appBar: <span class="hljs-type">AppBar</span>(
          title: <span class="hljs-type">Text</span>(<span class="hljs-symbol">'My</span> <span class="hljs-type">Flatter</span> <span class="hljs-type">App</span>'),
        ),
        body: <span class="hljs-type">Center</span>(
          child: <span class="hljs-type">Text</span>(
            <span class="hljs-symbol">'Hello</span> from <span class="hljs-type">Flutter</span>',
            style: <span class="hljs-type">TextStyle</span>(fontSize: <span class="hljs-number">28</span>),
          ),
        ),
      ),
    );
  }
}
</code></pre>
<p>The above snippet of code will print the text <code>Hello from Flutter</code> in the center of the screen.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/flutter_hello_world_transparent_2.png" alt="Mobile app screen titled &quot;My Flutter App&quot; with text &quot;Hello from Flutter&quot; centered on a white background."></p>
<p>In the screenshot below, we can see that the project structure includes directories that contain data responsible for compatibility with various platforms. Alongside them, we can also see the directory <code>lib</code> that contains the file <code>main.dart</code>. This is where the Dart code resides.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/flutter_project_structure-2.png" alt="Project Explorer showing Flutter app structure: .dart\_tool, .idea, android, build, ios, lib with main.dart, linux, macos, test, web, windows."></p>
<p>As we mentioned earlier, Flutter compiles the code natively, and thus the app will store the compiled C++ code in shared libraries (.so files). However, penetration testers can still decode and examine the resources during the static analysis using the appropriate tools. Incidentally, reading the code of an application that includes native components requires a different approach than analyzing a typical Android app written in Java or Kotlin. This is because the tools used to decompile Java bytecode into human-readable pseudocode are not effective for shared libraries (.so files) containing compiled C or C++ code. Analyzing these native binaries requires specialized tools and techniques, which will be covered in later sections.</p>
<hr>
<h3 id="xamarin">Xamarin</h3>
<p>Xamarin is a cross-platform application development framework that supports building Android, iOS, and desktop applications. Owned by Microsoft, Xamarin allows developers to create Android apps using C# as the primary programming language within Visual Studio. To get started, you can install the Mobile development with .NET workload in Visual Studio. The following snippet shows a simple &quot;Hello World&quot; application written in C# using Xamarin.</p>
<p>Code: c</p>
<pre><code class="lang-c"><span class="hljs-keyword">using</span> Android.App;
<span class="hljs-keyword">using</span> Android.OS;
<span class="hljs-keyword">using</span> Android.Runtime;
<span class="hljs-keyword">using</span> Android.Widget;
<span class="hljs-keyword">using</span> AndroidX.AppCompat.App;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">MyApplication</span>
{
    [Activity(Label = <span class="hljs-string">"@string/app_name"</span>, Theme = <span class="hljs-string">"@style/AppTheme"</span>, MainLauncher = <span class="hljs-literal">true</span>)]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-title">AppCompatActivity</span>
    {
        Button button;
        TextView message;

        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span>(<span class="hljs-params">Bundle savedInstanceState</span>)
        </span>{
            <span class="hljs-keyword">base</span>.OnCreate(savedInstanceState);
            Xamarin.Essentials.Platform.Init(<span class="hljs-keyword">this</span>, savedInstanceState);
            <span class="hljs-comment">// Set our view from the "main" layout resource</span>
            SetContentView(Resource.Layout.activity_main);

            message = FindViewById&lt;TextView&gt;(Resource.Id.message);
            button = FindViewById&lt;Button&gt;(Resource.Id.button);

            button.Click += (sender, args) =&gt;
            {
                message.Text = <span class="hljs-string">"Hello World!"</span>;
            };
        }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnRequestPermissionsResult</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">string</span>[] permissions, [GeneratedEnum] Android.Content.PM.Permission[] grantResults</span>)
        </span>{
            Xamarin.Essentials.Platform.OnRequestPermissionsResult(requestCode, permissions, grantResults);
            <span class="hljs-keyword">base</span>.OnRequestPermissionsResult(requestCode, permissions, grantResults);
        }
    }
}
</code></pre>
<p>The above application will print the message <code>Hello World!</code> on the screen once the button is pressed.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/xamarin_hello_world_transparent_3.png" alt="Mobile app screen titled &quot;MyApplication&quot; with text &quot;My Application&quot; at the top, a blue &quot;BUTTON&quot; in the center, and &quot;Hello World!&quot; at the bottom."></p>
<p>The screenshot below shows the project structure of a Xamarin application in Visual Studio.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/xamarin_project_structure-2.png" alt="Solution Explorer showing MyApplication structure: References, Packages (3 updates), Assets, Properties with AndroidManifest.xml, Resources with drawable, layout (activity\_main.xml), mipmap folders, values, AboutResources.txt, Resource.designer.cs, MainActivity.cs."></p>
<p>When creating a Xamarin app, the C# source code is compiled into Common Intermediate Language (CIL) using the .NET compiler. This intermediate code is then interpreted or just-in-time compiled into platform-specific machine code at runtime, depending on the target environment. Unlike native C++ code, which is compiled into shared libraries (.so files), Xamarin applications bundle their intermediate code as .NET assemblies (.dll files), often packaged inside a single file like assemblies.blob.</p>
<p>Since Xamarin apps contain intermediate code rather than native binaries, the reverse engineering process differs from analyzing native C++ or Java/Kotlin applications. The extracted .dll files can be loaded into .NET reverse engineering tools (such as ILSpy, dnSpy, or dotPeek) to recover readable pseudocode. These methodologies will be discussed in later sections.</p>
<hr>
<h3 id="other-frameworks">Other Frameworks</h3>
<p>More application development frameworks can be used to create Android applications, with some of them being <code>React Native</code>, <code>Apache Cordova</code> (formerly <code>PhoneGap</code>), and <code>Ionic</code>. These frameworks can create hybrid cross-platform applications that run on Android, iOS, and web browsers using web-based technologies like Javascript, HTML, and CSS. We can install these frameworks using the NPM (Node Package Manager) command-line tool and start the development on Android Studio. Applications can then run on a Physical or virtual device. The following snippet is a simple <code>Hello World</code> using the React Native framework. This <a href="https://reactnative.dev/docs/environment-setup">page</a> will guide you through building and running a React Native app.</p>
<p>Code: react</p>
<pre><code class="lang-react"><span class="hljs-keyword">import</span> { StatusBar } <span class="hljs-keyword">from</span> <span class="hljs-string">'expo-status-bar'</span>;
<span class="hljs-keyword">import</span> { StyleSheet, Text, View } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.container}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.text}</span>&gt;</span>Hello From React Native<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">StatusBar</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"auto"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
  text: {
    fontSize: 28,
  },
});</span>
</code></pre>
<p>The snippet above will print <code>Hello From React Native</code> on the screen.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/react_hello_world_transparent_2.png" alt="Mobile app screen with text &quot;Hello From React Native&quot; centered on a white background."></p>
<p>When an application is developed using React Native, the majority of the application&#39;s logic and UI are written in JavaScript. The framework will also create the MainActivity and other necessary Java classes that act as the entry point for your application. When the application is prepared for release, the JavaScript code will be bundled into a standalone file called <code>index.android.bundle</code>. This file is optimized and minified to improve performance and reduce the overall size of the application. While reversing apps created with React Native, apart from analyzing the Java code to identify the necessary entry points, testers should also analyze the Javascript code bundled in the <code>index.android.bundle</code> file. Another thing testers should keep in mind is that the attack surface will be different than native apps. Apps created with such frameworks may be susceptible to web vulnerabilities since they use web technologies.</p>
<p>On the other hand, apps created with Cordova and Ionic frameworks use a WebView component to render the user interface and execute the application code, which is HTML, CSS, and JavaScript. When we build an app using Cordova or Ionic, the web assets (HTML, CSS, JavaScript files) are packaged within the application as part of the project structure and can be found during reverse engineering under the directories <code>assets/www/</code> and <code>assets/public/</code> accordingly. Reversing apps created with such frameworks will be further discussed in a later section.</p>
<hr>
<h2 id="activities">Activities</h2>
<hr>
<h3 id="application-components">Application Components</h3>
<p>Application components are the building blocks that define different parts of an Android application, such as the user interface and core functionality. These components are declared in the <code>AndroidManifest.xml</code> and can be used individually or in tandem with one another. <code>Interprocess Communication</code> (IPC) is a mechanism that allows for communication between applications or different processes within the same application. In the second case, applications usually consist of components that run in different processes, including <code>Activities</code>, <code>Services</code>, <code>Broadcast Receivers</code>, and <code>Content Providers</code>. As we mentioned in the previous sections, in Android each application runs in its own process, and thus, IPC has to make sure that applications have a way to communicate with each other when necessary. In the following paragraphs, we will discuss some of the most essential Application Components and Interprocess Communication mechanisms.</p>
<h3 id="activities-introduction">Activities Introduction</h3>
<p>Activities are a fundamental application component, representing a single screen with a user interface and able to be presented in several modes, such as <code>full-screen</code>, <code>floating</code>, <code>embedded,</code> or <code>multi-window</code>. An Activity is the main component that allows the interaction between the user and the app, and can be started by other Activities, apps, or system events. Apart from managing and handling the application&#39;s user interface and interaction, Activities are also responsible for managing the app&#39;s lifecycle.</p>
<hr>
<h3 id="activity-lifecycle">Activity Lifecycle</h3>
<p>The lifecycle of an activity consists of six major stages called callbacks. The class below defines the entire lifecycle of an activity.</p>
<p>Code: java</p>
<pre><code class="lang-java"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Activity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationContext</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>;
     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span></span>;
     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRestart</span><span class="hljs-params">()</span></span>;
     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span>;
     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span></span>;
     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span></span>;
     <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span></span>;
 }
</code></pre>
<p>The system invokes the corresponding callback whenever an Activity enters a new state. Note that an application may only use some of the callbacks. The diagram below shows the lifecycle of an Activity.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/activity_lifecycle-5.png" alt="Flowchart of Android activity lifecycle: Activity launched, onCreate(), onStart(), onResume() (Activity running), onPause() (another activity in foreground), onStop() (activity not visible), onDestroy() (activity shut down). Includes paths for onRestart() and app process killed."></p>
<p>Next, we will describe the main stages of the activity lifecycle.</p>
<p><strong>onCreate()</strong></p>
<p>In this stage, the activity is first created, and developers can initialize tasks like setting up the user interface, binding data to views, and configuring listeners or handlers. When a new Android project is created, the Android Studio automatically generates the class <code>MainActivity.java</code> which contains the method <code>onCreate()</code>. This is the method called during this stage. The following snippet shows an example of the <code>onCreate()</code> method.</p>
<p>Code: java</p>
<pre><code class="lang-java">@<span class="hljs-keyword">Override</span>
protected void onCreate(Bundle savedInstanceState) {
    <span class="hljs-selector-tag">super</span><span class="hljs-selector-class">.onCreate</span>(<span class="hljs-selector-tag">savedInstanceState</span>);
    <span class="hljs-selector-tag">setContentView</span>(<span class="hljs-selector-tag">R</span><span class="hljs-selector-class">.layout</span><span class="hljs-selector-class">.activity_main</span>);

        <span class="hljs-selector-tag">Toast</span><span class="hljs-selector-class">.makeText</span>(<span class="hljs-selector-tag">this</span>, "<span class="hljs-selector-tag">This</span> <span class="hljs-selector-tag">message</span> <span class="hljs-selector-tag">will</span> <span class="hljs-selector-tag">be</span> <span class="hljs-selector-tag">displayed</span> <span class="hljs-selector-tag">on</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">app</span> <span class="hljs-selector-tag">start-up</span>.", <span class="hljs-selector-tag">Toast</span><span class="hljs-selector-class">.LENGTH_SHORT</span>)<span class="hljs-selector-class">.show</span>();
}
</code></pre>
<p>This method takes only one parameter, the <code>Bundle savedInstanceState</code>, which contains the activity&#39;s previously saved state. The above snippet will print the message on the screen as soon as the app starts. Since many initializations typically occur within this method (including the loading or initialization of sensitive information such as hard-coded credentials or keys), it serves as a key entry point for penetration testers during assessments. Another reason pentesters should pay attention during the examination of this method is that data is often passed as parameters whenever an activity is launched by an <code>Intent</code>, which we will see later in this section. This usually happens when the developer wants to send data from one activity to another, like session tokens or other values needed for the smooth operation of the application.</p>
<p><strong>onStart()</strong></p>
<p>Once the <code>Created</code> callback has been completed, it is always followed by the <code>Started</code> callback, where everything becomes visible to the user. The method <code>onStart()</code> is called when the activity is brought to the foreground and starts interacting with the user. At this point, resources are typically initialized in this lifecycle stage.</p>
<p><strong>onResume()</strong></p>
<p>Once the activity starts interacting with the user, the <code>onResume()</code> method will be called. Animations and other media, or interaction with the user, typically take place in this stage of the lifecycle. The Paused callback always follows this stage.</p>
<p><strong>onPause()</strong></p>
<p>If the user switches to another app or a dialog appears on top of the activity, it will no longer be active or focused. In this state, although the activity will remain visible to the user, any resource no longer needed is released. It is followed by the <code>onResume()</code> or the <code>onStop()</code> callbacks.</p>
<p><strong>onStop()</strong></p>
<p>At this point, the activity is no longer visible to the user and the resources are released. This activity is followed by either <code>onRestart()</code> or <code>onDestroy()</code>.</p>
<p><strong>onDestroy</strong></p>
<p>At this point, if the system needs any memory or space resources, the activity will be destroyed to free them up. The activity will also be destroyed if the user chooses to close the activity.</p>
<p><strong>onRestart()</strong></p>
<p>In case the activity is restarting after having been stopped, the <code>onRestart()</code> will be called, followed by the <code>onStart()</code>. Initializations can be done again if needed at this point.</p>
<hr>
<h3 id="launching-an-activity">Launching an Activity</h3>
<p>Launching an Activity in Android is a fundamental concept. An Activity represents a single screen with a user interface responsible for managing user interaction with the application. The following steps describe what is happening while launching an Activity.</p>
<p><strong>Intent creation</strong></p>
<p>To start an Activity programmatically, we first create an Intent object. Intents are messaging objects used to request an action from another component from the same or other applications. The target Activity and any other additional data required can be specified in the Intent object.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-comment">// In the source Activity (e.g., MainActivity.java)</span>
Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, TargetActivity.<span class="hljs-keyword">class</span>);
<span class="hljs-comment">// Optionally, you can add extra data to the Intent</span>
intent.putExtra(<span class="hljs-string">"key"</span>, <span class="hljs-string">"test"</span>);
</code></pre>
<p>As we can see, the parameter <code>key</code> with the value <code>test</code> has also been passed using the property <code>putExtra()</code>.</p>
<p><strong>Requesting Activity launch</strong></p>
<p>Next, the <code>startActivity()</code> or <code>startActivityForResult()</code> is called from the source Activity, passing the Intent object as a parameter. The <code>startActivity()</code> is used to launch an Activity without expecting any result back, while <code>startActivityForResult()</code> is used when we expect results from the launched Activity.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-comment">// For launching an Activity without expecting any result back</span>
startActivity(intent);

<span class="hljs-comment">// For launching an Activity and expecting a result back</span>
<span class="hljs-keyword">int</span> requestCode = <span class="hljs-number">1</span>; <span class="hljs-comment">// A unique integer request code to identify the result</span>
startActivityForResult(intent, requestCode);
</code></pre>
<p><strong>Activity stack management</strong></p>
<p>The Android operating system maintains an Activity stack as part of the task that the app belongs to. When a new Activity is launched, it&#39;s placed on top of the stack and becomes the active Activity. The previous Activity is paused and remains in the stack. The following image shows the progress between activities and the current back stack at each point.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/diagram_backstack-5.png" alt="Diagram of activity back stack: Start Activity 2, then Activity 3. Foreground activity changes from Activity 1 to 3. Navigate back to Activity 2 after Activity 3 is destroyed."></p>
<p><strong>Activity lifecycle transitions</strong></p>
<p>In this stage, the source Activity&#39;s <code>onPause()</code> method is called, and it becomes inactive. Meanwhile, the target Activity goes through a series of lifecycle methods, including <code>onCreate()</code>, <code>onStart()</code>, and <code>onResume()</code>, initializing its UI, setting up required resources, and starting any necessary background tasks. The necessary lifecycle methods should be implemented in the target Activity (e.g., <code>TargetActivity.java</code>).</p>
<p>Code: java</p>
<pre><code class="lang-java">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TargetActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>{

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="hljs-type">R</span>.layout.activity_target);

        <span class="hljs-comment">// Get data from the Intent</span>
        <span class="hljs-type">String</span> data = getIntent().getStringExtra(<span class="hljs-string">"key"</span>);
    }

    <span class="hljs-comment">// Other lifecycle methods, like onStart(), onResume(), onPause(), onStop(), onDestroy()</span>
}
</code></pre>
<p><strong>User interaction</strong></p>
<p>The new Activity becomes visible and users can interact. When the user decides to navigate back, the current Activity is popped from the stack and its <code>onPause()</code>, <code>onStop()</code>, and <code>onDestroy()</code> lifecycle methods are called. The previous Activity in the stack becomes active again, resuming its <code>onRestart()</code>, <code>onStart()</code>, and <code>onResume()</code> lifecycle methods. If the target Activity needs to return any results, the code in it will look like this.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-comment">// Set result and finish the Activity</span>
<span class="hljs-type">Intent</span> resultIntent = <span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">Intent</span>();
<span class="hljs-title">resultIntent</span>.<span class="hljs-title">putExtra</span>("result_key", "result_value");
<span class="hljs-title">setResult</span>(<span class="hljs-type">RESULT_OK</span>, resultIntent);
<span class="hljs-title">finish</span>();</span>
</code></pre>
<p><strong>Returning a result (optional)</strong></p>
<p>If the launched Activity was started using <code>startActivityForResult()</code>, it can return results to the calling Activity. This is done by calling <code>setResult()</code> in the launched Activity, followed by <code>finish()</code>. The calling Activity will then receive the result in its <code>onActivityResult()</code> method, where it can process the data accordingly. In the source Activity, the method that handles the results would look like this.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> void onActivityResult(int requestCode, int resultCode, <span class="hljs-meta">@Nullable</span> Intent <span class="hljs-keyword">data</span>) {
    <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="hljs-keyword">data</span>);

    <span class="hljs-keyword">if</span> (requestCode == <span class="hljs-number">1</span>) { <span class="hljs-comment">// Match the request code used in startActivityForResult()</span>
        <span class="hljs-keyword">if</span> (resultCode == RESULT_OK &amp;&amp; <span class="hljs-keyword">data</span> != <span class="hljs-literal">null</span>) {
            String resultData = <span class="hljs-keyword">data</span>.getStringExtra(<span class="hljs-string">"result_key"</span>);
            <span class="hljs-comment">// Process the result data</span>
        }
    }
}
</code></pre>
<p>The following flowchart shows the above steps.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/activity_launching_flowchart-1.png" alt="Flowchart of activity result process: Source Activity creates Intent. If expecting result, use startActivityForResult; otherwise, use startActivity. Target Activity lifecycle: onCreate, onStart, onResume. User interaction may return result, setting it and finishing, or just finish. Result handled in onActivityResult."></p>
<p>Apart from starting an activity by tapping the icon or through other applications, this can be done using ADB (Android Debug Bridge). Android Debug Bridge is a command-line tool that allows you to communicate with an Android device (emulator or physical device). It is primarily used for debugging, development, and testing purposes. Accessing Activities with the <code>exported</code> attribute set to <code>true</code> directly from ADB is possible, and this can sometimes raise security concerns.</p>
<hr>
<h3 id="declaring-activities">Declaring Activities</h3>
<p>In order to use an Activity properly, you must declare it in your app&#39;s manifest file. In Android, this file is called <code>AndroidManifest.xml,</code> and as we mentioned in previous sections, it is a configuration file that provides essential information about the application to the Android system. This information includes the app components, permissions, and other metadata. After creating a new Activity, it should be declared using the <code>&lt;activity&gt;</code> element as a child of the <code>&lt;application&gt;</code> element, as shown in the example below. The <code>android:name</code> attribute should contain the fully qualified Activity class name.</p>
<p>Code: xml</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">package</span>=<span class="hljs-string">"com.example.myapp"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">application</span>
        <span class="hljs-attr">android:allowBackup</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">"@mipmap/ic_launcher"</span>
        <span class="hljs-attr">android:label</span>=<span class="hljs-string">"@string/app_name"</span>
        <span class="hljs-attr">android:roundIcon</span>=<span class="hljs-string">"@mipmap/ic_launcher_round"</span>
        <span class="hljs-attr">android:supportsRtl</span>=<span class="hljs-string">"true"</span>
        <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@style/AppTheme"</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Declare your Activity here --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MainActivity"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>

        <span class="hljs-comment">&lt;!-- Declare other Activities if needed --&gt;</span>
        <span class="hljs-comment">&lt;!-- &lt;activity android:name=".AnotherActivity" /&gt; --&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span>
</code></pre>
<p>In the above snippet, the <code>android.intent.action.MAIN</code> action indicates that the <code>MainActivity</code> is the entry point of the app. This means it is the first Activity launched when the app starts. This action is typically used for the home screen of an app. While the activity name <code>MainActivity</code> is usually used as an entry point in Android applications, this name can be changed. Identifying the entry point of an application is very important during penetration testing since testers can better understand the application&#39;s flow, functionality, and overall structure, discover possible attack surfaces and eventually identify potential vulnerabilities and weaknesses. The second property, <code>android.intent.category.LAUNCHER</code> tells the Android system that this Activity should be listed in the system&#39;s app launcher. So when the user taps on the application&#39;s icon in the launcher, this Activity should be started.</p>
<p>Some activities may include the attribute <code>exported</code>. This attribute is used to specify whether other apps on the device can access an app component. The <code>exported</code> attribute can be set on <code>&lt;activity&gt;</code>, <code>&lt;service&gt;</code>, <code>&lt;receiver&gt;</code>, and <code>&lt;provider&gt;</code> elements in the <code>AndroidManifest.xml</code> file, and it accepts the boolean values <code>true</code> or <code>false</code>. Setting the <code>exported</code> attribute to <code>true</code> means that other apps on the device can access and invoke the app component. This configuration might expose the app to security risks. The following example shows an activity with the <code>exported</code> attribute set to true.</p>
<p>Code: xml</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">...</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">activity</span>
            <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MyCustomActivity"</span>
            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"true"</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- Intent filters if needed --&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span>
</code></pre>
<hr>
<h2 id="services">Services</h2>
<hr>
<p>A Service is an Android application component that performs long-running operations in the background without providing a user interface. Services can be used for tasks like downloading files, playing music, or communicating with a remote server, and can continue working even after the user has left the app. There are three types of services in Android.</p>
<p><strong>Foreground Service</strong></p>
<p>Foreground services perform operations that require user attention. They will provide users with notifications and continue running, even when the app has no interaction or is minimized. Foreground services must display notifications to inform the users that the service is running. Examples of such services include media players and navigation apps. A foreground service can be started by calling the <code>startService()</code> method.</p>
<p><strong>Background Service</strong></p>
<p>Background services perform operations that do not require user interaction. Starting with Android API level 26 (Android 8.0 Oreo), background services are no longer allowed to run unless the application is in the foreground. This change was introduced to conserve system resources and optimize battery life.</p>
<p><strong>Bound Service</strong></p>
<p>Bound services allow other application components to bind to them by calling the <code>bindService()</code> method. They provide a client-server interface that enables components—even across different processes—to interact with the service using Interprocess Communication (IPC).</p>
<p>Services extend the <code>Service</code> class.</p>
<p>Code: java</p>
<pre><code class="lang-java">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>{
    int startMode;       <span class="hljs-comment">// indicates how to behave if the service is killed</span>
    <span class="hljs-type">IBinder</span> binder;      <span class="hljs-comment">// interface for clients that bind</span>
    boolean allowRebind; <span class="hljs-comment">// indicates whether onRebind should be used</span>
    ...
    }
}
</code></pre>
<p>Similar to activities, services have lifecycle callback methods that must be implemented to monitor changes in their state. The following diagram shows the service&#39;s lifecycle callback methods. On the left, the service is created using <code>startService()</code>, while on the right, using <code>bindService()</code>.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/service_lifecycle-3.png" alt="Flowchart comparing unbounded and bounded service lifecycles. Unbounded: startService(), onCreate(), onStartCommand(), service running, stopped by itself or client, onDestroy(), shut down. Bounded: bindService(), onCreate(), onBind(), clients bound, unbindService(), onUnbind(), onDestroy(), shut down. Active lifetime highlighted."></p>
<p>Services must be declared in the <code>AndroidManifest.xml</code> file.</p>
<p>Code: xml</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">...</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">service</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MyForegroundService"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">service</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MyBackgroundService"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span>
</code></pre>
<hr>
<h2 id="broadcast-receivers">Broadcast Receivers</h2>
<hr>
<p>Broadcast Receivers can be considered as both Application Components and Interprocess Communication (IPC) mechanisms. As an IPC mechanism, Broadcast Receivers enable communication between different applications by sending and receiving Intents. These Intents can be sent by the Android system, other apps, or the app itself. As an Application Component, Broadcast Receivers are designed to respond to system-wide or custom events broadcasted by other applications. Broadcast Receivers can act as a messaging system between different components across the Android ecosystem. For example, the system broadcasts an event when the device starts charging. Similarly, an app can send a custom broadcast to let other apps know that new data has been downloaded. Broadcast Receivers extend the <code>BroadcastReceiver</code> class and override the <code>onReceive()</code> method to match a specified Intent Filter declared in the <code>AndroidManifest.xml</code>. The following example shows a Broadcast Receiver handling an event where the device is charging.</p>
<p>Code: java</p>
<pre><code class="lang-java">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBroadcastReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> </span>{
    <span class="hljs-meta">@Override</span>
    public void onReceive(<span class="hljs-type">Context</span> context, <span class="hljs-type">Intent</span> intent) {
        <span class="hljs-type">String</span> action = intent.getAction();

        <span class="hljs-keyword">if</span> (action != <span class="hljs-literal">null</span>) {
            switch (action) {
                <span class="hljs-keyword">case</span> <span class="hljs-type">Intent</span>.<span class="hljs-type">ACTION_POWER_CONNECTED</span>:
                    <span class="hljs-comment">// Handle the power connected event</span>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-type">Intent</span>.<span class="hljs-type">ACTION_POWER_DISCONNECTED</span>:
                    <span class="hljs-comment">// Handle the power disconnected event</span>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-comment">// Handle other actions as needed</span>
                    <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</code></pre>
<p>Broadcast Receivers also need to be declared in the <code>AndroidManifest.xml</code> file.</p>
<p>Code: xml</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">...</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MyBroadcastReceiver"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.ACTION_POWER_CONNECTED"</span> /&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.ACTION_POWER_DISCONNECTED"</span> /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span>
</code></pre>
<p>The following methods are used for sending broadcasts to different kinds of receivers.</p>
<table>
<thead>
<tr>
<th><strong>Method</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sendOrderedBroadcast(Intent, String)</code></td>
<td>Sends broadcasts to one receiver at a time.</td>
</tr>
<tr>
<td><code>sendBroadcast(Intent)</code></td>
<td>Sends broadcasts to all receivers in an undefined order.</td>
</tr>
<tr>
<td><code>localBroadcastManager.sendBroadcast(intent)</code></td>
<td>Send Intent broadcasts to local objects within your process. This method is deprecated since API 28, and <code>LiveData</code> is used instead.</td>
</tr>
</tbody>
</table>
<p>Similar to Activities, broadcasting messages through ADB is also possible, which will be discussed in later sections. Beginning with Android 8.0 (API level 26), the system imposes additional restrictions on manifest-declared receivers. Manifest can not be used to declare receivers for most implicit broadcasts (broadcasts that don&#39;t target your app specifically). However, exceptions exist and can be found <a href="https://developer.android.com/guide/components/broadcast-exceptions">here</a>.</p>
<hr>
<h2 id="content-providers">Content Providers</h2>
<hr>
<p>Content Providers can be considered as Application Components and Interprocess Communication (IPC) mechanisms. As an IPC mechanism, Content Providers enable communication between applications by allowing them to access, modify, or delete data using a consistent interface through the <code>ContentResolver</code> class. As an application component, Content Providers are responsible for managing and exposing data structures within or to other apps. At the same time, they allow data sharing between different components in the app or with external apps. In other words, they act as the intermediate between the app and its underlying data storage. Content Providers use a standardized API based on the CRUD (Create, Read, Update, Delete) operations to interact with data. The data handled by a Content Provider can be stored in multiple structures, including local SQLite databases, the device&#39;s internal or external storage, or even on a remote server.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/content-provider-overview-3.png" alt="Diagram showing your application with content provider implementation connected to data storage and other applications."></p>
<p>Accessing a <code>ContentProvider</code> is typically done asynchronously in the background using a <code>CursorLoader</code> to execute queries. The <code>Activity</code> or UI component initiates a request to the <code>CursorLoader</code>, which performs the query by accessing the <code>ContentProvider</code> via the <code>ContentResolver</code>. This approach keeps the UI responsive while executing the query. The process involves multiple components, as demonstrated in the following image.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/content-provider-interaction-3.png" alt="Flowchart showing data flow: Activity or Fragment to CursorLoader, to ContentResolver, to ContentProvider, connected to Data Storage."></p>
<p>The following code snippet retrieves words and their locales from the User Dictionary Provider. A <a href="https://developer.android.com/reference/android/provider/UserDictionary">User Dictionary Provider</a> is a <code>ContentProvider</code> in Android that manages the user&#39;s custom dictionary. To achieve this, it calls <code>ContentResolver.query()</code>, which in turn invokes the <code>ContentProvider.query()</code> method implemented by the User Dictionary Provider.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-comment">// Queries the user dictionary and returns results</span>
<span class="hljs-built_in">cursor</span> = getContentResolver().query(
    UserDictionary.Words.CONTENT_URI,  <span class="hljs-comment">// The content URI of the words table</span>
    projection,                        <span class="hljs-comment">// The columns to return for each row</span>
    selectionClause,                   <span class="hljs-comment">// Selection criteria</span>
    selectionArgs,                     <span class="hljs-comment">// Selection criteria</span>
    sortOrder);                        <span class="hljs-comment">// The sort order for the returned rows</span>
</code></pre>
<p>Content Providers extend the <code>ContentProvider</code> class.</p>
<p>Code: java</p>
<pre><code class="lang-java">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContentProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContentProvider</span> </span>{
    <span class="hljs-comment">// Implement required CRUD methods and other logic here</span>
}
</code></pre>
<p>Content Providers, along with the <a href="https://developer.android.com/guide/topics/providers/content-provider-basics#Permissions">permissions</a> required to access the provider&#39;s data, must be declared in the <code>AndroidManifest.xml</code> file.</p>
<p>Code: xml</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">...</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">provider</span>
            <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MyContentProvider"</span>
            <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">"com.example.myapp.provider"</span>
            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"false"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span>
</code></pre>
<p>Similar to Activities and Broadcast Receivers, Content Providers can be accessed using the Android Debug Bridge (ADB) through the terminal.</p>
<hr>
<h2 id="intents">Intents</h2>
<hr>
<p>As mentioned in the previous section, <code>Intents</code> are messaging objects used by applications or the Android system to request actions from other components such as Activities, Services, and Broadcast receivers. While Intents are not primarily designed for Interprocess Communication (IPC), they may be used when an application wants to interact with a component (such as a service) that resides in a different process. There are three essential use cases for Intents, shown below with practical examples.</p>
<p><strong>Starting an Activity</strong></p>
<p>Intents are commonly used to launch new activities, passing data between components.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-comment">/* Navigating from a list of contacts to a detailed view of the selected contact. 
   In the source Activity (ContactListActivity.java), an explicit Intent tells 
   Android to launch the target Activity (ContactDetailActivity.java) and passes 
   the selected contact's ID as extra data. This allows the target activity to 
   retrieve and display the correct contact details. */</span>

Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, ContactDetailActivity.<span class="hljs-keyword">class</span>);
intent.putExtra(<span class="hljs-string">"contact_id"</span>, selectedContactId);
startActivity(intent);
</code></pre>
<p><strong>Starting a Service</strong></p>
<p>Services are used for background operations, and Intents are used to start or bind to them.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-comment">/* Downloading a file in the background. This code starts a background Service
   (DownloadService) to handle a file download. An explicit Intent specifies the
   target Service class and attaches the file URL as extra data. The Service can
   then retrieve the URL from the Intent and begin the download operation in the 
   background. */</span>

Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, DownloadService.<span class="hljs-keyword">class</span>);
intent.putExtra(<span class="hljs-string">"file_url"</span>, fileUrl);
startService(intent);
</code></pre>
<p><strong>Delivering a Broadcast</strong></p>
<p>Broadcasts allow apps to send or listen for system-wide or app-specific events.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-comment">/* Informing other components that the battery is low. This code sends a custom
   broadcast with the action string `com.example.ACTION_BATTERY_LOW`. Any component 
   (within the same app or across apps) that has registered a BroadcastReceiver with
   a matching Intent filter will be notified when this broadcast is sent. */</span>

Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-type">Intent</span>(<span class="hljs-string">"com.example.ACTION_BATTERY_LOW"</span>);
sendBroadcast(intent);
</code></pre>
<p>Next we will examine the two types of Intent IPC.</p>
<p><strong>Explicit Intents</strong></p>
<p>Explicit Intents are commonly used for navigating between activities within the same app or starting services. The target component (activity, service, or broadcast receiver) should be known and can be created by specifying the target component&#39;s class name in the Intent constructor.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-keyword">Intent</span> <span class="hljs-keyword">intent</span> = new <span class="hljs-keyword">Intent</span>(this, TargetActivity.<span class="hljs-keyword">class</span>);
startActivity(<span class="hljs-keyword">intent</span>);
</code></pre>
<p><strong>Implicit Intents</strong></p>
<p>Implicit Intents are used when we don&#39;t know the exact target component, but know the action we want to perform and want the system to find a suitable component to handle the request. To create an implicit Intent, we must specify the action and the data (URI).</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-keyword">Intent</span> <span class="hljs-keyword">intent</span> = new <span class="hljs-keyword">Intent</span>(<span class="hljs-keyword">Intent</span>.ACTION_VIEW);
<span class="hljs-keyword">intent</span>.setData(Uri.parse(<span class="hljs-string">"https://www.example.com"</span>));
startActivity(<span class="hljs-keyword">intent</span>);
</code></pre>
<p>In addition, Intents can also carry data between components in the form of key-value pairs called <code>extras</code>.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-keyword">Intent</span> <span class="hljs-keyword">intent</span> = new <span class="hljs-keyword">Intent</span>(this, TargetActivity.<span class="hljs-keyword">class</span>);
<span class="hljs-keyword">intent</span>.putExtra(<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>);
startActivity(<span class="hljs-keyword">intent</span>);
</code></pre>
<p>The following image shows how an implicit intent is delivered through the system to start another activity.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/intent-filters_2x-5.png" alt="Flowchart showing Activity A using startActivity() to send an Intent to the Android System, which then calls onCreate() for Activity B. Steps labeled 1, 2, and 3."></p>
<p>Much like Application Components, Intents can be created using the Android Debug Bridge (ADB) through the terminal. Understanding and analyzing Intents while assessing an application is crucial—not only for gaining insight into the app’s flow but also for identifying potential security bypasses.</p>
<hr>
<h2 id="binders">Binders</h2>
<hr>
<p>The Binder is Android&#39;s core Interprocess Communication (IPC) mechanism, enabling efficient and secure communication between different processes. It is built on a Remote Procedure Call (RPC) model, allowing a client process to invoke methods on a remote object located in another process as if the object were local.</p>
<p>Throughout the following paragraphs, &quot;remote service&quot; refers to a service running within the same application but in a different process. Binders are typically used through a Service that implements an interface defined in an <a href="https://developer.android.com/develop/background-work/services/aidl">AIDL</a> file, which specifies the methods, parameters, and return values for IPC. The Service provides the requested functionality, while the Binder facilitates communication between the client and the service. The following code snippets demonstrate how a Service uses Binders to communicate with a remote client.</p>
<p><strong>ICalculator.aidl</strong></p>
<p>Here we see snippet of the <code>ICalculator.aidl</code> file containing the method&#39;s declaration.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span> {
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b</span>)</span>;
}
</code></pre>
<p>Next, we have a snippet of the <code>CalculatorService.java</code> file, which creates the service and implements the interface defined in the AIDL file.</p>
<p>Code: java</p>
<pre><code class="lang-java">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculatorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ICalculator</span>.<span class="hljs-type">Stub</span> binder = <span class="hljs-keyword">new</span> <span class="hljs-type">ICalculator</span>.<span class="hljs-type">Stub</span>() {
        <span class="hljs-meta">@Override</span>
        public int add(int a, int b) {
            <span class="hljs-keyword">return</span> a + b;
        }

    <span class="hljs-meta">@Override</span>
    public <span class="hljs-type">IBinder</span> onBind(<span class="hljs-type">Intent</span> intent) {
        <span class="hljs-keyword">return</span> binder;
    }
}
</code></pre>
<p><strong>MainActivity.java</strong></p>
<p>We now come to a snippet of the <code>MainActivity.java</code> file connecting and binding to the remote service <code>CalculatorService</code>, and subsequently calling its methods. <code>Connecting</code> to a service involves establishing a link with the service to communicate and interact with it, while <code>binding</code> to a service establishes a long-lasting connection between a client (such as an Activity) and a service. This allows the client to interact with the service, invoke its methods, and receive results synchronously.</p>
<p>Code: java</p>
<pre><code class="lang-java"><span class="hljs-comment">// Connecting to the remote service</span>
<span class="hljs-keyword">private</span> ServiceConnection serviceConnection = <span class="hljs-keyword">new</span> ServiceConnection() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> </span>{
        calculatorService = ICalculator.Stub.asInterface(service);
        performCalculations();
    }
        ...
};
....

<span class="hljs-comment">// Binding to the remote service</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>{
    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    Intent intent = <span class="hljs-keyword">new</span> Intent();
    intent.setComponent(<span class="hljs-keyword">new</span> ComponentName(<span class="hljs-string">"com.example.calculatorservice"</span>, <span class="hljs-string">"com.example.calculatorservice.CalculatorService"</span>));
    bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
}
...

<span class="hljs-comment">// Calling the methods</span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">performCalculations</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (calculatorService == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">int</span> additionResult = calculatorService.add(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);

        <span class="hljs-comment">// Use the results as needed, e.g., display them in the UI</span>
        <span class="hljs-comment">// ...</span>

    } <span class="hljs-keyword">catch</span> (RemoteException e) {
        e.printStackTrace();
    }
}
</code></pre>
<p>Binders are not declared in the manifest file directly, as they are a part of the Service implementation. However, if the Service runs in a different process, the attribute <code>android:process</code> should be specified in the <code>AndroidManifest.xml</code> file.</p>
<p>Code: xml</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">...</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">application</span> <span class="hljs-attr">...</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">service</span>
            <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MyService"</span>
            <span class="hljs-attr">android:process</span>=<span class="hljs-string">":remote"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span>
</code></pre>
<hr>
<h2 id="deep-links">Deep Links</h2>
<hr>
<p>A Deep Link is an Interprocess Communication (IPC) mechanism that allows users to navigate directly to specific content within an app by tapping a URL found on a website, email, or any other location where links can be placed.</p>
<p>For example, a user might receive a promotional email about a flash sale on a specific product. Instead of directing the user to the website, the link opens the corresponding app to display the product. In some cases, if the app is not installed, the user is redirected to the app store to download and install it.The are two types of Deep Links, the <code>Standard Deep Link</code>, and the <code>Android App Link</code>.</p>
<p><strong>Standard Deep Link</strong></p>
<p>The example below demonstrates a website that provides deep links to list its computer products through the mobile app. The source code of the website looks like this:</p>
<p>Code: html</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Buy our latest PC parts.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"app://myapp/products/cpu"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>In order for the above URL to open within the application, we must set up an <code>intent</code> filter in the <code>Androidmanifest.xml</code> file for the corresponding activity.</p>
<p>Code: xml</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">".ProductsActivity"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.VIEW"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.DEFAULT"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.BROWSABLE"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">"app"</span>
              <span class="hljs-attr">android:host</span>=<span class="hljs-string">"myapp"</span>
              <span class="hljs-attr">android:pathPrefix</span>=<span class="hljs-string">"/products/"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>
</code></pre>
<p>The table below provides a description of the most important elements of the above snippet.</p>
<table>
<thead>
<tr>
<th><strong>Element</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;activity android:name=&quot;.ProductsActivity&quot;&gt;</code></td>
<td>Defines the activity to be launched once the link is tapped.</td>
</tr>
<tr>
<td><code>android:scheme=&quot;app&quot;</code></td>
<td>Sets the protocol. It defines the <code>app</code> (can be anything) part of the URL <code>app://myapp/products/cpu</code> included in the website.</td>
</tr>
<tr>
<td><code>android:host=&quot;myapp&quot;</code></td>
<td>Sets the host. It defines the <code>myapp</code> (can be anything) part of the URL <code>app://myapp/products/cpu</code> included in the website.</td>
</tr>
<tr>
<td><code>android:pathPrefix=&quot;/products/&quot; /&gt;</code></td>
<td>Sets the path prefix. It defines the <code>/products/</code> part of the URL <code>app://myapp/products/cpu</code> included in the website.</td>
</tr>
</tbody>
</table>
<p>Now that we have set up the <code>intent</code> filter properly, let&#39;s take a look at the following Java snippet to see how it handles the incoming intent.</p>
<p>Code: java</p>
<pre><code class="lang-java">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="hljs-type">R</span>.layout.activity_planet);

        <span class="hljs-type">Intent</span> intent = getIntent();
        <span class="hljs-type">String</span> action = intent.getAction();
        <span class="hljs-type">Uri</span> data = intent.getData();

        <span class="hljs-keyword">if</span> (<span class="hljs-type">Intent</span>.<span class="hljs-type">ACTION_VIEW</span>.equals(action) &amp;&amp; data != <span class="hljs-literal">null</span>) {
            <span class="hljs-type">String</span> <span class="hljs-type">ProductName</span> = data.getLastPathSegment();

              <span class="hljs-keyword">if</span> (<span class="hljs-type">ProductName</span>.equals(<span class="hljs-string">"cpu"</span>)) {
                <span class="hljs-comment">// Do something. For example, query the database for information on this product.</span>
            }
        }
    }
}
</code></pre>
<p>In the above Java snippet, the <code>if()</code> statement checks if the value returned from the <code>data.getLastPathSegment()</code> method is equal to <code>cpu</code>. The value returned from the <code>data.getLastPathSegment()</code>method is actually the <code>cpu</code> part of the URL <code>app://myapp/products/cpu</code>.</p>
<p>This is how Android handles a Standard Deep Link. While deep linking is a powerful mechanism, security risks may arise from improper implementation. In the example above, the <code>android:scheme</code> attribute is set to <code>app</code>, and the <code>android:host</code> is set to <code>myapp</code>. However, Android does not enforce ownership verification for custom schemes, meaning any malicious app can declare itself as the default handler for that scheme, potentially leading to security vulnerabilities. To mitigate this risk, <code>Android App Links</code> should be used.</p>
<p><strong>Android App Link</strong></p>
<p>Assuming that the URL <code>https://www.myapp.com/</code> leads to an existing website, the deep link in it would look like this.</p>
<p>Code: html</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Buy our latest PC parts.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://www.myapp.com/products/cpu"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>Accordingly, the <code>Androidmanifest.xml</code> file will contain the following.</p>
<p>Code: xml</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">".ProductsActivity"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.VIEW"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.DEFAULT"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.BROWSABLE"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">"https"</span>
              <span class="hljs-attr">android:host</span>=<span class="hljs-string">"www.myapp.com"</span>
              <span class="hljs-attr">android:pathPrefix</span>=<span class="hljs-string">"/products/"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span>
</code></pre>
<p>We notice that the <code>android:scheme</code> attribute is set to <code>https</code>, and the <code>android:host</code> is set to <code>www.myapp.com</code>. In this case, if the app that handles the deep link isn&#39;t installed, the link will open in a web browser listing the products. This is a feature added on <code>Android 6.0</code> and higher, ensuring that only the verified domain owner can handle links to that domain within their app, and other potential malicious apps won&#39;t be able to handle this link.</p>
<p>On the other hand, bad programming could still lead to security issues. Imagine an application handling the URL <code>https://www.myapp.com/home?uid=50&amp;token=RLsB?19oYMAL6M5v</code>. If the app doesn&#39;t verify the <code>uid</code> and <code>token</code> parameters passed in via the deep link, a malicious actor could craft their own link with different parameter values, leading to unauthorized access to another user&#39;s data. To enhance security when using Deep Links, it is suggested to use <code>Android App Links</code> (which ensure links are verified and securely handled) instead of generic <code>Deep Links</code>. Additionally, one should validate the input of parameters and avoid passing sensitive data through URLs.</p>
<hr>
<h2 id="android-emulators">Android Emulators</h2>
<hr>
<p>Setting up the testing environment requires our host machine, an emulated Android device, and the tools we will use for the application penetration testing. In the following paragraphs, we will discuss various Android emulators and set up one we are going to be using during the next sections.</p>
<p>Android emulators are a vital tool for application penetration testers. They are programs allowing users to run Android applications and simulate the Android operating system on devices like personal computers. They are widely used for app development, testing, and gaming purposes. Android emulators are a cost-effective solution that allows testing applications on various devices and Android API levels without needing each physical device. Apart from this, emulators also provide most of the capabilities that a real device does, like simulating incoming phone calls and text messages, camera, Bluetooth, sensors, accessing the Google Play Store, and more. Penetration testers can benefit from emulators since they can simulate real-world scenarios and evaluate Android application vulnerabilities.</p>
<p>Most real Android devices use ARM or ARM64 CPU architecture, specifically designed for mobile devices and providing high-energy performance. However, Android emulators use x86 or x86_64 CPU architectures for better performance and compatibility with the host machine&#39;s hardware. Different CPU architectures can affect how exploits or vulnerabilities behave in emulated environments compared to real devices. In the following sections, we will use Android Virtual Device (AVD) for testing applications, which is included in the Android Studio IDE.</p>
<hr>
<h3 id="android-studio-avd">Android Studio AVD</h3>
<p>Android Studio&#39;s AVD is a fast and feature-rich emulator that allows us to test applications. It will help us run and debug applications developed with Android Studio in order to exploit other apps. Android Studio includes the AVD Manager, which simplifies creating, configuring, and managing Android Virtual Devices to simulate real-world scenarios. The following steps will show how to set up an Android Virtual Device (AVD) using Android Studio.</p>
<p>&#x20;Note: It is not recommended to run the Android emulator within a Virtual Machine, as nested virtualization can cause significant performance delays.</p>
<p>Since we have already seen how to install Android Studio and create a new project, let&#39;s jump directly to creating the AVD. In a new Android project, navigate to <code>Tools</code> -&gt; <code>Device Manager</code>.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/AVD_Tools-3.png" alt="System Image selection screen in Virtual Device Configuration. Tiramisu API Level 33, x86\_64, Android Tiramisu (Google APIs) is highlighted. Details on the right show API Level 33, Android Tiramisu by Google Inc., System Image x86\_64. Options to cancel, go to the previous or next step, and finish."></p>
<p>On the right side of the Android Studio, the <code>Device Manager</code> window will pop up, containing a default virtual device (Pixel 3a XL API 33) that might be created while installing Android Studio. The following image shows an example of the <code>Device Manager</code> window, having many devices created.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/AVD_Device_Manager-3.png" alt="Tools menu in an IDE with &quot;Device Manager&quot; highlighted. Options include Tasks &amp; Contexts, SDK Manager, Resource Manager, and more. Code editor visible in the background."></p>
<p>Let&#39;s see the process of creating a new device by clicking on the button under <code>Tools</code> -&gt; <code>Device Manager</code> -&gt; <code>Create device</code>. Along with other properties, an AVD contains a hardware profile that defines the characteristics of a device as shipped from the factory. The Device Manager comes pre-equipped with certain hardware profiles (e.g., Pixel devices), allowing users to define or tailor these profiles according to their requirements.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/AVD_Hardware-3.png" alt="Device Manager showing virtual devices: Nexus 5X API 25, Pixel 3a XL API 33, Pixel 4 API 30, Pixel 4 XL API 30. Details include API level, size on disk, and actions. Options to create a device and switch between virtual and physical tabs."></p>
<p>Navigating to the <code>x86 Images</code> we can see the different Android API levels. The Google Play logo in the <code>Play Store</code> column indicates that the device includes Google Play Store and access to other services. Assuming we select the <code>Pixel 4</code> device, moving on to the next step, we are prompted to choose a system image.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/AVD_System_Image-3.png" alt="Select Hardware screen in Virtual Device Configuration. Pixel 4 is highlighted with details: 5.7&quot; size, 1080x2280 resolution, 440dpi density. Options to choose other devices, create a new hardware profile, and navigate with cancel, previous, next, and finish buttons."></p>
<p>System images labeled with <code>Google APIs</code> provide access only to Google Play services, while images labeled with <code>Google Play</code> also provide a Google Play Store. If the download icon appears near the Release Name, the image is not installed, and we must download it. System images that include the Google Play Store are signed with a release key, and thus elevated privileges (root) are not supported. On the other hand, system images that only include <code>Google APIs</code> will allow elevated privileges (root) by using the ADB tool through the terminal. This is a necessary feature that we will utilize while conducting application penetration testing. Assuming we select the <code>Tiramisu 33 x86_64 (Google APIs)</code> image, moving on to the next step, we are prompted to give the AVD a name and verify the configurations.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/AVD_Verify_Configuration-3.png" alt="Android Virtual Device Configuration screen. AVD Name: Pixel 4 API 33. Device: Pixel 4, 5.7&quot; 1080x2280 440dpi. System: Tiramisu x86\_64. Startup orientation: Portrait. Options to change settings, show advanced settings, and navigate with cancel, previous, next, and finish buttons."></p>
<p>Once we click the <code>Finish</code> button and create the device, we can find it and start it in the <code>Device Manager</code> by clicking the <code>Play</code> button under the <code>Actions</code> tab.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/AVD_Play-3.png" alt="Device Manager showing virtual devices. &quot;Pixel 4 API 33 (My First AVD)&quot; is highlighted. Details: API 33, 513 MB size. Options to create a device and launch AVD in the emulator."></p>
<p>Once the emulator is launched, it will look like this.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/AVD_Device_transparent_1.png" alt="Android emulator displaying a smartphone home screen with time, date, and app icons. Emulator controls are visible on the right side."></p>
<p>On the device&#39;s right side, there is a vertical menu bar. We can stop the emulator by clicking the <code>x</code> icon on the top. Finally, among other action buttons in the menu bar, there is a 3-dot icon that contains various device settings we can configure as the device is running.</p>
<hr>
<h3 id="other-emulators">Other Emulators</h3>
<p>Although Android Studio AVD is the emulator we will use throughout the following sections, several other emulators are available with unique features and capabilities. Some of the popular alternatives include the following emulators.</p>
<table>
<thead>
<tr>
<th><a href="https://www.corellium.com/"><strong>Corellium</strong></a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Supports a wide range of mobile devices including both Android and iOS operating systems.</td>
</tr>
<tr>
<td>Offers a web-based interface.</td>
</tr>
<tr>
<td>Provides integrated advanced debugging tools.</td>
</tr>
<tr>
<td>Enables users to take snapshots of the emulator.</td>
</tr>
<tr>
<td>Emulates both standard and rooted/jailbroken devices.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><a href="https://www.genymotion.com/"><strong>Genymotion</strong></a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Designed for app developers and testers</td>
</tr>
<tr>
<td>Offers a wide range of virtual devices with different Android versions</td>
</tr>
<tr>
<td>Supports advanced features like camera, GPS, and accelerometer emulation</td>
</tr>
<tr>
<td>Integrates with development platforms like Android Studio and Xamarin</td>
</tr>
<tr>
<td>Available for Windows, macOS, and Linux</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><a href="https://www.bluestacks.com/"><strong>BlueStacks</strong></a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Widely popular and user-friendly</td>
</tr>
<tr>
<td>Multi-instance feature for running multiple apps simultaneously</td>
</tr>
<tr>
<td>Integrates with gaming platforms like Twitch and Discord</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><a href="https://www.bignox.com/"><strong>NoxPlayer</strong></a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Lightweight and efficient emulator</td>
</tr>
<tr>
<td>Supports gamepad, keyboard, and script recording</td>
</tr>
<tr>
<td>Offers advanced features like GPS spoofing and virtual location</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><a href="https://www.memuplay.com/"><strong>MEmu Play</strong></a></th>
</tr>
</thead>
<tbody>
<tr>
<td>High performance and compatibility</td>
</tr>
<tr>
<td>Offers multiple Android versions</td>
</tr>
<tr>
<td>Allows multiple instances and easy app cloning</td>
</tr>
<tr>
<td>Keyboard mapping and joystick support</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><a href="https://www.ldplayer.net/"><strong>LDPlayer</strong></a></th>
</tr>
</thead>
<tbody>
<tr>
<td>Optimized for gaming and productivity apps</td>
</tr>
<tr>
<td>Customizable controls and graphics settings</td>
</tr>
<tr>
<td>Multi-instance support and synchronization</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="android-debug-bridge">Android Debug Bridge</h2>
<hr>
<p><code>Android Debug Bridge</code> (ADB) is a versatile command-line tool that enables communication between a computer and a device. As a part of the Android SDK (Software Development Kit), it allows developers to perform tasks like installing and debugging applications, transferring files between the host computer and the device, and accessing the device through a shell. <code>Android Debug Bridge</code> is a client-server program that can be used on physical and emulated devices, and it includes the following three components.</p>
<table>
<thead>
<tr>
<th><strong>Components</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>The client</code></td>
<td>It runs on the host machine and can be invoked from the terminal by issuing the <code>adb</code> command.</td>
</tr>
<tr>
<td><code>The daemon (adbd)</code></td>
<td>It runs as a background process on each device, and it is responsible for executing the commands in the device.</td>
</tr>
<tr>
<td><code>The server</code></td>
<td>It runs as a background process on the host machine, and it manages the communication between the client and the daemon.</td>
</tr>
</tbody>
</table>
<p>The following steps show how the ADB connection process works.</p>
<p><strong>Step 1</strong></p>
<p>The ADB client will start as soon as we issue an <code>adb</code> command in the terminal. When this happens, the client will check for an <code>adb</code> server process running on the host machine. If there isn&#39;t one, it starts the server process, which binds to the local TCP port <code>5037</code> and listens for commands sent from the <code>adb</code> client.</p>
<p><strong>Step 2</strong></p>
<p>The server then locates the connected emulators by scanning the odd-numbered ports from <code>5555</code> to <code>5585</code>. Finally, it sets up the connection with the emulators that run an ADB daemon (adbd).</p>
<p><strong>Step 3</strong></p>
<p>Each emulator instance has a unique pair of ports to avoid conflicts when running multiple emulators simultaneously. These pairs are an even-numbered port for console connections and an odd-numbered port for ADB connections. In the console connection, we can issue commands to control the emulator using tools like <code>telnet</code>. In the ADB connections, we can perform various development and debugging tasks using the <code>adb</code> command. The following is an example of two connected emulators.</p>
<table>
<thead>
<tr>
<th><strong>Emulator</strong></th>
<th><strong>Service</strong></th>
<th><strong>Port</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Emulator 1</code></td>
<td>console</td>
<td>5554</td>
</tr>
<tr>
<td><code>Emulator 1</code></td>
<td>adb</td>
<td>5555</td>
</tr>
<tr>
<td><code>Emulator 2</code></td>
<td>console</td>
<td>5556</td>
</tr>
<tr>
<td><code>Emulator 2</code></td>
<td>adb</td>
<td>5557</td>
</tr>
</tbody>
</table>
<p><strong>Step 4</strong></p>
<p>Once the connections are set up, we can use the <code>adb</code> command to access the emulators.</p>
<hr>
<h3 id="installing-and-using-adb">Installing and Using ADB</h3>
<p>In the following paragraphs, we will see how to install and use ADB. The example below shows the installation process on three different operating systems.</p>
<p><strong>Debian-based Linux</strong></p>
<p>On Debian-based Linux, through the <code>APT</code> package manager:</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ apt-get install adb
</code></pre>
<p><strong>MacOS</strong></p>
<p>On MacOS, through the <code>Homebrew</code> package manager:</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[/htb]$ /bin/bash -c <span class="hljs-string">"<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>"</span>
root<span class="hljs-meta">@htb</span>[/htb]$ brew update
root<span class="hljs-meta">@htb</span>[/htb]$ brew install android-platform-tools
</code></pre>
<p><strong>Windows</strong></p>
<p>On Windows, through the <code>Scoop</code> command-line installer.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-powershell-session">C:\&gt; Set-ExecutionPolicy RemoteSigned -<span class="hljs-keyword">Scope </span>CurrentUser
C:\&gt; iex (New-Object System.Net.WebClient).DownloadString(<span class="hljs-string">'https://get.scoop.sh'</span>)
C:\&gt; <span class="hljs-keyword">scoop </span><span class="hljs-keyword">bucket </span><span class="hljs-keyword">add </span><span class="hljs-keyword">extras
</span>C:\&gt; <span class="hljs-keyword">scoop </span><span class="hljs-keyword">install </span>adb
</code></pre>
<p><code>ADB</code> is also made available to us as part of the <a href="https://developer.android.com/tools/releases/platform-tools">Android SDK Platform Tools package</a>, available through Android Studio&#39;s <a href="https://developer.android.com/studio/intro/update#sdk-manager">SDK Manager</a>. On Windows, the resulting platform tools including <code>adb.exe</code> are located at <code>C:\Users\&lt;username&gt;\AppData\Local\Android\Sdk\platform-tools</code></p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-powershell-session">Windows PowerShell
Copyright (C) Microsoft Corporation. All rights reserved.

Install <span class="hljs-keyword">the</span> latest PowerShell <span class="hljs-keyword">for</span> <span class="hljs-built_in">new</span> features <span class="hljs-keyword">and</span> improvements! <span class="hljs-keyword">https</span>://aka.ms/PSWindows

PS C:\Windows\system32&gt; cd C:\Users\Owner\AppData\Local\Android\Sdk\<span class="hljs-built_in">platform</span>-tools

PS C:\Users\Owner\AppData\Local\Android\Sdk\<span class="hljs-built_in">platform</span>-tools&gt; ls


    Directory: C:\Users\Owner\AppData\Local\Android\Sdk\<span class="hljs-built_in">platform</span>-tools


Mode                 LastWriteTime         Length Name
<span class="hljs-comment">----                 -------------         ------ ----</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM        5857056 adb.exe</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM         108320 AdbWinApi.dll</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM          73504 AdbWinUsbApi.dll</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM         439072 etc1tool.exe</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM        1807136 fastboot.exe</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM          54560 hprof-conv.exe</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM         242128 libwinpthread-1.dll</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM         477472 make_f2fs.exe</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM         477472 make_f2fs_casefold.exe</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM           1157 mke2fs.conf</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM         754464 mke2fs.exe</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM        1110529 NOTICE.txt</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM          18404 package.xml</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM             38 source.properties</span>
-<span class="hljs-keyword">a</span><span class="hljs-comment">----         5/17/2024  12:24 PM        2838304 sqlite3.exe</span>
</code></pre>
<hr>
<p>We also recommend adding the location of <code>adb.exe</code> to your PATH environment variable, so it can be run from any directory when working with PowerShell/Command Prompt. For instructions on how to do this, check out <a href="https://theflutterist.medium.com/setting-up-adb-path-on-windows-android-tips-5b5cdaa9084b">this article</a>.</p>
<p>To start the ADB server on the host computer, we can type the following command.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ adb start-server
</code></pre>
<p>Once the ADB is installed on our host computer and the emulator is started, we can start issuing ADB commands. As mentioned earlier, starting the ADB server can also be done by directly executing commands using the ADB client. Below are some useful ADB commands.</p>
<table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>adb help</code></td>
<td>List all commands.</td>
</tr>
<tr>
<td><code>adb kill-server</code></td>
<td>Kills the adb server.</td>
</tr>
<tr>
<td><code>adb devices</code></td>
<td>Lists connected devices.</td>
</tr>
<tr>
<td><code>adb root</code></td>
<td>Restarts <code>adbd</code> with root permissions.</td>
</tr>
<tr>
<td><code>adb install &lt;apk&gt;</code></td>
<td>Install app.</td>
</tr>
<tr>
<td><code>adb push &lt;local&gt; &lt;remote&gt;</code></td>
<td>Copy file/dir to device.</td>
</tr>
<tr>
<td><code>adb pull &lt;remote&gt; &lt;local&gt;</code></td>
<td>Copy file/dir from device.</td>
</tr>
<tr>
<td><code>adb logcat [options] [filter] [filter]</code></td>
<td>View device log.</td>
</tr>
</tbody>
</table>
<p>Let&#39;s list the connected devices using the following command.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ adb devices

<span class="hljs-built_in">List</span> <span class="hljs-keyword">of</span> devices attached
emulator-<span class="hljs-number">5554</span>    device
</code></pre>
<p>The above command reveals one attached device using port <code>5554</code>. Apart from providing interactive shell access to the emulated device, ADB can also be used non-interactively to execute commands from the host machine directly to the emulated device. The following <code>adb</code> command executes the <code>whoami</code> command inside the emulated device and prints the result to the terminal.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ adb shell whoami

shell
</code></pre>
<p>Let&#39;s issue the following command to get a shell in the emulated device.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ adb shell

emu64x:/ $
</code></pre>
<p>We can now start executing Linux commands inside the emulator.</p>
<p><strong>Android Shell</strong></p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session">emu64x:/sdcard $ ls -l /sdcard/

total <span class="hljs-number">104</span>
drwxrws--- <span class="hljs-number">2</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Alarms
drwxrws--x <span class="hljs-number">5</span> media_rw media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:29</span> Android
drwxrws--- <span class="hljs-number">2</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Audiobooks
drwxrws--- <span class="hljs-number">2</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> DCIM
drwxrws--- <span class="hljs-number">2</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Documents
drwxrws--- <span class="hljs-number">2</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Download
drwxrws--- <span class="hljs-number">3</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Movies
drwxrws--- <span class="hljs-number">3</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Music
drwxrws--- <span class="hljs-number">2</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Notifications
drwxrws--- <span class="hljs-number">3</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Pictures
drwxrws--- <span class="hljs-number">2</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Podcasts
drwxrws--- <span class="hljs-number">2</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Recordings
drwxrws--- <span class="hljs-number">2</span> u0_a146  media_rw <span class="hljs-number">4096 2023</span>-<span class="hljs-number">04-28 17:30</span> Ringtones
</code></pre>
<hr>
<h3 id="adb-root">ADB Root</h3>
<p>ADB can also provide the user with elevated privileges. The <code>adb root</code> command restarts the ADB daemon (adbd) on the Android emulator with root privileges. It gives elevated permissions to the user that allows for a wider range of command execution, as well as access to system files and directories that are typically restricted to regular users. Root access allows us to perform more in-depth debugging and testing during the application penetration testing. This said, running ADB as root is typically only available on emulators, as most production devices come with locked bootloaders and cannot be rooted without voiding the warranty. Also, as mentioned earlier in the <code>Android Emulators</code> section, only system images labeled with <code>Google APIs</code> will provide this feature. System images labeled with <code>Google Play</code> are signed with a release key, and elevated privileges (root) are not supported.</p>
<p>The following command will restart the <code>adbd</code> with root privillages.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ adb root

restarting adbd as root
</code></pre>
<p>Once it&#39;s restarted, we can execute the following command to confirm that we can run commands as the user <code>root</code>.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ adb shell whoami

root
</code></pre>
<hr>
<h3 id="installing-apps-and-transferring-files">Installing Apps and Transferring Files</h3>
<p>Android Debug Bridge also allows us to install applications. Let&#39;s try to install the application we created in the section <code>Native Apps</code> using the following command.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ adb <span class="hljs-keyword">install</span> myapp.apk 

Performing Streamed <span class="hljs-keyword">Install</span>
<span class="hljs-keyword">Success</span>
</code></pre>
<p>Once installed, we can locate the app on the device and tap on it to start. Another useful command of ADB is the <code>push</code> and <code>pull</code> commands. Using these commands, we can transfer files from the host computer to the device and vice versa. To push files from the host to the device, we can execute the following command.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ adb push ./</span>myapp.apk <span class="hljs-regexp">/sdcard/</span>Download/

.<span class="hljs-regexp">/myapp.apk: 1 file pushed, 0 skipped. 14.9 MB/</span>s (<span class="hljs-number">4527105</span> bytes <span class="hljs-keyword">in</span> <span class="hljs-number">0.291</span>s)
</code></pre>
<p>We can verify by listing the content of the directory <code>/sdcard/Download/</code> in the device.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session">root<span class="hljs-variable">@htb</span>[<span class="hljs-regexp">/htb]$ adb shell ls -l /sdcard</span><span class="hljs-regexp">/Download/</span>

total <span class="hljs-number">4428</span>
-rw-rw---- <span class="hljs-number">1</span> u0_a146 media_rw <span class="hljs-number">4527105</span> <span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">03</span> <span class="hljs-number">01</span><span class="hljs-symbol">:</span><span class="hljs-number">44</span> myapp.apk
</code></pre>
<p>Similarly, we pull files from the device to the host by executing the following command.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ adb pull /</span>sdcard<span class="hljs-regexp">/Download/</span>myapp.apk .

<span class="hljs-regexp">/sdcard/</span>Download<span class="hljs-regexp">/myapp.apk: 1 file pulled, 0 skipped. 78.9 MB/</span>s (<span class="hljs-number">4527105</span> bytes <span class="hljs-keyword">in</span> <span class="hljs-number">0.055</span>s)
</code></pre>
<hr>
<h3 id="setting-up-a-real-device">Setting Up a Real Device</h3>
<p>Setting up ADB with a real Android device requires some extra steps on the device&#39;s side. After installing ADB on the host machine, we also have to enable <code>USB Debugging</code> on our Android device. To do this, we first have to go to <code>Settings</code> -&gt; <code>About phone</code> or <code>About device</code> or <code>About emulated device</code>, find the <code>Build number</code>, and tap on it seven times. This will display the message <code>You are now a developer!</code>.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/ADB_Developer_Options_transparent_2.png" alt="About emulated device screen showing Android version 13, IP address, Wi-Fi MAC address, device Wi-Fi MAC address, Bluetooth address, up time, and build number."></p>
<p>The <code>Developer Options</code> menu can be found under <code>Settings</code> -&gt; <code>Developer Options</code> or <code>Settings</code> -&gt; <code>System</code> -&gt; <code>Developer Options</code>, depending on the Android version. After navigating to the path we mentioned earlier, the next step is to enable <code>USB Debugging</code> and confirm any prompts that appear.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/195/ADB_USB_Debugging_transparent_2.png" alt="Developer options screen with &quot;Use developer options&quot; enabled. USB debugging is on, wireless debugging, disable ADB authorization timeout, bug report shortcut, and enable verbose vendor logging are off."></p>
<p>Once enabled, we can connect the device to the computer using a USB cable. When prompted on the device, choose <code>File transfer</code> or <code>MTP</code> mode. We can confirm that the device is connected by executing the following command.</p>
<p>&#x20; Android Debug Bridge</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ adb devices

<span class="hljs-built_in">List</span> <span class="hljs-keyword">of</span> devices attached
<span class="hljs-number">1234567890</span>ABCDEF    device
</code></pre>
<p>The device&#39;s serial number should be included in the output, indicating that ADB is successfully connected to your device. Finally, we can start executing <code>adb</code> commands from our host computer to the device.</p>
<hr>
<h2 id="application-penetration-testing-methodology-and-tools">Application Penetration Testing - Methodology and Tools</h2>
<hr>
<p>Mobile applications and services are vital for both our personal and professional life, making them prime targets for malicious actors seeking sensitive data. Modern Android applications are widely used in commerce, healthcare, banking, education, and more. Beyond storing sensitive information, these applications often contain security vulnerabilities that could be exploited. Penetration testers and developers play a crucial role in identifying and mitigating these vulnerabilities, reducing risks such as fraud, malware infections, and data breaches. For companies launching new applications, ensuring security and compliance is essential to avoiding legal issues and protecting user data.</p>
<p>Mobile application penetration testing is the process of assessing an app&#39;s security by simulating real-world attack scenarios. This methodology helps identify vulnerabilities and ensures that applications remain resilient against threats. The following steps outline a structured, high-level approach that Android penetration testers should follow for a comprehensive security evaluation.</p>
<p><strong>1. Planning and Environment Setup</strong></p>
<table>
<thead>
<tr>
<th><strong>Objectives</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Define the scope and objectives of the penetration test.</td>
</tr>
<tr>
<td>Obtain necessary permissions from the app owner or organization.</td>
</tr>
<tr>
<td>Set up the testing environment, including the necessary tools, operating systems, and emulators.</td>
</tr>
</tbody>
</table>
<p><strong>2. Enumeration and Information Gathering</strong></p>
<table>
<thead>
<tr>
<th><strong>Objectives</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Gather information about the app and its architecture.</td>
</tr>
<tr>
<td>Understand the functionality of the application.</td>
</tr>
<tr>
<td>Enumerate any data structure the app uses that is stored in the local storage.</td>
</tr>
</tbody>
</table>
<p><strong>3. Static Analysis</strong></p>
<table>
<thead>
<tr>
<th><strong>Objectives</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Understand the manifest file of the application. Review the app&#39;s components, permissions, and configurations.</td>
</tr>
<tr>
<td>Decompile and analyze the application&#39;s source code to understand the flow and find potential vulnerabilities.</td>
</tr>
<tr>
<td>Examine native or third-party libraries, frameworks, and dependencies the app uses.</td>
</tr>
</tbody>
</table>
<p><strong>4. Dynamic Analysis</strong></p>
<table>
<thead>
<tr>
<th><strong>Objectives</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Monitor the application&#39;s behavior during runtime. Enumerate the local storage for files and data structures created after performing various functionalities.</td>
</tr>
<tr>
<td>Perform dynamic instrumentation to read the memory of the application during runtime.</td>
</tr>
<tr>
<td>Intercept network traffic and test the app for vulnerabilities such as authentication bypass and insecure data transmission.</td>
</tr>
<tr>
<td>Check for Server-Side attacks by analyzing API calls and looking for vulnerabilities such as injection and XSS attacks.</td>
</tr>
</tbody>
</table>
<p><strong>5. Documenting and Reporting</strong></p>
<table>
<thead>
<tr>
<th><strong>Objectives</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Document the identified vulnerabilities, exploitation methods, impact, and potential risks.</td>
</tr>
<tr>
<td>Communicate the findings to the app owner or organization.</td>
</tr>
<tr>
<td>Provide recommendations for fixing vulnerabilities and mitigating security risks.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="suggested-tools">Suggested Tools</h3>
<p>The following list presents some of the most widely used tools for mobile app penetration testing , focusing on <code>reverse engineering</code>, <code>dynamic analysis</code>, <code>code instrumentation</code>, <code>network traffic analysis</code>, and <code>digital forensics</code>. Familiarity with these tools is essential for anyone practicing their Android application penetration testing skills.</p>
<p><strong>ADB</strong></p>
<p>A versatile command-line tool that allows communication with Android devices. This tool will let us enumerate the local storage of the device and the installation directory of the application, see the app logs while it is running, and install and run other apps and tools necessary for the steps of the dynamic analysis and instrumentation.</p>
<p><strong>JADX</strong></p>
<p>This tool allows us to reverse engineer an application and view its source code through a graphical interface. It provides the user with a Java-like pseudocode that is close enough to the actual code. It also decodes the encoded resources that are packed in the APK file, making the file configurations and the other assets readable to humans. This tool is an essential part of the process since the testers can understand how the app works and what technologies are used.</p>
<p><strong>APKTool</strong></p>
<p>This tool also allows reverse engineering Android applications. It will decompile the source code and decode the resources of the APK file. APKTool also enables us to edit the source code and configuration files, recompile the code, and build the APK file again. This is called application patching. The decompiled code provided to the user is a symbolic language called <code>Smali</code>. This language is not easy to read, but if combined with a tool that offers Java-like pseudocode like JADX, pentesters can efficiently understand and change the flow of the application to their benefit.</p>
<p><strong>Ghidra</strong></p>
<p>An open-source software reverse engineering (SRE) framework developed by the National Security Agency (NSA). It is used for disassembling, decompiling, and analyzing binaries. In Android application penetration testing, Ghidra is often used to analyze the native C++ libraries loaded to the application.</p>
<p><strong>Burp Suite</strong></p>
<p>A tool used for web application penetration testing. While we often see it used for testing websites, it can also be used for testing any web-based application communicating with a server, including Android. In the Android application, penetration testing will be mainly used to intercept and analyze HTTP/HTTPS requests.</p>
<p><strong>Frida</strong></p>
<p>A dynamic instrumentation toolkit used by developers, reverse engineers, and security researchers. It enables us to inject snippets of JavaScript or native code into the running processes of Android applications, allowing us to analyze and manipulate them during runtime.</p>
<p><strong>Autopsy</strong></p>
<p>An open-source digital forensics platform that can be used for various tasks, including Android forensics. Autopsy will help us investigate disk images of Android devices and let us search for files, databases, calls, messages, and logs, using the provided GUI.</p>
<hr>
<h3 id="automated-tools">Automated Tools</h3>
<p>Automated Android penetration testing tools are suitable for scanning common vulnerabilities. They offer a faster and cheaper solution than manual tools and processes, which provide more depth and vulnerability insights by combining human intelligence with automated tools.</p>
<p><strong>MobSF</strong></p>
<p>An automated security testing framework for Android, iOS, and Windows platforms that performs static, dynamic, and malware analysis on mobile applications.</p>
<p><strong>Drozer</strong></p>
<p>A comprehensive security and attack framework that allows us to assess the security of Android applications. It simulates various attack vectors and provides multiple tools to analyze, exploit, and debug Android applications.</p>
<p><strong>Qark</strong></p>
<p>A static code analysis tool that automates the discovery of security vulnerabilities in Android applications. It can also create Proof-of-Concept deployable APKs and ADB commands to exploit the vulnerabilities it finds.</p>
<p><strong>Objection</strong></p>
<p>A runtime mobile exploration toolkit that uses Frida to provide an easy environment for assessing Android and iOS application security. It automates several common tasks, such as bypassing SSL pinning, and users won&#39;t be needed to create custom scripts whenever they need to exploit common vulnerabilities.</p>
<p><strong>Medusa</strong></p>
<p>An extensible and modularized framework that automates processes and techniques practiced during the dynamic analysis of Android Applications. Medusa is based on Frida and can analyze and enumerate an app, attack common entry points, and automate processes like application patching, MITM attack, and more. Medusa can add and remove hooks for Java or Native methods and has more than 90 modules that can be combined.</p>
<p><strong>Androbugs</strong></p>
<p>Androbugs is an Android vulnerability analysis framework that automatically scans Android applications and checks for security issues and vulnerabilities.</p>
<p>It is crucial to remember that combining both manual and automated techniques usually results in a better evaluation. Recapping this module, we went through the most critical fundamental concepts necessary for understanding the methodologies that will follow in subsequent modules. We analyzed the structure of the Android OS and the architecture of applications, discussed the different types of apps, and examined examples of applications built with various frameworks. We studied their components and IPCs, and learned how to set up a testing environment and interact with emulators.</p>
<p>Following the Penetration Testing methodology discussed in this section, we are now ready to prepare for the next module, which regards Android Application Static Analysis. In this upcoming module, we will reverse engineer apps and study the source code to identify security issues and exploit vulnerabilities.</p>
<hr>

  </div>
</body>