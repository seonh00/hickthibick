
<body>
  <div class="container">
<link rel="stylesheet" href="style.css">

<h1 id="introduction-to-c-">Introduction to C\</h1>
<h2 id="cheat-sheet">Cheat Sheet</h2>
<h3 id="basic-syntax">Basic Syntax</h3>
<table><thead><tr><th width="282">Content</th><th>Description</th></tr></thead><tbody><tr><td>Main Method</td><td>The main entry point for all C# programs. Defined as: <code>static void Main(string[] args) { }</code></td></tr><tr><td>Case Sensitivity</td><td>C# is case-sensitive. For instance, <code>MyVariable</code>, <code>myvariable</code>, and <code>myVariable</code> would be three different identifiers.</td></tr><tr><td>Identifiers</td><td>Names given to entities such as variables, methods, etc. Must start with a letter (A-Z or a-z), an underscore (_), followed by zero or more letters, underscores, and digits (0-9).</td></tr><tr><td>Keywords</td><td>Predefined reserved words with special meanings that cannot be used as identifiers. Examples: <code>public</code>, <code>class</code>, <code>void</code>, etc.</td></tr><tr><td>The ;</td><td>In C#, the semicolon is a statement terminator. Each statement must end with a semicolon. Example: <code>int x = 10;</code></td></tr><tr><td>Statements &#x26; Expressions</td><td>A statement performs an action, e.g., <code>x = 7;</code>. An expression is a construct comprising variables, operators, and method invocations evaluated to a single value, e.g., <code>x + 7</code>.</td></tr><tr><td>Blocks of Code</td><td>Blocks are used to group two or more C# statements and are defined by braces <code>{}</code>. Example: <code>{ int x = 7; Console.WriteLine(x); }</code></td></tr><tr><td>Comments</td><td>Comments are used to explain code and are ignored by the compiler. Single-line comments start with <code>//</code>. Multi-line comments start with <code>/<em></code> and end with <code></em>/</code>.</td></tr><tr><td>Read Compiler Errors</td><td>Compiler errors indicate issues in your code that prevent it from compiling. They often include the line number and a description of the error, which can guide you towards resolving the issue.</td></tr></tbody></table>

<h3 id="variables-constants-and-data-types">Variables, Constants, and Data Types</h3>
<table><thead><tr><th width="157">Content</th><th>Description</th></tr></thead><tbody><tr><td>Variables</td><td>Variables are storage locations, each defined with a specific data type. They are declared using the syntax: <code>dataType variableName;</code> <code>int num;</code></td></tr><tr><td>Constants</td><td>Constants are similar to variables, but, as the name suggests, their value remains constant throughout the program. They are declared using the <code>const</code> keyword. <code>const double Pi = 3.14159;</code></td></tr><tr><td>Enums</td><td>Enum is short for &quot;enumerations&quot;, which are a distinct type consisting of a set of named constants. Declared using the <code>enum</code> keyword. <code>enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};</code></td></tr><tr><td>Data Types</td><td>Data types specify the data type that a valid C# variable can hold. C# has several data types, including <code>int</code>, <code>double</code>, <code>char</code>, <code>bool</code>, and <code>string</code>. Each has its own range of values and behaviours.</td></tr></tbody></table>

<h3 id="operators-and-type-conversion">Operators and Type Conversion</h3>
<table><thead><tr><th width="289">Content</th><th>Description</th></tr></thead><tbody><tr><td>Arithmetic Operators</td><td>These include <code>+</code> (addition), <code>-</code> (subtraction), <code>*</code> (multiplication), <code>/</code> (division), <code>%</code> (modulus) and more.</td></tr><tr><td>Relational Operators</td><td>These include <code>==</code> (equal to), <code>!=</code> (not equal to), <code>&#x3C;</code> (less than), <code>&gt;</code> (greater than), <code>&#x3C;=</code> (less than or equal to) and <code>&gt;=</code> (greater than or equal to).</td></tr><tr><td>Logical Operators</td><td>These include <code>&#x26;&#x26;</code> (logical AND), <code>&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bitwise Operators&lt;/td&gt;&lt;td&gt;These perform operations on binary representations of numbers. They include &lt;code&gt;&amp;#x26;&lt;/code&gt; (AND),</code></td></tr><tr><td>Assignment Operators</td><td>The assignment operator is <code>=</code>. There are also compound assignment operators like <code>+=</code>, <code>-=</code>, etc.</td></tr><tr><td>Unary Operators</td><td>These operators work with only one operand. They include <code>++</code>, <code>--</code>, and the logical negation operator <code>!</code>.</td></tr><tr><td>Ternary Operator</td><td>A shorthand for conditional statements. Syntax: <code>(condition) ? true_expression : false_expression</code>.</td></tr><tr><td>Null Conditional Operators</td><td>Used to simplify checking for null values, denoted as <code>?.</code>.</td></tr><tr><td>Null-coalescing Operator</td><td>Used to define a default value for nullable value types or reference types, denoted as <code>??</code>.</td></tr><tr><td>Implicit Type Conversion</td><td>Also known as widening conversion, it is done automatically by the compiler where no data loss is expected. Example: converting an integer to a float.</td></tr><tr><td>Explicit Type Conversion</td><td>Also known as narrowing conversion, the programmer must do it manually when there might be data loss. Example: converting a float to an integer.</td></tr><tr><td>Type Checking &#39;is&#39;</td><td>The &#39;is&#39; keyword checks if an object is of a certain type.</td></tr><tr><td>Type Checking &#39;as&#39;</td><td>The &#39;as&#39; keyword performs certain types of conversions between compatible reference types.</td></tr></tbody></table>

<h3 id="namespaces">Namespaces</h3>
<table>
<thead>
<tr>
<th>Content</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Creating and Organizing Code Using Namespaces</td>
<td>Namespaces are used to organise code and create globally unique types. Declare a namespace with <code>namespace</code> keyword followed by name and body enclosed in <code>{}</code>. <code>namespace MyNamespace { // code }</code>.</td>
</tr>
<tr>
<td>Importing and Using Namespaces in C# Programs</td>
<td>Use the <code>using</code> directive at the beginning of your code to include a namespace in your program. <code>using System;</code></td>
</tr>
<tr>
<td>Resolving Naming Conflicts with Namespaces</td>
<td>If two namespaces contain types with the same name, fully qualify the name by including the namespace to avoid conflict. <code>System.Console.WriteLine(&quot;Hello, world!&quot;);</code></td>
</tr>
</tbody>
</table>
<h3 id="console-i-o">Console I/O</h3>
<table><thead><tr><th width="237">Content</th><th>Description</th></tr></thead><tbody><tr><td>Console.Read</td><td>Reads the next character from the standard input stream. Returns the ASCII value of the character read, or -1 if no more characters are available.</td></tr><tr><td>Console.ReadLine</td><td>Reads the next line of characters from the standard input stream. Returns a string containing the line read or null if no more lines are available.</td></tr><tr><td>Console.Write</td><td>Writes data to the standard output stream without a newline character at the end. Can take a string or other data types as argument(s). <code>Console.Write(&quot;Hello, world&quot;);</code></td></tr><tr><td>Console.WriteLine</td><td>Similar to <code>Console.Write</code>, but appends a newline character () at the end, causing subsequent output to appear on a new line. <code>Console.WriteLine(&quot;Hello, world&quot;);</code></td></tr></tbody></table>

<h3 id="control-statements-and-loops">Control Statements and Loops</h3>
<table><thead><tr><th width="140">Content</th><th>Description</th></tr></thead><tbody><tr><td>if</td><td>A control statement executes a block of code if a specified condition is <code>true</code>.</td></tr><tr><td>else</td><td>Used after an <code>if</code> statement. Its block of code executes if the <code>if</code> condition is <code>false</code>.</td></tr><tr><td>else if</td><td>Used after an <code>if</code> or another <code>else if</code> to test multiple conditions.</td></tr><tr><td>switch</td><td>A control statement that selects one of many code blocks to be executed.</td></tr><tr><td>for</td><td>A loop that repeats a block of code a certain number of times, defined at the start of the loop.</td></tr><tr><td>while</td><td>A loop that repeats a block of code as long as a specified condition is <code>true</code>.</td></tr><tr><td>do-while</td><td>Similar to the <code>while</code> loop, but checks the condition at the end of the loop. This means the loop will always run at least once.</td></tr><tr><td>break</td><td>Used to exit a loop or a <code>switch</code> statement prematurely.</td></tr><tr><td>continue</td><td>Skips the rest of the current iteration and moves directly to the next iteration of the loop.</td></tr><tr><td>goto</td><td>Transfers control to another part of the program marked with a label.</td></tr></tbody></table>

<h3 id="arrays">Arrays</h3>
<table><thead><tr><th width="293">Content</th><th>Description</th></tr></thead><tbody><tr><td>Arrays in C#</td><td>An array is a collection of elements of the same type stored in contiguous memory locations. It is declared with the type followed by square brackets <code>[]</code>. <code>int[] arr;</code></td></tr><tr><td>Multidimensional Arrays in C#</td><td>C# supports multidimensional arrays, declared with commas in the square brackets. <code>int[,] arr;</code></td></tr><tr><td>The Array Class</td><td>Provides various properties and methods to work with arrays. It is defined within the <code>System</code> namespace.</td></tr><tr><td>Array.Sort()</td><td>A method that sorts the elements in an entire one-dimensional Array. <code>Array.Sort(arr);</code></td></tr><tr><td>Array.Reverse()</td><td>Reverses the sequence of the elements in the entire one-dimensional Array or in a portion of it. <code>Array.Reverse(arr);</code></td></tr><tr><td>Array.IndexOf()</td><td>Returns the index of the first occurrence of a value in a one-dimensional Array or in a portion of it. <code>int index = Array.IndexOf(arr, value);</code></td></tr><tr><td>Array.Clear()</td><td>Sets a range of elements in the Array to zero, to false, or to null, depending on the element type. <code>Array.Clear(arr, startIndex, length);</code></td></tr></tbody></table>

<h3 id="strings">Strings</h3>
<table><thead><tr><th width="242">Content</th><th>Description</th></tr></thead><tbody><tr><td>String Declaration</td><td>In C#, a string is declared as: <code>string str = &quot;Hello World&quot;;</code></td></tr><tr><td>String Concatenation</td><td>Strings can be concatenated using the <code>+</code> operator. Example: <code>string str = &quot;Hello&quot; + &quot; World&quot;;</code></td></tr><tr><td>String Interpolation</td><td>Insert variables directly in a string with <code>{}</code>. Example: <code>string str = $&quot;Hello {name}&quot;;</code></td></tr><tr><td>Length Property</td><td>To get the length of a string, use the <code>Length</code> property. Example: <code>int length = str.Length;</code></td></tr><tr><td>Indexing</td><td>Access individual characters in a string with an index, starting from 0. Example: <code>char ch = str[0];</code></td></tr><tr><td>Substrings</td><td>Extract part of a string using the <code>Substring</code> method. Example: <code>string substr = str.Substring(startIndex, length);</code></td></tr><tr><td>String Comparison</td><td>Compare two strings using the <code>==</code> operator or the <code>String.Equals</code> method.</td></tr><tr><td>String Case Conversion</td><td>Convert to uppercase or lowercase using the <code>ToUpper()</code> and <code>ToLower()</code> methods.</td></tr><tr><td>Trimming Strings</td><td>Remove whitespace from start/end of a string with <code>Trim()</code>, <code>TrimStart()</code>, or <code>TrimEnd()</code>.</td></tr><tr><td>Searching in Strings</td><td>Find a substring or character using the <code>IndexOf()</code> or <code>Contains()</code> methods.</td></tr><tr><td>Replacing in Strings</td><td>Replace a substring or character using the <code>Replace()</code> method.</td></tr></tbody></table>

<h3 id="collections">Collections</h3>
<table><thead><tr><th width="286">Content</th><th>Description</th></tr></thead><tbody><tr><td>Iterating through a collection</td><td>You can iterate through a collection using a <code>foreach</code> loop. <code>foreach(var item in collection) { // actions }</code>.</td></tr><tr><td>List</td><td>A list is an ordered collection of items that can contain duplicates. Use the <code>Add</code>, <code>Remove</code>, and <code>Sort</code> methods to manipulate a list.</td></tr><tr><td>Dictionary</td><td>A dictionary is a collection of key-value pairs where each key must be unique. Use the <code>Add</code>, <code>Remove</code>, and <code>TryGetValue</code> methods to manipulate a dictionary.</td></tr><tr><td>HashSet</td><td>A HashSet is an unordered collection of unique elements. It provides high-performance set operations like union, intersection, and difference.</td></tr><tr><td>List vs Dictionary vs HashSet</td><td>Lists are best for accessing elements by index or iterating in order. Dictionaries provide fast lookups for elements based on a unique key. HashSets provide fast lookups like dictionaries but only store individual values instead of key-value pairs.</td></tr><tr><td>Performance considerations</td><td>In general, Dictionaries and HashSets provide faster lookups than Lists, especially for large collections. However, the choice between these depends on the specific requirements of your program.</td></tr></tbody></table>

<h3 id="linq-language-integrated-query-">LINQ (Language Integrated Query)</h3>
<table><thead><tr><th width="293">Content</th><th>Description</th></tr></thead><tbody><tr><td>LINQ Query Syntax</td><td>LINQ queries consist of three parts: <code>from clause</code>, <code>where clause</code>, and <code>select clause</code>. <code>var result = from s in source where s.condition select s.property;</code></td></tr><tr><td>Where</td><td>Filters a collection based on a condition. <code>var result = data.Where(x =&gt; x &gt; 5);</code></td></tr><tr><td>Select</td><td>Projects each sequence element into a new form. <code>var result = data.Select(x =&gt; x * 2);</code></td></tr><tr><td>OrderBy/OrderByDescending</td><td>Sorts the elements of a sequence in ascending/descending order. <code>var result = data.OrderBy(x =&gt; x);</code> or <code>var result = data.OrderByDescending(x =&gt; x);</code></td></tr><tr><td>GroupBy</td><td>Groups the elements of a sequence according to a specified key selector function. Example: <code>var result = data.GroupBy(x =&gt; x.Key);</code></td></tr><tr><td>Join</td><td>Joins two collections based on matching keys. <code>var result = list1.Join(list2, x =&gt; x.Key, y =&gt; y.Key, (x, y) =&gt; new { X = x, Y = y });</code></td></tr><tr><td>Aggregate</td><td>Applies an accumulator function over a sequence. <code>var result = data.Aggregate((a, b) =&gt; a + b);</code></td></tr><tr><td>Count/Sum/Average/Min/Max</td><td>Performs calculations on a sequence of values. <code>var count = data.Count();</code>, <code>var sum = data.Sum();</code>, <code>var avg = data.Average();</code>, <code>var min = data.Min();</code>, <code>var max = data.Max();</code></td></tr></tbody></table>

<h3 id="methods-and-exception-handling">Methods and Exception Handling</h3>
<table><thead><tr><th width="271">Content</th><th>Description</th></tr></thead><tbody><tr><td>Creating a method</td><td>Methods are declared with a return type, name, and parameters. <code>public int Add(int x, int y) { return x + y; }</code></td></tr><tr><td>Method Scope</td><td>The scope of a method is the region of code within which a method can be accessed. Typically defined by the access modifier (<code>public</code>, <code>private</code>, etc.).</td></tr><tr><td>Static vs Non-Static Methods</td><td>Static methods belong to the class itself and can be called without creating an instance of the class. Non-static methods belong to an instance of the class.</td></tr><tr><td>try catch finally</td><td><code>try</code> contains code that might throw an exception. <code>catch</code> defines what to do if an exception is thrown in the try block. <code>finally</code> contains code that will always be executed, whether an exception is thrown or not.</td></tr><tr><td>throw</td><td>The <code>throw</code> keyword is used to throw an exception from within your code explicitly. <code>throw new Exception(&quot;An error occurred.&quot;);</code></td></tr></tbody></table>

<h3 id="lambda-expressions">Lambda Expressions</h3>
<table>
<thead>
<tr>
<th>Content</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Simple Lambda Expression</td>
<td>A lambda expression with no parameters, represented as: <code>() =&gt; SomeMethod();</code></td>
</tr>
<tr>
<td>Lambda Expression with Parameters</td>
<td>A lambda expression with one or more parameters. <code>(param1, param2) =&gt; param1 + param2;</code></td>
</tr>
<tr>
<td>Lambda Expression with Statement Block</td>
<td>A lambda expression with multiple statements enclosed in <code>{}</code>. <code>(param1, param2) =&gt; { var result = param1 + param2; return result; };</code></td>
</tr>
</tbody>
</table>
<h3 id="libraries">Libraries</h3>
<table><thead><tr><th width="217">Content</th><th>Description</th></tr></thead><tbody><tr><td>NuGet</td><td>NuGet is a package manager for .NET. It allows you to add third-party libraries to your project with ease. You can add a NuGet package using the Package Manager Console or the Manage NuGet Packages dialogue box in an IDE.</td></tr><tr><td>Manual Referencing</td><td>If a library isn&#39;t available on NuGet, or you have a local library that you want to use, you can manually add a reference to it in your project.</td></tr></tbody></table>

<h3 id="object-oriented-programming">Object-Oriented Programming</h3>
<table><thead><tr><th width="235">Content</th><th>Description</th></tr></thead><tbody><tr><td>Classes</td><td>A blueprint for creating objects. Defined with the <code>class</code> keyword.</td></tr><tr><td>Accessors</td><td>Methods that get and set the value of class properties (<code>get</code> and <code>set</code>).</td></tr><tr><td>Automatic Properties</td><td>C# allows you to define a property without specifying a field (also known as auto-implemented properties). <code>public string Name { get; set; }</code></td></tr><tr><td>Structs</td><td>Similar to classes but are value types and don&#39;t support inheritance. Defined with the <code>struct</code> keyword.</td></tr><tr><td>Encapsulation</td><td>The process of hiding internal details and exposing only what&#39;s necessary. Achieved with access modifiers like <code>public</code>, <code>private</code>, etc.</td></tr><tr><td>Inheritance</td><td>The ability for one class to inherit properties and methods from another class. Defined using the <code>:</code> symbol. <code>public class ChildClass : ParentClass</code></td></tr><tr><td>Single Inheritance</td><td>A class can inherit from one base class only.</td></tr><tr><td>Multilevel Inheritance</td><td>A chain of inheritance where a class inherits from a base class, which itself inherits from another base class, and so on.</td></tr><tr><td>base</td><td>The <code>base</code> keyword is used to access members of the base class from within a derived class. <code>base.MethodName()</code></td></tr></tbody></table>

<h3 id="polymorphism-and-abstraction">Polymorphism and Abstraction</h3>
<table><thead><tr><th width="226">Content</th><th>Description</th></tr></thead><tbody><tr><td>Polymorphism</td><td>Allows objects of different types to be treated as objects of a common supertype. Enables us to write more generic and reusable code.</td></tr><tr><td>Method Overloading</td><td>The ability to define multiple methods in the same scope with the same name but different parameters.</td></tr><tr><td>Method Overriding</td><td>Allows a subclass to provide a specific implementation of a method that is already provided by its superclass. Achieved using <code>override</code> keyword.</td></tr><tr><td>Operator Overloading</td><td>The ability to redefine or overload most of the built-in operators available in C#. This allows using operators with user-defined types as well.</td></tr><tr><td>Property Overriding</td><td>Similar to method overriding but for properties. Allows a subclass to override a property in the base class.</td></tr><tr><td>Abstraction</td><td>Hiding complex details and providing a simpler interface. In C#, it&#39;s achieved through abstract classes and interfaces. Abstract classes contain abstract methods that have a declaration but no implementation.</td></tr></tbody></table>

<h3 id="generics">Generics</h3>
<table><thead><tr><th width="239">Content</th><th>Description</th></tr></thead><tbody><tr><td>Benefits of Generics</td><td>Generics increase the reusability of code, type safety, and performance by eliminating boxing and unboxing.</td></tr><tr><td>Generic Classes</td><td>A class that can be customized to work with a specified data type. <code>public class GenericClass&#x3C;T&gt; { }</code></td></tr><tr><td>Generic Methods</td><td>Methods with a type parameter in its declaration. <code>public T GenericMethod&#x3C;T&gt;(T param) { return param; }</code></td></tr><tr><td>Generic Constraints</td><td>Constraints are used to restrict the types that can be used as arguments for a type parameter in a generic class or method. <code>public class GenericClass&#x3C;T&gt; where T : IComparable { }</code></td></tr></tbody></table>

<h3 id="file-i-o">File I/O</h3>
<table><thead><tr><th width="333">Content</th><th>Description</th></tr></thead><tbody><tr><td>StreamReader</td><td><code>StreamReader</code> is used for reading characters from a byte stream in a particular encoding. <code>StreamReader sr = new StreamReader(path);</code></td></tr><tr><td>Reading Data with StreamReader</td><td>Use <code>sr.ReadToEnd();</code> to read all data.</td></tr><tr><td>StreamWriter</td><td><code>StreamWriter</code> is used for writing characters to a stream in a particular encoding. <code>StreamWriter sw = new StreamWriter(path);</code></td></tr><tr><td>Writing Data with StreamWriter</td><td>Use <code>sw.Write(&quot;Hello World&quot;);</code> to write data.</td></tr></tbody></table>

<h3 id="network-i-o">Network I/O</h3>
<table><thead><tr><th width="148">Content</th><th>Description</th></tr></thead><tbody><tr><td>HttpClient</td><td><code>HttpClient</code> is a class in .NET used for sending HTTP requests and receiving HTTP responses.</td></tr><tr><td>GetAsync</td><td>Sends a <code>GET</code> request to the specified Uri and returns the response. Example: <code>var response = await client.GetAsync(url);</code></td></tr><tr><td>PostAsync</td><td>Sends a <code>POST</code> request to the specified Uri with a specified content. Example: <code>var response = await client.PostAsync(url, content);</code></td></tr><tr><td>PutAsync</td><td>Sends a <code>PUT</code> request to the specified Uri with a specified content. Example: <code>var response = await client.PutAsync(url, content);</code></td></tr><tr><td>DeleteAsync</td><td>Sends a <code>DELETE</code> request to the specified Uri and returns the response. Example: <code>var response = await client.DeleteAsync(url);</code></td></tr></tbody></table>

<h3 id="asynchronous-programming">Asynchronous Programming</h3>
<table><thead><tr><th width="338">Content</th><th>Description</th></tr></thead><tbody><tr><td>async &#x26; await</td><td><code>async</code> modifier indicates that a method, lambda expression, or anonymous method is asynchronous. <code>await</code> operator is applied to a task in an <code>async</code> method to suspend the execution of the method until the awaited task completes.</td></tr><tr><td>Tasks</td><td>A <code>Task</code> represents a single operation that does not return a value and that usually executes asynchronously. A <code>Task&#x3C;TResult&gt;</code> represents a single operation that returns a value.</td></tr><tr><td>Task Cancellation</td><td>The cooperative cancellation model provided by .NET allows you to cancel running tasks using <code>CancellationTokenSource</code> and <code>CancellationToken</code>.</td></tr><tr><td>Exception Handling with Async Code</td><td>In async methods, use <code>try-catch</code> blocks to handle exceptions. Exceptions are propagated when the task is awaited.</td></tr></tbody></table>



<h2 id="arrays">Arrays</h2>
<hr>
<p>Arrays are a crucial aspect of C# programming and most other programming languages as well. Their importance is due to their ability to store multiple values of the same type in a structured manner.</p>
<h3 id="arrays-in-c-">Arrays in C\</h3>
<p>To declare an array in C#, the syntax involves specifying the type of elements that the array will hold, followed by square brackets <code>[]</code>. This tells the compiler that this variable will hold an array, but it does not yet specify the size or elements of the array.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">int</span>[] <span class="hljs-built_in">array</span>;
</code></pre>
<p>This line of code simply declares an array named <code>array</code> that will hold integers. The array does not yet exist in memory at this point - it is simply a declaration.</p>
<p>To create the array in memory, we instantiate it using the <code>new</code> keyword, followed by the type of the array elements and the number of elements enclosed in square brackets.</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">array</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];
</code></pre>
<p>In this line of code, we are telling the compiler to create an array of integers with a size of 5. At this point, the <code>array</code> variable references an array of five integer elements, all of which are initialised to 0, the default value for integers.</p>
<p>Arrays can also be declared, instantiated, and initialised in a single line of code.</p>
<pre><code class="lang-csharp">int[]<span class="hljs-built_in"> array </span>=<span class="hljs-built_in"> new </span>int[] { 1, 2, 3, 4, 5 };
</code></pre>
<p>This line declares an array of integers, creates it with a size of 5, and assigns the specified values to the five elements.</p>
<h3 id="multidimensional-arrays-in-c-">Multidimensional Arrays in C\</h3>
<p>C# supports multidimensional arrays. This concept can be extended to two, three, or more dimensions. A two-dimensional array can be considered a table with rows and columns.</p>
<p>The syntax for declaring a two-dimensional array involves specifying the type of elements that the array will hold, followed by two sets of square brackets <code>[,]</code>.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">int</span>[,] <span class="hljs-keyword">matrix</span>;
</code></pre>
<p>Here, <code>matrix</code> is a two-dimensional array that will hold integers. The new keyword is used to instantiate the matrix, followed by the type of the array elements and the number of rows and columns enclosed in square brackets.</p>
<pre><code class="lang-csharp">matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>];
</code></pre>
<p>This line creates a matrix with 3 rows and 3 columns.</p>
<p>Two-dimensional arrays can also be declared, instantiated, and initialised in a single line of code.</p>
<pre><code class="lang-csharp">int[,] matrix = new int[,] { { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> }, { <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> }, { <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> } };

<span class="hljs-comment">// Use the GetLength method to get the number of rows (dimension 0) and columns (dimension 1)</span>
for (int i = <span class="hljs-number">0</span>; i &lt; matrix.GetLength(<span class="hljs-number">0</span>); i++) {
    for (int j = <span class="hljs-number">0</span>; j &lt; matrix.GetLength(<span class="hljs-number">1</span>); j++)
    {
        <span class="hljs-comment">// Access each element of the array using the indices</span>
        Console.Write(matrix[i, j] + <span class="hljs-string">" "</span>);
    }
    Console.WriteLine(); <span class="hljs-comment">// Print a newline at the end of each row</span>
}
</code></pre>
<p>This example will output:</p>
<pre><code><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> 
<span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span> 
<span class="hljs-symbol">7 </span><span class="hljs-number">8</span> <span class="hljs-number">9</span>
</code></pre><p>This representation shows the <code>matrix</code> as it is, conceptually, a 3x3 grid. Each row of numbers in the output corresponds to a row in the matrix, and each number in a row corresponds to a column for that row in the matrix.</p>
<p>You can access the elements in the array using their indices. In a 2D array, the first index represents the row number, and the second index represents the column number. For instance, <code>matrix[0, 1];</code> will access the second element of the first row.</p>
<h3 id="the-array-class">The Array Class</h3>
<p>The <code>Array</code> class, part of the <code>System</code> namespace, offers various methods that help in efficiently managing and manipulating arrays.</p>
<p>The distinction between <code>Array</code> and <code>array</code> in C# can be somewhat confusing, primarily because both represent similar concepts but in different ways. <code>Array</code> is an abstract base class provided by the <code>System</code> namespace in <code>C#</code>. It provides various properties and methods like <code>Length</code>, <code>Sort()</code>, <code>Reverse()</code>, and many more that allow you to manipulate arrays.</p>
<p>An <code>array</code>, on the other hand, is a fundamental data type in C#. It is a low-level construct supported directly by the language. An <code>array</code> represents a fixed-size, sequential collection of elements of a specific type, such as int, string, or custom objects.</p>
<p>Let&#39;s look at an example:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">//arr is an array</span>
</code></pre>
<p>Here, <code>arr</code> is an array of integers. You can add, retrieve, or modify elements using their indices.</p>
<pre><code class="lang-csharp">arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// Assigns the value 1 to the first element of the array.</span>
</code></pre>
<p>On the other hand, if you want to use the functionality provided by the <code>Array</code> class on this array:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">Array</span>.<span class="hljs-keyword">Sort</span>(arr); // Uses the <span class="hljs-keyword">Sort</span> method from <span class="hljs-keyword">Array</span> class to sort <span class="hljs-string">'arr'</span>.
</code></pre>
<h4 id="array-sort-">Array.Sort()</h4>
<p>The <code>Sort()</code> method is used to sort the elements in an entire one-dimensional <code>Array</code> or, alternatively, a portion of an <code>Array</code>.</p>
<pre><code class="lang-csharp">int[] numbers = {<span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>};
Array.Sort(numbers);
</code></pre>
<p>After sorting, our array would look like:<code>{1, 2, 3, 6, 8}</code>.</p>
<h4 id="array-reverse-">Array.Reverse()</h4>
<p>The <code>Reverse()</code> method reverses the sequence of the elements in the entire one-dimensional <code>Array</code> or a portion of it.</p>
<p>For instance:</p>
<pre><code class="lang-csharp">int[] numbers = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
Array.Reverse(numbers);
</code></pre>
<p>The result will be a reversed array: <code>{3, 2, 1}</code>.</p>
<h4 id="array-indexof-">Array.IndexOf()</h4>
<p>The <code>IndexOf()</code> method returns the index of the first occurrence of a value in a one-dimensional <code>Array</code> or in a portion of the <code>Array</code>.</p>
<p>Consider this example:</p>
<pre><code class="lang-csharp">int[] numbers = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
int index = Array.IndexOf(numbers, <span class="hljs-number">2</span>);
</code></pre>
<p>The variable <code>index</code> now holds the value <code>1</code>, which is the index of number <code>2</code> in the array.</p>
<h4 id="array-clear-">Array.Clear()</h4>
<p>The <code>Clear()</code> method sets a range of elements in the <code>Array</code> to zero (in case of numeric types), false (in case of boolean types), or null (in case of reference types).</p>
<p>Take a look at this example:</p>
<p>Code: csharp</p>
<pre><code class="lang-csharp">int[] numbers = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
Array.Clear(numbers, <span class="hljs-number">0</span>, numbers.Length);
</code></pre>
<p>Now all elements in our array are set to zero: <code>{0, 0, 0}</code>.</p>
<h2 id="strings">Strings</h2>
<p>In C#, a string is not simply a character array, although it can be thought of as akin to an array of characters for some operations. In essence, a string is an instance of the <code>System.String</code> class that provides a range of sophisticated methods and properties, encapsulating a sequence of Unicode characters.</p>
<p>The main differentiation between a string and a character array is that strings in C# are immutable, meaning that once created, they cannot be changed. Any operations that appear to alter the string are actually creating a new string and discarding the old one. This design enhances security and improves performance for static or rarely changing text.</p>
<p>On the other hand, character arrays are mutable, and individual elements can be changed freely. This mutability comes at the cost of not having built-in text manipulation and comparison methods, as strings do.</p>
<p>For instance, we create a string as follows:</p>
<pre><code class="lang-csharp"><span class="hljs-attribute">string welcomeMessage</span> = <span class="hljs-string">"Welcome to Academy!"</span>;
</code></pre>
<p>Once you have a string in C#, there are many operations you can perform on it. The <code>Length</code> property, for example, returns the number of characters in the string.</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">Console</span>.WriteLine(welcomeMessage.Length); <span class="hljs-comment">// Outputs: 19</span>
</code></pre>
<p>This tells us that our <code>welcomeMessage</code> string is 19 characters long.</p>
<p>String concatenation is another operation that is used frequently. It is performed using the <code>+</code> operator.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string</span> firstString = <span class="hljs-string">"Welcome "</span>;
<span class="hljs-keyword">string</span> secondString = <span class="hljs-string">"to Academy!"</span>;
<span class="hljs-keyword">string</span> concatenatedString = firstString + secondString;
<span class="hljs-built_in">Console</span>.WriteLine(concatenatedString); <span class="hljs-comment">// Outputs: "Welcome to Academy!"</span>
</code></pre>
<p>When it comes to manipulating the casing of strings, the <code>String</code> class provides the <code>ToLower</code> and <code>ToUpper</code> methods. <code>ToLower</code> converts all the characters in a string to lowercase, while <code>ToUpper</code> converts them all to uppercase.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string</span> lowerCaseString = welcomeMessage.ToLower();
<span class="hljs-built_in">Console</span>.WriteLine(lowerCaseString); <span class="hljs-comment">// Outputs: "welcome to academy!"</span>

<span class="hljs-keyword">string</span> upperCaseString = welcomeMessage.ToUpper();
<span class="hljs-built_in">Console</span>.WriteLine(upperCaseString); <span class="hljs-comment">// Outputs: "WELCOME TO ACADEMY!"</span>
</code></pre>
<p>There are also methods to check whether a string starts or ends with a specific substring. These are the <code>StartsWith</code> and <code>EndsWith</code> methods, respectively.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">bool</span> startsWithWelcome = welcomeMessage.StartsWith(<span class="hljs-string">"Welcome"</span>);
<span class="hljs-built_in">Console</span>.WriteLine(startsWithWelcome); <span class="hljs-comment">// Outputs: True</span>

<span class="hljs-keyword">bool</span> endsWithProgramming = welcomeMessage.EndsWith(<span class="hljs-string">"Academy!"</span>);
<span class="hljs-built_in">Console</span>.WriteLine(endsWithProgramming); <span class="hljs-comment">// Outputs: True</span>
</code></pre>
<p>A common requirement in programming is to determine whether a specific substring exists within a larger string. This can be accomplished with the <code>Contains</code> method.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">bool</span> containsCsharp = welcomeMessage.Contains(<span class="hljs-string">"C#"</span>);
<span class="hljs-built_in">Console</span>.WriteLine(containsCsharp); <span class="hljs-comment">// Outputs: False</span>
</code></pre>
<p>Sometimes, you may need to replace all occurrences of a substring within a string with another substring. The <code>Replace</code> method allows you to do this.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string</span> replacedMessage = welcomeMessage.Replace(<span class="hljs-string">"Academy"</span>, <span class="hljs-string">"HTB Academy"</span>);
<span class="hljs-built_in">Console</span>.WriteLine(replacedMessage); <span class="hljs-comment">// Outputs: "Welcome to HTB Academy!"</span>
</code></pre>
<p>You can use the <code>Equals</code> method or the <code>==</code> operator when comparing two strings for equality. Both perform a case-sensitive comparison by default.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string </span><span class="hljs-keyword">str1 </span>= <span class="hljs-string">"Welcome"</span><span class="hljs-comment">;</span>
<span class="hljs-keyword">string </span><span class="hljs-keyword">str2 </span>= <span class="hljs-string">"welcome"</span><span class="hljs-comment">;</span>
<span class="hljs-keyword">bool </span>areEqual = <span class="hljs-keyword">str1.Equals(str2);
</span><span class="hljs-symbol">Console.WriteLine</span>(areEqual)<span class="hljs-comment">; // Outputs: False</span>
</code></pre>
<p>In addition to the basic operations mentioned above, there are several advanced operations that C# offers for string manipulation.</p>
<p>One of these operations is string interpolation, which provides a more readable and convenient syntax to format strings. Instead of using complicated string concatenation to include variable values within strings, string interpolation allows us to insert expressions inside string literals directly. To create an interpolated string in C#, prefix the string with a <code>$</code> symbol, and enclose any variables or expressions you want to interpolate in curly braces <code>{}</code>. When the string is processed, these expressions are replaced by their evaluated string representations.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string</span> name = <span class="hljs-string">"Alice"</span>;
<span class="hljs-keyword">string</span> greeting = $<span class="hljs-string">"Hello, {name}!"</span>;
<span class="hljs-built_in">Console</span>.WriteLine(greeting); <span class="hljs-comment">// Outputs: "Hello, Alice!"</span>
</code></pre>
<p>In the above example, <code>{name}</code> inside the string literal is replaced by the value of the variable <code>name</code>.</p>
<p>Another important string operation is trimming, which is performed using the <code>Trim</code> method. This is commonly used to remove a string&#39;s leading and trailing white space.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string</span> paddedString = <span class="hljs-string">"    Extra spaces here    "</span>;
<span class="hljs-keyword">string</span> trimmedString = paddedString.Trim();
<span class="hljs-built_in">Console</span>.WriteLine(trimmedString); <span class="hljs-comment">// Outputs: "Extra spaces here"</span>
</code></pre>
<p>The <code>Substring</code> method extracts a portion of a string starting at a specified index and continuing for a specified length. For instance:</p>
<pre><code class="lang-csharp"><span class="hljs-type">string</span> fullString = <span class="hljs-string">"Hello, World!"</span>;
<span class="hljs-type">string</span> partialString = fullString.Substring(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);
Console.WriteLine(partialString); <span class="hljs-comment">// Outputs: "World"</span>
</code></pre>
<p>In the above example, <code>Substring(7, 5)</code> returns a new string starting at index 7 and of length 5 from the <code>fullString</code>.</p>
<p>Moreover, using the <code>Split</code> method, strings can be split into arrays of substrings based on delimiters. This is especially useful when parsing input or handling data that comes in string form.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string</span> sentence = <span class="hljs-string">"This is a sentence."</span>;
<span class="hljs-keyword">string</span>[] words = sentence.Split(<span class="hljs-string">' '</span>);
foreach (<span class="hljs-keyword">string</span> <span class="hljs-keyword">word</span> in words)
{
    <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-keyword">word</span>);
}
<span class="hljs-comment">// Outputs: </span>
<span class="hljs-comment">// "This"</span>
<span class="hljs-comment">// "is"</span>
<span class="hljs-comment">// "a"</span>
<span class="hljs-comment">// "sentence."</span>
</code></pre>
<p>In this example, the <code>Split</code> method splits the <code>sentence</code> string into an array of words based on the space character delimiter.</p>
<p>Lastly, the <code>Join</code> method concatenates all elements in a string array or collection, using a specified separator between each element.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string</span>[] words = { <span class="hljs-string">"This"</span>, <span class="hljs-string">"is"</span>, <span class="hljs-string">"a"</span>, <span class="hljs-string">"sentence"</span> };
<span class="hljs-keyword">string</span> sentence = <span class="hljs-keyword">string</span>.Join(<span class="hljs-string">" "</span>, words);
<span class="hljs-built_in">Console</span>.WriteLine(sentence); <span class="hljs-comment">// Outputs: "This is a sentence"</span>
</code></pre>
<p>In this case, <code>Join</code> constructs a single string from all the elements in the <code>words</code> array, with a space character as the separator.</p>
<h2 id="collections">Collections</h2>
<hr>
<p>In C#, a collection is used to group related objects. Collections provide a more flexible way to work with groups of objects, as unlike arrays, the group of objects you work with can grow and shrink dynamically as the demands of the application change. Collections are defined in the <code>System.Collections</code> namespace.</p>
<h3 id="iterating-through-a-collection">Iterating through a collection</h3>
<p>The <code>foreach</code> loop is an efficient and straightforward way to iterate through any collection. It automatically moves to the next item in the collection at the end of each loop iteration, making it an excellent choice for reading collections. Suppose you want to modify the collection while iterating over it. In that case, you might need to use a different looping construct, like a <code>for</code> loop, as <code>foreach</code> does not support collection modification during iteration.</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };

<span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.Count; i++)
{
    <span class="hljs-comment">// Modify the element at index i</span>
    numbers[i] *= <span class="hljs-number">2</span>;
}

foreach (<span class="hljs-built_in">int</span> number <span class="hljs-keyword">in</span> numbers)
{
    Console.WriteLine(number);
}
</code></pre>
<p>We use a <code>for</code> loop to iterate over the numbers list in this example. The loop variable <code>i</code> represents the index of each element in the list. Within the loop, we can modify the element at the current index by performing the desired operation, in this case, multiplying it by 2. After the <code>for</code> loop completes, we use a <code>foreach</code> loop to iterate over the modified <code>numbers</code> list and print each number to the console.</p>
<h3 id="list">List</h3>
<p>A <code>List&lt;T&gt;</code> is one of the most commonly used types in .NET, especially when we need a resizable array-like collection. This type is found in the <code>System.Collections.Generic</code> namespace is a generic class which supports storing values of any type. However, all <code>List&lt;T&gt;</code> elements must be the same type.</p>
<pre><code class="lang-csharp">List&lt;<span class="hljs-keyword">string</span>&gt; namesList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">string</span>&gt;();

<span class="hljs-comment">// Adding elements to the list</span>
namesList.Add(<span class="hljs-string">"John"</span>);
namesList.Add(<span class="hljs-string">"Jane"</span>);
namesList.Add(<span class="hljs-string">"Alice"</span>);

<span class="hljs-comment">// Accessing elements by index</span>
<span class="hljs-keyword">string</span> firstElement = namesList[<span class="hljs-number">0</span>]; <span class="hljs-comment">// O(1) indexed access</span>

<span class="hljs-comment">// Modifying an element</span>
namesList[<span class="hljs-number">1</span>] = <span class="hljs-string">"Emily"</span>;

<span class="hljs-comment">// Checking if an element exists</span>
<span class="hljs-keyword">bool</span> hasAlice = namesList.Contains(<span class="hljs-string">"Alice"</span>);

<span class="hljs-comment">// Removing an element</span>
namesList.Remove(<span class="hljs-string">"John"</span>);

<span class="hljs-comment">// Iterating over the elements</span>
<span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">string</span> name <span class="hljs-keyword">in</span> namesList)
{
    Console.WriteLine(name);
}
</code></pre>
<p>A <code>List&lt;T&gt;</code> provides the advantage of dynamic resizing compared to an array. However, this also means that a <code>List&lt;T&gt;</code> generally uses more memory than an array, as it allocates extra space to allow for potential growth. If the size of your collection is fixed, using an array could be more memory-efficient.</p>
<p>However, the flexibility and utility of the <code>List&lt;T&gt;</code> class methods often outweigh the minor performance and memory usage benefits of arrays in many scenarios. This is especially true in applications where the exact count of elements may change over time.</p>
<h3 id="dictionary">Dictionary</h3>
<p>A <code>Dictionary&lt;TKey, TValue&gt;</code> is a collection that stores and retrieves data using a key-value relationship. It is part of the <code>System.Collections.Generic</code> namespace in C#.</p>
<p>To use a <code>Dictionary&lt;TKey, TValue&gt;</code>, specify the key type (<code>TKey</code>) and the value (<code>TValue</code>) in the angle brackets. For example, <code>Dictionary&lt;int, string&gt;</code> indicates a dictionary where the keys are integers and the values are strings.</p>
<pre><code class="lang-csharp">Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>&gt; studentGrades = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>&gt;();

<span class="hljs-comment">// Adding key-value pairs to the dictionary</span>
studentGrades.Add(<span class="hljs-string">"John"</span>, <span class="hljs-number">85</span>);
studentGrades.Add(<span class="hljs-string">"Jane"</span>, <span class="hljs-number">92</span>);
studentGrades.Add(<span class="hljs-string">"Alice"</span>, <span class="hljs-number">78</span>);

<span class="hljs-comment">// Accessing values by key</span>
<span class="hljs-keyword">int</span> johnGrade = studentGrades[<span class="hljs-string">"John"</span>]; <span class="hljs-comment">// O(1) lookup by key</span>

<span class="hljs-comment">// Modifying an existing value</span>
studentGrades[<span class="hljs-string">"Jane"</span>] = <span class="hljs-number">95</span>;

<span class="hljs-comment">// Checking if a key exists</span>
<span class="hljs-keyword">bool</span> hasAlice = studentGrades.ContainsKey(<span class="hljs-string">"Alice"</span>);

<span class="hljs-comment">// Removing a key-value pair</span>
studentGrades.Remove(<span class="hljs-string">"John"</span>);

<span class="hljs-comment">// Iterating over the key-value pairs</span>
<span class="hljs-keyword">foreach</span> (KeyValuePair&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>&gt; pair <span class="hljs-keyword">in</span> studentGrades)
{
    Console.WriteLine(<span class="hljs-string">$"Name: <span class="hljs-subst">{pair.Key}</span>, Grade: <span class="hljs-subst">{pair.Value}</span>"</span>);
}
</code></pre>
<h3 id="hashset">HashSet</h3>
<p>A <code>HashSet&lt;T&gt;</code> collection stores an unordered set of unique elements. The primary characteristic of a <code>HashSet</code> is its ability to store unique elements, completely disallowing duplication. Adding elements to a <code>HashSet</code> will check if the element already exists before adding it. This makes <code>HashSet</code> an optimal choice when you need to store a collection of items without any duplicates and do not require a specific order.</p>
<p>To use a <code>HashSet</code>, specify the type of elements (<code>T</code>) within the angle brackets. For example, <code>HashSet&lt;int&gt;</code> indicates a set of integers.</p>
<pre><code class="lang-csharp">HashSet&lt;<span class="hljs-keyword">string</span>&gt; namesHashSet = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-keyword">string</span>&gt;();

<span class="hljs-comment">// Adding elements to the set</span>
namesHashSet.Add(<span class="hljs-string">"John"</span>);
namesHashSet.Add(<span class="hljs-string">"Jane"</span>);
namesHashSet.Add(<span class="hljs-string">"Alice"</span>);

<span class="hljs-comment">// Checking if an element exists</span>
<span class="hljs-keyword">bool</span> hasAlice = namesHashSet.Contains(<span class="hljs-string">"Alice"</span>); <span class="hljs-comment">// O(1) membership check</span>

<span class="hljs-comment">// Removing an element</span>
namesHashSet.Remove(<span class="hljs-string">"John"</span>);

<span class="hljs-comment">// Iterating over the elements</span>
<span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">string</span> name <span class="hljs-keyword">in</span> namesHashSet)
{
    Console.WriteLine(name);
}
</code></pre>
<h3 id="list-vs-dictionary-vs-hashset">List vs Dictionary vs HashSet</h3>
<p>Each collection type has its unique characteristics, behaviours, and use cases.</p>
<table>
<thead>
<tr>
<th></th>
<th>List</th>
<th>Dictionary</th>
<th>HashSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data Structure</td>
<td>Ordered</td>
<td>Key-Value Pairs</td>
<td>Unordered, Unique Elements</td>
</tr>
<tr>
<td>Duplication</td>
<td>Allows duplicates</td>
<td>Keys must be unique</td>
<td>Ensures uniqueness</td>
</tr>
<tr>
<td>Access and Lookup</td>
<td>Indexed access by index</td>
<td>Fast lookup by unique key</td>
<td>Membership checks</td>
</tr>
<tr>
<td>Ordering</td>
<td>Maintains order</td>
<td>No specific order</td>
<td>No specific order</td>
</tr>
<tr>
<td>Element Removal</td>
<td>By index or value</td>
<td>By key</td>
<td>By value</td>
</tr>
<tr>
<td>Memory Overhead</td>
<td>Consumes memory based on elements</td>
<td>Memory for keys and values</td>
<td>Memory for unique elements</td>
</tr>
<tr>
<td>Use Cases</td>
<td>Ordered collection, indexed access</td>
<td>Associating values with keys, key-based lookup</td>
<td>Unordered collection, uniqueness and membership checks</td>
</tr>
</tbody>
</table>
<h3 id="collection-performance">Collection Performance</h3>
<p>Performance considerations vary for each collection type based on the operations performed and the specific use case.</p>
<p><code>Big-O notation</code> is a notation used in computer science to describe the performance characteristics of an algorithm, specifically its time complexity and space complexity.</p>
<p>In terms of time complexity, <code>Big-O notation</code> quantifies the worst-case scenario of an algorithm as the size of the input data approaches infinity. For instance, if an algorithm has a time complexity of <code>O(n)</code>, it indicates that the time it takes to execute the algorithm grows linearly with the input data size. On the other hand, an algorithm with a time complexity of <code>O(n^2)</code> would suggest that the execution time increases quadratically with the input size.</p>
<p>While analysed less frequently, <code>Big-O</code> notation can also describe space complexity by measuring the amount of memory an algorithm needs relative to the input size. For example, an algorithm with a space complexity of <code>O(1)</code> uses a constant amount of memory regardless of the input size.</p>
<p>Here are some general performance considerations for <code>List</code>, <code>Dictionary</code>, and <code>HashSet</code>:</p>
<table>
<thead>
<tr>
<th></th>
<th>List</th>
<th>Dictionary</th>
<th>HashSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>Access Speed</td>
<td>Very fast, O(1)</td>
<td>Average: O(1), Worst: O(n)</td>
<td>Average: O(1), Worst: O(n)</td>
</tr>
<tr>
<td>Insertion/Removal</td>
<td>Insertion and removal at ends: O(1)</td>
<td>Average: O(1), Worst: O(n)</td>
<td>Average: O(1), Worst: O(n)</td>
</tr>
<tr>
<td>Searching</td>
<td><p>Unsorted: O(n)<br>Sorted (Binary Search): O(log n)</p></td>
<td>Key-based lookup: Average O(1), Worst O(n)</td>
<td>Membership check: Average O(1), Worst O(n)</td>
</tr>
<tr>
<td>Memory Overhead</td>
<td>Relatively low</td>
<td>Keys and values, additional structure fields</td>
<td>Unique elements, additional structure fields</td>
</tr>
</tbody>
</table>
<p>Please note that the access speed represents the time complexity of accessing elements in the collection, whether it&#39;s by index (for List) or by key (for Dictionary) or membership check (for HashSet). The performance characteristics in this table are general guidelines and may vary based on the specific implementation and use case.</p>
<h2 id="linq-language-integrated-query-">LINQ (Language Integrated Query)</h2>
<hr>
<p>Language Integrated Query (LINQ) is a feature in C# that provides a consistent model for working with data across various kinds of data sources and formats. You use LINQ to query data with C# irrespective of the data source.</p>
<p>In a more technical sense, LINQ is a set of methods, provided as extension methods in .NET, that provide a universal approach to querying data of any type. This data can be in-memory objects (like lists or arrays), XML, databases, or any other format for which a LINQ provider is available. These methods take lambda expressions as arguments, which behave like in-line functions that work on the dataset being queried.</p>
<p>There are several benefits to using LINQ in your C# applications:</p>
<ol>
<li><code>Simplicity</code>: LINQ simplifies querying and manipulating data by providing a consistent query syntax across different data sources, making code cleaner and more maintainable.</li>
<li><code>Type Safety</code>: LINQ is strongly typed, meaning compile-time type checking is performed on query expressions.</li>
<li><code>Expressiveness</code>: LINQ offers a rich set of query operators that allow you to express complex data operations concisely and declaratively, making queries easy to read.</li>
<li><code>Integration</code>: LINQ is seamlessly integrated into the C# language and can be used with various data sources, including in-memory collections, databases (via LINQ to SQL or Entity Framework), XML, and web services.</li>
</ol>
<h3 id="linq-query-syntax">LINQ Query Syntax</h3>
<p>LINQ provides two main syntaxes for writing queries: query syntax and method syntax. The query syntax is often preferred for its readability and resemblance to SQL, while the method syntax offers more flexibility and composability. Let us explore both syntaxes with examples.</p>
<p>Consider a simple example where we have a list of integers and want to retrieve all the even numbers from the list:</p>
<pre><code class="lang-csharp">// This creates a <span class="hljs-built_in">new</span> list of integers named 'numbers' <span class="hljs-keyword">and</span> populates it with the numbers from <span class="hljs-number">1</span> to <span class="hljs-number">10</span>.
List&lt;int&gt; numbers = <span class="hljs-built_in">new</span> List&lt;int&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> };

// This <span class="hljs-built_in">is</span> a LINQ query that will create a <span class="hljs-built_in">new</span> collection called 'evenNumbers'. 
// The 'from <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> numbers' <span class="hljs-built_in">part</span> signifies that we're querying over the 'numbers' list <span class="hljs-keyword">and</span> will refer to each element as '<span class="hljs-built_in">num</span>'.
// The 'where <span class="hljs-built_in">num</span> <span class="hljs-symbol">%</span> <span class="hljs-number">2</span> == <span class="hljs-number">0</span>' <span class="hljs-built_in">part</span> <span class="hljs-built_in">is</span> a condition that each number <span class="hljs-keyword">in</span> the list must satisfy to be included <span class="hljs-keyword">in</span> the <span class="hljs-built_in">new</span> collection - <span class="hljs-keyword">in</span> this case, the number must be <span class="hljs-built_in">even</span>. 
// The '<span class="hljs-symbol">%</span>' operator <span class="hljs-built_in">is</span> the <span class="hljs-built_in">modulus</span> operator, which gives the <span class="hljs-built_in">remainder</span> of <span class="hljs-built_in">integer</span> division. So '<span class="hljs-built_in">num</span> <span class="hljs-symbol">%</span> <span class="hljs-number">2</span>' gives the <span class="hljs-built_in">remainder</span> when '<span class="hljs-built_in">num</span>' <span class="hljs-built_in">is</span> divided by <span class="hljs-number">2</span>. If this <span class="hljs-built_in">remainder</span> <span class="hljs-built_in">is</span> <span class="hljs-number">0</span>, <span class="hljs-keyword">then</span> the number <span class="hljs-built_in">is</span> <span class="hljs-built_in">even</span>.
// The 'select <span class="hljs-built_in">num</span>' <span class="hljs-built_in">part</span> signifies that <span class="hljs-keyword">if</span> a number satisfies the condition, <span class="hljs-keyword">then</span> it should be included <span class="hljs-keyword">in</span> the 'evenNumbers' collection.
<span class="hljs-built_in">var</span> evenNumbers = from <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> numbers
                  where <span class="hljs-built_in">num</span> <span class="hljs-symbol">%</span> <span class="hljs-number">2</span> == <span class="hljs-number">0</span>
                  select <span class="hljs-built_in">num</span>;
</code></pre>
<p>In the above code, we use the <code>from</code> clause to define a range variable <code>num</code> representing each element in the <code>numbers</code> list. The <code>where</code> clause filters the numbers based on the condition <code>num % 2 == 0</code>, selecting only the even numbers. Finally, the <code>select</code> clause projects the selected numbers into the <code>evenNumbers</code> variable.</p>
<p>The equivalent code using method syntax would look like this:</p>
<pre><code class="lang-csharp">// This creates a <span class="hljs-keyword">new</span> list <span class="hljs-keyword">of</span> integers named <span class="hljs-symbol">'numbers</span>' <span class="hljs-keyword">and</span> populates it <span class="hljs-keyword">with</span> the numbers from <span class="hljs-number">1</span> to <span class="hljs-number">10</span>.
List&lt;int&gt; numbers = <span class="hljs-keyword">new</span> List&lt;int&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> };

// This <span class="hljs-keyword">is</span> a LINQ query using method syntax. It creates a <span class="hljs-keyword">new</span> collection called <span class="hljs-symbol">'evenNumbers</span>' from the <span class="hljs-symbol">'numbers</span>' list.
// The <span class="hljs-symbol">'Where</span>' method filters the <span class="hljs-symbol">'numbers</span>' list based on the provided lambda expression <span class="hljs-symbol">'num</span> =&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>'.
// The lambda expression takes each number <span class="hljs-symbol">'num</span>' <span class="hljs-keyword">in</span> the <span class="hljs-symbol">'numbers</span>' list <span class="hljs-keyword">and</span> returns <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> <span class="hljs-symbol">'num</span>' <span class="hljs-keyword">is</span> even (i.e., <span class="hljs-keyword">if</span> the remainder <span class="hljs-keyword">when</span> <span class="hljs-symbol">'num</span>' <span class="hljs-keyword">is</span> divided by <span class="hljs-number">2</span> <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>), <span class="hljs-keyword">and</span> <span class="hljs-literal">false</span> otherwise.
// The <span class="hljs-symbol">'Where</span>' method <span class="hljs-keyword">then</span> includes <span class="hljs-keyword">in</span> <span class="hljs-symbol">'evenNumbers</span>' only those numbers <span class="hljs-keyword">for</span> which the lambda expression returned <span class="hljs-literal">true</span>.
// As a result, <span class="hljs-symbol">'evenNumbers</span>' will include <span class="hljs-keyword">all</span> even numbers from the original <span class="hljs-symbol">'numbers</span>' list. The output will be: <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>.
var evenNumbers = numbers.Where(num =&gt; num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>); // Output: <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>
</code></pre>
<p>In the method syntax, we use the <code>Where</code> operator to filter the numbers based on the provided condition.</p>
<h3 id="linq-operators">LINQ Operators</h3>
<p>LINQ provides a series of <code>query operators</code>, each performing a specific operation on a data source. The power of LINQ comes from these operators, which can be combined in various ways to compose complex queries.</p>
<h4 id="where">Where</h4>
<p>The <code>Where</code> operator filters a sequence based on a specified condition.</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> };

<span class="hljs-comment">// This line filters the 'numbers' list using a LINQ query. The query uses a lambda expression to select only the numbers that are even (i.e., numbers where the remainder of the division by 2 is equal to zero). </span>
<span class="hljs-comment">// The result is a new collection 'evenNumbers' containing all the even numbers from the original 'numbers' list.</span>
<span class="hljs-keyword">var</span> evenNumbers = numbers.Where(<span class="hljs-built_in">num</span> =&gt; <span class="hljs-built_in">num</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);

<span class="hljs-comment">// Output: 2, 4, 6, 8, 10</span>
foreach (<span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> evenNumbers)
{
    Console.WriteLine(<span class="hljs-built_in">num</span>);
}
</code></pre>
<h4 id="select">Select</h4>
<p>The <code>Select</code> operator projects each element of a sequence into a new form.</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">List</span>&lt;string&gt; names = new <span class="hljs-built_in">List</span>&lt;string&gt; { <span class="hljs-string">"John"</span>, <span class="hljs-string">"Alice"</span>, <span class="hljs-string">"Michael"</span> };

<span class="hljs-comment">// This line uses a LINQ query with the Select method to create a new collection 'upperCaseNames'. </span>
<span class="hljs-comment">// The query takes the 'names' collection and applies the 'ToUpper' method to each element. </span>
<span class="hljs-comment">// The ToUpper method is a built-in C# method that converts all the characters in a string to uppercase.</span>
<span class="hljs-comment">// The result is a new collection where all the names from the original 'names' collection are transformed into uppercase.</span>
var upperCaseNames = names.<span class="hljs-built_in">Select</span>(<span class="hljs-built_in">name</span> =&gt; <span class="hljs-built_in">name</span>.<span class="hljs-built_in">ToUpper</span>());

<span class="hljs-comment">// Output: JOHN, ALICE, MICHAEL</span>
<span class="hljs-keyword">foreach</span> (var <span class="hljs-built_in">name</span> <span class="hljs-built_in">in</span> upperCaseNames)
{
    Console.WriteLine(<span class="hljs-built_in">name</span>);
}
</code></pre>
<h4 id="orderby-orderbydescending">OrderBy/OrderByDescending</h4>
<p>The <code>OrderBy</code> and <code>OrderByDescending</code> operators sort the elements of a sequence in ascending or descending order.</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; { <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span> };

<span class="hljs-comment">// The OrderBy method is a LINQ operation that sorts the elements of a collection in ascending order according to a key. In this case, the key is the numbers themselves.</span>
<span class="hljs-keyword">var</span> sortedNumbersAsc = numbers.OrderBy(<span class="hljs-built_in">num</span> =&gt; <span class="hljs-built_in">num</span>);

<span class="hljs-comment">// Output: 1, 2, 5, 8, 9</span>
foreach (<span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> sortedNumbersAsc)
{
    Console.WriteLine(<span class="hljs-built_in">num</span>);
}

<span class="hljs-comment">// The OrderByDescending method is similar to OrderBy, but sorts the elements in descending order. Like in the previous example, the key is the numbers themselves.</span>
<span class="hljs-keyword">var</span> sortedNumbersDesc = numbers.OrderByDescending(<span class="hljs-built_in">num</span> =&gt; <span class="hljs-built_in">num</span>);

<span class="hljs-comment">// Output: 9, 8, 5, 2, 1</span>
foreach (<span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span> <span class="hljs-keyword">in</span> sortedNumbersDesc)
{
    Console.WriteLine(<span class="hljs-built_in">num</span>);
}
</code></pre>
<h4 id="groupby">GroupBy</h4>
<p>The <code>GroupBy</code> operator groups elements of a sequence based on a specified key.</p>
<pre><code class="lang-csharp"><span class="hljs-comment">// Define a class 'Student' with two properties: 'Name' and 'Grade'. The 'get' and 'set' are accessors which control the read-write status of these properties.</span>

<span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Grade { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Create a list of students, where each student is an instance of the 'Student' class. Each student has a 'Name' and a 'Grade'.</span>
List&lt;Student&gt; students = <span class="hljs-keyword">new</span> List&lt;Student&gt;
{
    <span class="hljs-keyword">new</span> Student { Name = <span class="hljs-string">"John"</span>, Grade = <span class="hljs-string">"A"</span> },
    <span class="hljs-keyword">new</span> Student { Name = <span class="hljs-string">"Alice"</span>, Grade = <span class="hljs-string">"B"</span> },
    <span class="hljs-keyword">new</span> Student { Name = <span class="hljs-string">"Michael"</span>, Grade = <span class="hljs-string">"A"</span> },
    <span class="hljs-keyword">new</span> Student { Name = <span class="hljs-string">"Emily"</span>, Grade = <span class="hljs-string">"B"</span> }
};

<span class="hljs-comment">// Using the LINQ GroupBy method, we group the students by their grades. This method returns a collection of `IGrouping&lt;TKey,TElement&gt;` objects, where each `IGrouping` object contains a collection of objects that have the same key.</span>
<span class="hljs-keyword">var</span> studentsByGrade = students.GroupBy(student =&gt; student.Grade);

<span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">in</span> studentsByGrade)
{
    Console.WriteLine(<span class="hljs-string">"Students in Grade "</span> + <span class="hljs-keyword">group</span>.Key + <span class="hljs-string">":"</span>);
    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> student <span class="hljs-keyword">in</span> <span class="hljs-keyword">group</span>)
    {
        Console.WriteLine(student.Name);
    }
}
<span class="hljs-comment">// Students in Grade A:</span>
<span class="hljs-comment">// John</span>
<span class="hljs-comment">// Michael</span>
<span class="hljs-comment">// Students in Grade B:</span>
<span class="hljs-comment">// Alice</span>
<span class="hljs-comment">// Emily</span>
</code></pre>
<p>When the <code>GroupBy</code> method is called, it groups the elements of the original collection (<code>students</code> in this case) based on a specified key. In this case, the key is <code>student.Grade</code>, which means the students are grouped by their grades. Each <code>group</code> is an <code>IGrouping&lt;TKey, TElement&gt;</code> object (where <code>TKey</code> is the type of the key and <code>TElement</code> is the type of the elements in the group). In this specific case, <code>TKey</code> is a <code>string</code> (the grade) and <code>TElement</code> is a <code>Student</code>.</p>
<p>So, in the foreach loop, <code>group</code> represents each of these <code>IGrouping&lt;string, Student&gt;</code> objects. The <code>Key</code> property of each <code>group</code> holds the grade (A or B in this example), and iterating over <code>group</code> gives you each student in that grade.</p>
<h4 id="join">Join</h4>
<p>The <code>Join</code> operator combines two sequences based on a common key.</p>
<pre><code class="lang-csharp"><span class="hljs-comment">// This is the Student class with properties for Id, Name, and CourseId. The 'get' and 'set' are accessors which control the read-write status of these properties.</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>
</span>{
    <span class="hljs-keyword">public</span> int Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> string Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> int CourseId { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// This is the Course class with properties for Id and Title. The 'get' and 'set' are accessors which control the read-write status of these properties.</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span>
</span>{
    <span class="hljs-keyword">public</span> int Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> string Title { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}

<span class="hljs-comment">// Here we create a list of students, where each student is an instance of the 'Student' class. Each student has an 'Id', 'Name', and a 'CourseId'.</span>
List&lt;Student&gt; students = <span class="hljs-keyword">new</span> <span class="hljs-type">List</span>&lt;Student&gt;
{
    <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span> { Id = <span class="hljs-number">1</span>, Name = <span class="hljs-string">"John"</span>, CourseId = <span class="hljs-number">101</span> },
    <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span> { Id = <span class="hljs-number">2</span>, Name = <span class="hljs-string">"Alice"</span>, CourseId = <span class="hljs-number">102</span> },
    <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span> { Id = <span class="hljs-number">3</span>, Name = <span class="hljs-string">"Michael"</span>, CourseId = <span class="hljs-number">101</span> },
    <span class="hljs-keyword">new</span> <span class="hljs-type">Student</span> { Id = <span class="hljs-number">4</span>, Name = <span class="hljs-string">"Emily"</span>, CourseId = <span class="hljs-number">103</span> }
};

<span class="hljs-comment">// We create a list of courses, where each course is an instance of the 'Course' class. Each course has an 'Id' and a 'Title'.</span>
List&lt;Course&gt; courses = <span class="hljs-keyword">new</span> <span class="hljs-type">List</span>&lt;Course&gt;
{
    <span class="hljs-keyword">new</span> <span class="hljs-type">Course</span> { Id = <span class="hljs-number">101</span>, Title = <span class="hljs-string">"Mathematics"</span> },
    <span class="hljs-keyword">new</span> <span class="hljs-type">Course</span> { Id = <span class="hljs-number">102</span>, Title = <span class="hljs-string">"Science"</span> },
    <span class="hljs-keyword">new</span> <span class="hljs-type">Course</span> { Id = <span class="hljs-number">103</span>, Title = <span class="hljs-string">"History"</span> }
};

<span class="hljs-comment">// Here we perform a join operation between the 'students' and 'courses' lists using LINQ's Join method.</span>
<span class="hljs-comment">// We match each student with their corresponding course based on the CourseId from the student and the Id from the course.</span>
<span class="hljs-comment">// The result is a new anonymous object that includes each student's name and the title of their course.</span>
<span class="hljs-keyword">var</span> studentCourseInfo = students.Join(courses,
                                      student =&gt; student.CourseId,
                                      course =&gt; course.Id,
                                      (student, course) =&gt; <span class="hljs-keyword">new</span><span class="hljs-type"></span>
                                      {
                                          student.Name,
                                          course.Title
                                      });

foreach (<span class="hljs-keyword">var</span> info <span class="hljs-keyword">in</span> studentCourseInfo)
{
    Console.WriteLine(info.Name + <span class="hljs-string">" - "</span> + info.Title);
}

<span class="hljs-comment">// John - Mathematics</span>
<span class="hljs-comment">// Alice - Science</span>
<span class="hljs-comment">// Michael - Mathematics</span>
<span class="hljs-comment">// Emily - History</span>
</code></pre>
<h4 id="aggregate">Aggregate</h4>
<p>The <code>Aggregate</code> operator applies an accumulator function over a sequence.</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">int</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };

<span class="hljs-comment">// This line uses the LINQ Aggregate method to generate a single value from the 'numbers' collection.</span>
<span class="hljs-comment">// The Aggregate method applies a specified function to the first two elements of the collection, then to the result and the next element, and so on. </span>
<span class="hljs-comment">// In this case, the function is a lambda expression '(acc, num) =&gt; acc + num', where 'acc' represents the accumulated value so far and 'num' represents the current element.</span>
<span class="hljs-comment">// So essentially, this code sums up all the numbers in the 'numbers' collection. The resulting sum is then stored in the 'sum' variable.</span>
<span class="hljs-keyword">var</span> sum = numbers.Aggregate((acc, <span class="hljs-built_in">num</span>) =&gt; acc + <span class="hljs-built_in">num</span>);

<span class="hljs-comment">// Output: 15</span>
Console.WriteLine(sum);
</code></pre>
<h4 id="count-sum-average-min-max">Count/Sum/Average/Min/Max</h4>
<p>These methods compute a sequence&#39;s <code>count</code>, <code>sum</code>, <code>average</code>, <code>minimum</code>, or <code>maximum</code> value.</p>
<pre><code class="lang-csharp">List&lt;<span class="hljs-keyword">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt; { <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span> };

<span class="hljs-comment">// The Count method is a LINQ extension method that returns the number of elements in the 'numbers' collection. The result is stored in the 'count' variable.</span>
<span class="hljs-keyword">int</span> count = numbers.Count();
<span class="hljs-comment">// The Sum method calculates the sum of all elements in the 'numbers' collection. The resulting sum is stored in the 'sum' variable.</span>
<span class="hljs-keyword">int</span> sum = numbers.Sum();
<span class="hljs-comment">// The Average method calculates the average value of all elements in the 'numbers' collection. Since an average can be a fractional number, it's stored in a variable of type double.</span>
<span class="hljs-keyword">double</span> average = numbers.Average();
<span class="hljs-comment">// The Min method finds the smallest number in the 'numbers' collection. The minimum value found is stored in the 'min' variable.</span>
<span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span> = numbers.Min();
<span class="hljs-comment">// The Max method finds the largest number in the 'numbers' collection. The maximum value found is stored in the 'max' variable.</span>
<span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = numbers.Max();

<span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"Count: "</span> + count);        <span class="hljs-comment">// Output: Count: 5</span>
<span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"Sum: "</span> + sum);            <span class="hljs-comment">// Output: Sum: 25</span>
<span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"Average: "</span> + average);    <span class="hljs-comment">// Output: Average: 5</span>
<span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"Min: "</span> + <span class="hljs-built_in">min</span>);            <span class="hljs-comment">// Output: Min: 1</span>
<span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"Max: "</span> + <span class="hljs-built_in">max</span>);            <span class="hljs-comment">// Output: Max: 9</span>
</code></pre>
<p>This code has a <code>List&lt;int&gt;</code> called numbers with five elements. We use various LINQ extension methods (<code>Count()</code>, <code>Sum()</code>, <code>Average()</code>, <code>Min()</code>, <code>Max()</code>) to perform calculations on the list. The expected output comments indicate the results when printing the count, sum, average, minimum, and maximum values to the console.</p>
<h2 id="methods-and-exception-handling">Methods and Exception Handling</h2>
<hr>
<h3 id="functions">Functions</h3>
<p>Functions, known as methods in C#, are a significant feature of programming, providing a means to create reusable code. They allow programmers to build modular programs, improving efficiency, readability, and maintainability.</p>
<h4 id="creating-a-method">Creating a method</h4>
<p>In C#, a method declaration specifies the method’s name, return type, and parameters within the class definition. Here&#39;s an example of a method declaration for a simple method that multiplies two numbers:</p>
<pre><code class="lang-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Multiply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;
</code></pre>
<p>The method is declared <code>public</code>, which means it can be accessed from other classes. <code>int</code> signifies the return type, indicating that the method will return an integer value. <code>Multiply</code> is the method&#39;s name, and within the parentheses <code>(int a, int b)</code>, we define the parameters the method will take.</p>
<p>The definition of a method involves providing the body of the method or what the method does. The code block inside the curly brackets <code>{}</code> forms the method’s body. Let&#39;s define our <code>Multiply</code> method:</p>
<pre><code class="lang-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Multiply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> 
</span>{
    <span class="hljs-keyword">return</span> a * b;
}
</code></pre>
<p>The <code>return</code> statement specifies the output of the method . In this case, it returns the product of <code>a</code> and <code>b</code>.</p>
<p>In C#, the terms &quot;declaration&quot; and &quot;definition&quot; of a method aren&#39;t typically differentiated, as they are in some languages such as C or C++. This is because C# does not permit separate declaration and definition of methods - when you declare a method, you must also provide its implementation, thus effectively defining it.</p>
<h4 id="method-scope">Method Scope</h4>
<p>Scope pertains to the visibility or accessibility of variables within the program. In C#, variables declared inside a method, known as local variables, are not accessible outside that method. For instance:</p>
<pre><code class="lang-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Multiply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> 
</span>{
    <span class="hljs-keyword">int</span> result = a * b;
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayResult</span><span class="hljs-params">()</span> 
</span>{
    Console.WriteLine(result); <span class="hljs-comment">// This will lead to an error</span>
}
</code></pre>
<p>In the <code>DisplayResult()</code> method, accessing the <code>result</code> variable local to the Multiply method would result in a compile-time error. This is because the <code>result</code> is out of scope in <code>DisplayResult()</code>.</p>
<p>However, if a variable is declared in a class but outside any method, it is a global variable and can be accessed from any method within that class.</p>
<h4 id="static-vs-non-static-methods">Static vs Non-Static Methods</h4>
<p>The <code>static</code> keyword is used to declare members that <code>belong to the type</code> rather than <code>any instance of the type</code>. This means that static members are shared across all instances of a type and can be accessed directly using the type name, without creating an instance of the class.</p>
<p>Methods can be declared as <code>static</code> or <code>non-static</code>, also known as <code>instance</code> methods.</p>
<p>Details about <code>classes</code> and <code>instances</code> will be explored in the <code>Object-oriented Programming</code> section, but for now, just note the following.</p>
<p>A <code>static</code> method belongs to the class itself rather than any specific class instance. It is declared with the keyword <code>static</code>.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>
{
    <span class="hljs-comment">// Static method</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyStaticMethod</span>(<span class="hljs-params"></span>)
    </span>{
        Console.WriteLine(<span class="hljs-string">"This is a static method."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)
    </span>{
        <span class="hljs-comment">// Call the static method</span>
        MyClass.MyStaticMethod();  <span class="hljs-comment">// Outputs: This is a static method.</span>
    }
}
</code></pre>
<p>To call a static method, you don&#39;t need to create an instance of the class. Instead, you use the class name itself.</p>
<pre><code class="lang-csharp">MyClass.MyStaticMethod()<span class="hljs-comment">;</span>
</code></pre>
<p>Since static methods are tied to the class itself, they can only access the class&#39;s other static members (methods, properties, etc.). They cannot access non-static members as those belong to specific instances of the class.</p>
<p>A <code>non-static</code> (or <code>instance</code>) method belongs to a particular class instance. It is declared without using the <code>static</code> keyword.</p>
<pre><code class="lang-csharp">public class MyClass
{
    // Non-static (instance) method
   <span class="hljs-keyword"> public</span> void MyInstanceMethod()
    {
        Console.WriteLine(<span class="hljs-string">"This is an instance method."</span>);
    }
}
<span class="hljs-keyword">
public</span> class Program
{
   <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> void Main(string[] args)
    {
        // Create an<span class="hljs-built_in"> instance </span>of MyClass
        MyClass myObject =<span class="hljs-built_in"> new </span>MyClass();

        // Call the<span class="hljs-built_in"> instance </span>method
        myObject.MyInstanceMethod();  // Outputs: This is an<span class="hljs-built_in"> instance </span>method.
    }
}
</code></pre>
<p>To call a non-static method, you must create an instance of the class.</p>
<pre><code class="lang-csharp"><span class="hljs-type">MyClass</span> myObject = <span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">MyClass</span>();
<span class="hljs-title">myObject</span>.<span class="hljs-title">MyInstanceMethod</span>();</span>
</code></pre>
<p>Instance methods can access the class&#39;s <code>static</code> and <code>non-static</code> members since they belong to a specific class instance.</p>
<p>Static members can also include <code>fields</code>, <code>properties</code>, <code>events</code>, <code>operators</code>, and <code>constructors</code>.</p>
<h3 id="exceptions">Exceptions</h3>
<p>Exception handling in C# is a robust mechanism used to handle runtime errors so that the normal flow of the application can be maintained. C# provides a structured solution to error handling through try-and-catch blocks. Using these blocks, we can isolate code that may throw an exception and enable the program to respond rather than letting the program crash.</p>
<h4 id="try-catch-finally">try catch finally</h4>
<p>A <code>try</code> block is used to encapsulate a region of code. If any statement within the try block throws an exception, that exception will be handled by the associated catch block.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">try</span>
{
    <span class="hljs-comment">// Code that could potentially throw an exception.</span>
}
</code></pre>
<p>The <code>catch</code> block is used to catch and handle an exception. It follows a try block or another catch block. Each try block can have multiple catch blocks associated with it, each designed to handle specific or multiple exceptions. A <code>catch</code> block without a specified type will catch all exceptions.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">catch</span> (<span class="hljs-keyword">Exception</span> ex)
{
    <span class="hljs-comment">// Handle the exception</span>
}
</code></pre>
<p>A <code>finally</code> block lets you execute code after a try block has been completed, regardless of whether an exception has been thrown. It is optional and cleans up resources inside the try block (like database connections, files, or network resources).</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">finally</span>
{
    <span class="hljs-comment">// Code to be executed after the try block has completed,</span>
    <span class="hljs-comment">// regardless of whether an exception was thrown.</span>
}
</code></pre>
<p>Here&#39;s an example of try, catch, and finally all used together:</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">try</span>
{
    <span class="hljs-comment">// Code that could potentially throw an exception.</span>
    <span class="hljs-keyword">int</span> divisor = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">10</span> / divisor;
}
<span class="hljs-built_in">catch</span> (DivideByZeroException ex)
{
    <span class="hljs-comment">// Handle the DivideByZeroException.</span>
    <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"Cannot divide by zero"</span>);
}
finally
{
    <span class="hljs-comment">// Code to be executed after the try block has completed,</span>
    <span class="hljs-comment">// regardless of whether an exception was thrown.</span>
    <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"This code is always executed."</span>);
}
</code></pre>
<p>When dealing with <code>catch blocks</code>, remember that they can handle multiple exception exceptions. The order in which you specify different catch blocks matters; they&#39;re examined top to bottom, so the first one that matches the exception type will be executed. If you have a catch block that handles all exceptions at the top, it will catch all exceptions, and none of the catch blocks below it will execute. This is why the catch block for the most general exception type, <code>Exception</code>, is usually last.</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">try</span>
{
    <span class="hljs-comment">// Code that could throw an exception</span>
    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>];
    arr[<span class="hljs-number">10</span>] = <span class="hljs-number">30</span>; <span class="hljs-comment">// This line throws an IndexOutOfRangeException.</span>
}
<span class="hljs-built_in">catch</span> (IndexOutOfRangeException ex)
{
    <span class="hljs-comment">// Handle specific exception first</span>
    <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"An IndexOutOfRangeException has been caught: "</span> + ex.Message);
}
<span class="hljs-built_in">catch</span> (Exception ex)
{
    <span class="hljs-comment">// General exception catch block</span>
    <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"An exception has been caught: "</span> + ex.Message);
}
</code></pre>
<p>The <code>finally</code> block is executed regardless of whether an exception is thrown. If you have any code that must execute, whether an exception is thrown or not, it should be placed in a finally block. For example, if you open a file in a try block, you should close it in a finally block, whether or not an exception is thrown when working with the file.</p>
<pre><code class="lang-csharp">StreamReader reader = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">try</span>
{
    reader = <span class="hljs-keyword">new</span> StreamReader(<span class="hljs-string">"file.txt"</span>);
    <span class="hljs-comment">// Code to read the file.</span>
}
<span class="hljs-keyword">catch</span> (FileNotFoundException ex)
{
    Console.<span class="hljs-keyword">WriteLine</span>(ex.Message);
}
<span class="hljs-keyword">finally</span>
{
    <span class="hljs-comment">// Whether an exception is thrown or not, close the file.</span>
    <span class="hljs-keyword">if</span> (reader != <span class="hljs-keyword">null</span>)
        reader.Close();
}
</code></pre>
<h4 id="throw">throw</h4>
<p>The <code>throw</code> keyword can be used to raise exceptions. You can throw a pre-existing exception, or you can instantiate a new exception and throw it.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">try</span>
{
    <span class="hljs-comment">// Throw a new exception.</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">Exception</span>(<span class="hljs-string">"A problem has occurred."</span>);
}
<span class="hljs-keyword">catch</span> (<span class="hljs-keyword">Exception</span> ex)
{
    <span class="hljs-comment">// Handle the exception.</span>
    Console.WriteLine(ex.Message);
}
</code></pre>
<h2 id="lambda-expressions">Lambda Expressions</h2>
<hr>
<p>A lambda expression is a method without a name that calculates and returns a single value. They are simple methods to represent <code>anonymous methods</code> (methods without a name) or <code>functions</code> inline.</p>
<p>A lambda expression consists of three main parts: a <code>parameter list</code>, the <code>lambda operator</code> (<code>=&gt;</code>), and an <code>expression or statement</code>. The general syntax for a lambda expression looks something like this:</p>
<pre><code class="lang-csharp">(<span class="hljs-keyword">parameters</span>) =&gt; expression <span class="hljs-comment">or statement block</span>
</code></pre>
<ul>
<li>The <code>parameters</code> represent the input values to the lambda expression. They can be zero or more, separated by commas. If there is only one parameter, parentheses are optional. For multiple parameters, parentheses are required.</li>
<li>The <code>lambda Operator (=&gt;)</code> separates the parameter list from the body of the expression. It denotes a relationship between the parameters and the code to execute.</li>
<li>The <code>expression or statement block</code> represents the code that is executed when the lambda expression is invoked. For a single expression, the result is implicitly returned. A statement block is enclosed in curly braces <code>{}</code> for multiple statements.</li>
</ul>
<p>Consider the example given in the <code>LINQ</code> section.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">var</span> evenNumbers = numbers.Where(<span class="hljs-built_in">num</span> =&gt; <span class="hljs-built_in">num</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// Output: 2, 4, 6, 8, 10</span>
</code></pre>
<p>The lambda expression <code>num =&gt; num % 2 == 0</code> specifies the condition for the <code>Where</code> method to filter the numbers. Here, <code>num</code> is the input parameter, and the condition to the right of the lambda operator is the statement block. This condition is applied to each element of the numbers list.</p>
<p>In plain English, this lambda expression reads, &quot;For each number (num) in numbers, keep it if the remainder when num is divided by 2 equals 0.&quot; The % operator is the modulus operator, which gives the remainder of a division operation. Therefore, <code>num % 2 == 0</code> checks if a number is evenly divisible by 2, i.e., it&#39;s an even number.</p>
<h3 id="simple-lambda-expression">Simple Lambda Expression</h3>
<p>Consider the following method.</p>
<pre><code class="lang-csharp"><span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">Greet</span>()
{
    <span class="hljs-selector-tag">Console</span><span class="hljs-selector-class">.WriteLine</span>(<span class="hljs-string">"Hello, world!"</span>);
}

<span class="hljs-comment">// Invoke the method</span>
<span class="hljs-selector-tag">Greet</span>(); <span class="hljs-comment">// Output: Hello, world!</span>
</code></pre>
<p>In this example, we merely define a method that prints a message to the console when invoked. However, we can further simplify this code using a lambda function, which essentially condenses it into a single line.</p>
<pre><code class="lang-csharp"><span class="hljs-comment">// Lambda expression without parameters</span>
<span class="hljs-keyword">var</span> greet = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> Console.WriteLine(<span class="hljs-string">"Hello, world!"</span>);
greet(); <span class="hljs-comment">// Output: Hello, world!</span>
</code></pre>
<p>In this instance, we&#39;ve defined a lambda expression without any parameters. The lambda expression assigns a function to the variable <code>greet</code>, which prints &quot;Hello, world!&quot; to the console upon invocation.</p>
<p>While both achieve the same outcome, the lambda expression is far more succinct and can be employed as an inline function where required, contrasted with the method definition that necessitates a separate declaration.</p>
<h3 id="lambda-expression-with-parameters">Lambda Expression with Parameters</h3>
<p>A <code>Lambda Expression with Parameters</code> is a type of lambda expression in C# that takes one or more input parameters. This type of lambda expression is typically used when you want to perform an operation or evaluate a condition using the input parameters.</p>
<pre><code class="lang-csharp"><span class="hljs-comment">// Regular method</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b</span>)
</span>{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// Lambda expression with parameters</span>
<span class="hljs-keyword">var</span> <span class="hljs-keyword">add</span> = (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) =&gt; a + b;
<span class="hljs-keyword">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);
Console.WriteLine(result); <span class="hljs-comment">// Output: 8</span>
</code></pre>
<p>Here, we define a lambda expression with two parameters <code>a</code> and <code>b</code>, which adds the values of <code>a</code> and <code>b</code>. The lambda expression is assigned to the variable <code>add</code>, and we invoke it with arguments <code>5</code> and <code>3</code>, resulting in the sum <code>8</code> being assigned to the variable <code>result</code>.</p>
<h3 id="lambda-expression-with-statement-block">Lambda Expression with Statement Block</h3>
<p>A <code>Lambda Expression with a Statement Block</code>, often called a <code>Statement Lambda</code>, is a type of lambda expression in C# that contains a block of code instead of a single expression on the right side of the lambda operator (<code>=&gt;</code>).</p>
<pre><code class="lang-csharp"><span class="hljs-comment">// Regular method</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEven</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> number</span>)
</span>{
    <span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-comment">// Lambda expression with statement block</span>
<span class="hljs-keyword">var</span> isEven = (<span class="hljs-keyword">int</span> number) =&gt;
{
    <span class="hljs-keyword">if</span> (number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};

<span class="hljs-keyword">bool</span> even = isEven(<span class="hljs-number">6</span>);
Console.WriteLine(even); <span class="hljs-comment">// Output: True</span>
</code></pre>
<p>In this example, we define a lambda expression with a parameter <code>number</code> and a statement block enclosed in curly braces. The lambda expression checks if the <code>number</code> is even and returns <code>true</code> or <code>false</code> accordingly. We assign the result of invoking the lambda expression with <code>6</code> to the variable <code>even</code>, which evaluates to <code>true</code>.</p>
<h2 id="libraries">Libraries</h2>
<hr>
<p>C# includes many predefined functions and libraries that developers can use to accomplish various tasks more easily and efficiently. The .NET Framework provides these libraries and includes functionalities for things like file I/O, database access, networking, and much more.</p>
<p>A library in C# is typically provided as a <code>.dll</code> (Dynamic Link Library) file. To use the library&#39;s functions and classes, you must first reference it in your project. This will be done automatically if the library is installed via a package manager like nuget, or if you use a library from within the .NET ecosystem.</p>
<p>The <code>using</code> directive then tells the compiler to use a specific namespace in the library. A <code>namespace</code> groups related class, structures, and other types under a single name. For instance, the <code>System</code> namespace includes fundamental classes and base types that are used in C# programming.</p>
<p>For example, to use the <code>File</code> class from the <code>System.IO</code> namespace for handling files, you would first need to add <code>using System.IO;</code> at the top of your code.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">using</span> System.IO;

<span class="hljs-keyword">class</span> Program
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Main(<span class="hljs-keyword">string</span>[] args)
    {
        <span class="hljs-comment">// Check if a file exists</span>
        <span class="hljs-built_in">if</span> (<span class="hljs-built_in">File</span>.Exists(<span class="hljs-string">"test.txt"</span>))
        {
            <span class="hljs-comment">// Read the content of the file</span>
            <span class="hljs-keyword">string</span> content = <span class="hljs-built_in">File</span>.ReadAllText(<span class="hljs-string">"test.txt"</span>);
            <span class="hljs-built_in">Console</span>.WriteLine(content);
        }
        <span class="hljs-built_in">else</span>
        {
            <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"The file does not exist."</span>);
        }
    }
}
</code></pre>
<p>In this example, <code>File.Exists</code> is a predefined function from the <code>System.IO</code> namespace that checks if a file exists at the provided path and <code>File.ReadAllText</code> is another predefined function that reads the entire content of the file as a string. Because <code>System</code> is a core library, the compiler will automatically include it.</p>
<p>Similarly, you can use predefined functions from other namespaces and libraries—for instance, the <code>System.Math</code> namespace contains mathematical functions such as <code>Math.Sqrt</code> for computing the square root of a number, <code>Math.Pow</code> for raising a number to a specified power, and <code>Math.Round</code> for rounding a number to the nearest integer.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">using</span> System;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)
    </span>{
        <span class="hljs-keyword">double</span> num = <span class="hljs-number">9.0</span>;
        <span class="hljs-keyword">double</span> squareRoot = Math.Sqrt(num);
        Console.WriteLine(<span class="hljs-string">$"The square root of <span class="hljs-subst">{num}</span> is <span class="hljs-subst">{squareRoot}</span>"</span>);

        <span class="hljs-keyword">double</span> baseNum = <span class="hljs-number">2.0</span>;
        <span class="hljs-keyword">double</span> exponent = <span class="hljs-number">3.0</span>;
        <span class="hljs-keyword">double</span> power = Math.Pow(baseNum, exponent);
        Console.WriteLine(<span class="hljs-string">$"<span class="hljs-subst">{baseNum}</span> raised to the power of <span class="hljs-subst">{exponent}</span> is <span class="hljs-subst">{power}</span>"</span>);

        <span class="hljs-keyword">double</span> toBeRounded = <span class="hljs-number">9.5</span>;
        <span class="hljs-keyword">double</span> rounded = Math.Round(toBeRounded);
        Console.WriteLine(<span class="hljs-string">$"<span class="hljs-subst">{toBeRounded}</span> rounded to the nearest integer is <span class="hljs-subst">{rounded}</span>"</span>);
    }
}
</code></pre>
<p>As you can see, leveraging the predefined functions and libraries provided by the .NET Framework can achieve complex functionality with less code.</p>
<h3 id="nuget">NuGet</h3>
<p>In addition to the standard libraries, C# offers extensive support for using third-party libraries and packages. These can be added to your project through various means, including the <a href="https://www.nuget.org/">NuGet package manager</a>. <code>NuGet</code> is a free and open-source package manager designed for the Microsoft development platform, and it hosts thousands of libraries.</p>
<p>Adding a <code>NuGet</code> package to your project can be as easy as right-clicking on your project in the Solution Explorer in Visual Studio, selecting &quot;<code>Manage NuGet Packages...</code>&quot; and then searching for and installing the required package. If using a code editor, we use the <code>dotnet package add</code> command, but <a href="https://learn.microsoft.com/en-za/nuget/consume-packages/install-use-packages-dotnet-cli">Microsoft provides great documentation for using nuget from the CLI</a>.</p>
<p>Once a package is installed, you can utilise its functionality in your code by adding the appropriate <code>using</code> directive at the top of your file. The <code>Newtonsoft.Json</code> package, for instance, provides powerful tools for working with JSON data.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">using</span> Newtonsoft.Json;
<span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Collections.Generic;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)
    </span>{
        <span class="hljs-keyword">string</span> json = <span class="hljs-string">"[{'Name':'John', 'Age':30}, {'Name':'Jane', 'Age':28}]"</span>;

        List&lt;Person&gt; people = JsonConvert.DeserializeObject&lt;List&lt;Person&gt;&gt;(json);

        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> person <span class="hljs-keyword">in</span> people)
        {
            Console.WriteLine(<span class="hljs-string">$"Name: <span class="hljs-subst">{person.Name}</span>, Age: <span class="hljs-subst">{person.Age}</span>"</span>);
        }
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Age { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>In this example, the <code>JsonConvert.DeserializeObject&lt;T&gt;</code> method is used to parse the JSON string into a list of <code>Person</code> objects. This predefined function, part of the <code>Newtonsoft.Json</code> library, dramatically simplifies the task of JSON parsing.</p>
<h3 id="manual-referencing">Manual Referencing</h3>
<p>It is also possible to manually link a library to the project. If you use an IDE such as Visual Studio, or Jetbrains Rider, it&#39;s as simple as right-clicking on the <code>Project Dependencies</code> section under the solution explorer and selecting the <code>Add Project Reference...</code> option, and then finding the library you want to link.</p>
<p>Alternatively, if you are using a Code editor, such as VSCode, you will need to manually edit the project file to include the references, such as the example below, which is going to reference every <code>.dll</code> file in the libs subfolder:</p>
<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Project</span> <span class="hljs-attr">Sdk</span>=<span class="hljs-string">"Microsoft.NET.Sdk"</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">PropertyGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">TargetFramework</span>&gt;</span>net7.0<span class="hljs-tag">&lt;/<span class="hljs-name">TargetFramework</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ImplicitUsings</span>&gt;</span>enable<span class="hljs-tag">&lt;/<span class="hljs-name">ImplicitUsings</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Nullable</span>&gt;</span>enable<span class="hljs-tag">&lt;/<span class="hljs-name">Nullable</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">AllowUnsafeBlocks</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">AllowUnsafeBlocks</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">PropertyGroup</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ItemGroup</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- references look like this --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Reference</span> <span class="hljs-attr">Include</span>=<span class="hljs-string">"libs\*.dll"</span> /&gt;</span> 
  <span class="hljs-tag">&lt;/<span class="hljs-name">ItemGroup</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">Project</span>&gt;</span>
</code></pre>
<p>It&#39;s also possible to hardcode paths and establish multiple <code>Reference</code> definitions for each individualreference specifically.</p>
<p>To identify the <code>namespaces</code>, <code>types</code>, <code>classes</code>, and <code>methods</code> provided by the library, it is generally considered best practice to consult the provided documentation. Both Visual Studio and Visual Studio Code will provide code auto-complete functionality for the functionality from imported libraries through their IntelliSense auto-complete tool.</p>
<p>While the .NET Framework and third-party libraries offer a wide array of predefined functions, it&#39;s essential to understand their usage and potential impact on your application. Some libraries may have licensing restrictions, or they may not be maintained actively. Always research before including a third-party library in your project.</p>
<h2 id="object-oriented-programming">Object-Oriented Programming</h2>
<hr>
<p>Object-Oriented Programming (OOP) is a programming paradigm that relies on the concept of &quot;objects&quot;. Objects are instances of classes, which can contain data in the form of fields, often known as attributes, and code, in the form of methods. In OOP, computer programs are designed by making them out of objects that interact with one another.</p>
<p>There are four main principles of Object-Oriented Programming:</p>
<ol>
<li><code>Encapsulation</code> is the practice of keeping fields within a class private and providing access to them via public methods. It&#39;s a protective barrier that keeps the data and implementation code bundled together within an object.</li>
<li><code>Inheritance</code> is a process by which one class can acquire the properties (methods and fields) of another. With the use of inheritance, information is made manageable in a hierarchical order.</li>
<li><code>Polymorphism</code> enables methods to be used as if they were the methods of a class&#39;s parent. It&#39;s the characteristic of an operation to behave differently based on the types of objects or arguments involved.</li>
<li><code>Abstraction</code> represents essential features without including background details or explanations. It provides a simple interface and reduces complexity by hiding unnecessary details.</li>
</ol>
<h3 id="classes-structs">Classes &amp; Structs</h3>
<p>In C#, a <code>class</code> is a blueprint for creating objects, and an object is an instance of a class. Class definitions start with the keyword <code>class</code> followed by the name of the class and typically encapsulate data and methods that operate on that data.</p>
<p>Classes are made up of two fundamental elements: <code>Properties</code> and <code>Methods</code>.</p>
<ul>
<li><code>Properties</code> represent data about the class. They are often referred to as attributes or characteristics. For example, in a <code>Car</code> class, properties might include <code>Color</code>, <code>Model</code>, and <code>Year</code>.</li>
<li><code>Methods</code> represent actions or behaviour associated with the class. They are functions defined within a class. For instance, a <code>Car</code> class may have methods like <code>Drive()</code>, <code>Park()</code>, and <code>Brake()</code>.</li>
</ul>
<pre><code class="lang-csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>
{
    <span class="hljs-comment">// Properties</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Color;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Year;

    <span class="hljs-comment">// Method</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Drive</span>(<span class="hljs-params"></span>)
    </span>{
        Console.WriteLine(<span class="hljs-string">$"The <span class="hljs-subst">{Color}</span> car from <span class="hljs-subst">{Year}</span> is driving."</span>);
    }
}
</code></pre>
<p>In the above example, <code>Car</code> is a class that contains two properties (<code>Color</code> and <code>Year</code>) and one method (<code>Drive</code>).</p>
<p>To create an object in C#, you use the <code>new</code> keyword followed by the class name. This process is often called <code>instantiation</code> because you create an &quot;instance&quot; of a class.</p>
<pre><code class="lang-csharp"><span class="hljs-attribute">Car myCar</span> = new Car();
</code></pre>
<p>In this line, <code>myCar</code> is an object of the <code>Car</code> class. You can now use the dot operator <code>.</code> to access its properties and methods:</p>
<pre><code class="lang-csharp">myCar.Color = <span class="hljs-string">"Red"</span>;
myCar.Year = <span class="hljs-number">2020</span>;
myCar.Drive<span class="hljs-comment">()</span>;
<span class="hljs-comment">// output: The Red car from 2020 is driving.</span>
</code></pre>
<p>Remember that each object has its own copy of properties. Thus, if you create another <code>Car</code> object, it will have its own <code>Color</code> and <code>Year</code>:</p>
<pre><code class="lang-csharp">Car anotherCar = <span class="hljs-keyword">new</span> <span class="hljs-type">Car</span>();
anotherCar.Color = <span class="hljs-string">"Blue"</span>;
anotherCar.Year = <span class="hljs-number">2021</span>;
<span class="hljs-comment">//output: The Blue car from 2021 is driving.</span>
</code></pre>
<p>So even though <code>myCar</code> and <code>anotherCar</code> are both instances of the <code>Car</code> class, they have different property values. This allows objects to have unique states while sharing common behaviour from their respective classes.</p>
<p>Classes can also have a <code>constructor</code>, which is a special method in a class or struct that is automatically called when an object of that class or struct is created. The primary purpose of a constructor is to initialise the object and its data members.</p>
<p>The constructor has the same name as the class or struct, and it doesn&#39;t have any return type, not even void. It can take parameters if needed.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>
{
    <span class="hljs-comment">// Properties</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Color;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Year;

    <span class="hljs-comment">// Constructor</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> c, <span class="hljs-keyword">int</span> y</span>)
    </span>{
        Color = c;
        Year = y;
    }

    <span class="hljs-comment">// Method</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Drive</span>(<span class="hljs-params"></span>)
    </span>{
        Console.WriteLine(<span class="hljs-string">$"The <span class="hljs-subst">{Color}</span> car from <span class="hljs-subst">{Year}</span> is driving."</span>);
    }
}
</code></pre>
<p>You can then pass the parameters when the object is instantiated to set the variables.</p>
<pre><code class="lang-csharp">Car myNewCar = <span class="hljs-keyword">new</span> <span class="hljs-type">Car</span>(<span class="hljs-string">"Pink"</span>, <span class="hljs-number">2022</span>);
myNewCar.Drive();
<span class="hljs-comment">// output: The Pink car from 2022 is driving.</span>
</code></pre>
<h4 id="accessors">Accessors</h4>
<p>An <code>accessor</code> is a class member function that provides access to the value of private or protected data members. There are two types of accessors - <code>get</code> and <code>set</code>.</p>
<p>The <code>get</code> accessor is used to return the property value. It provides read-only access to the attribute it is assigned to. If only a <code>get</code> accessor is specified, the property becomes read-only.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> Radius
    {
        <span class="hljs-keyword">get</span>
        {
            <span class="hljs-keyword">return</span> radius;
        }
    }
}
</code></pre>
<p>In this example, the <code>Radius</code> property has only a <code>get</code> accessor, making it read-only. Trying to set its value will result in a compile-time error.</p>
<p>The <code>set</code> accessor is used to set the property <code>value</code>. It provides write-only access to the attribute it is assigned to. If only a <code>set</code> accessor is specified, the property becomes write-only.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> Radius
    {
        <span class="hljs-keyword">set</span>
        {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &gt; <span class="hljs-number">0</span>)
                radius = <span class="hljs-keyword">value</span>;
            <span class="hljs-keyword">else</span>
                Console.WriteLine(<span class="hljs-string">"Radius cannot be negative or zero"</span>);
        }
    }
}
</code></pre>
<p>In this example, the <code>Radius</code> property has only a <code>set</code> accessor. Its value can be set but not directly retrieved. The <code>value</code> keyword in C# is a special keyword that is used in the <code>set</code> accessor of a property or indexer. It represents the new value the code attempts to assign to the property.</p>
<p>Most commonly, you&#39;ll see both <code>get</code> and <code>set</code> accessors used together. This allows for both reading and writing the property value.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> Radius
    {
        <span class="hljs-keyword">get</span>
        {
            <span class="hljs-keyword">return</span> radius;
        }
        <span class="hljs-keyword">set</span>
        {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &gt; <span class="hljs-number">0</span>)
                radius = <span class="hljs-keyword">value</span>;
            <span class="hljs-keyword">else</span>
                Console.WriteLine(<span class="hljs-string">"Radius cannot be negative or zero"</span>);
        }
    }
}
</code></pre>
<h4 id="automatic-properties">Automatic Properties</h4>
<p>In C#, an automatic property, also known as auto-implemented property, allows you to define a class property in a concise way without explicitly declaring a backing field. A backing field is a private variable used to store a property’s data.</p>
<p>For example, consider a <code>full property</code> with a declared backing field:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> Radius
    {
        <span class="hljs-keyword">get</span>
        {
            <span class="hljs-keyword">return</span> radius;
        }
        <span class="hljs-keyword">set</span>
        {
            radius = <span class="hljs-keyword">value</span>;
        }
    }
}
</code></pre>
<p>Whereas an automatic property will automatically declare the backing field:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> Radius { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</code></pre>
<p>In this example, <code>Radius</code> is an automatic property. The <code>{ get; set; }</code> syntax tells C# to generate a hidden backing field behind the scenes automatically. This field stores the actual data, and the <code>get</code> and <code>set</code> accessors are used to read from and write to this field.</p>
<p>Functionally both properties are identical.</p>
<pre><code class="lang-csharp"><span class="hljs-type">Circle</span> c = <span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">Circle</span>();
<span class="hljs-title">c</span>.<span class="hljs-title">Radius</span> = 12345.54321;

<span class="hljs-title">Console</span>.<span class="hljs-title">WriteLine</span>(c.<span class="hljs-type">Radius</span>);  <span class="hljs-comment">// Outputs: 12345.54321</span></span>
</code></pre>
<p>Automatic properties provide a shorter and more readable way to create properties, helping keep your code clean and efficient.</p>
<h4 id="structs">Structs</h4>
<p>A <code>struct</code>, short for structure, is a value type in C#. This means when a <code>struct</code> is created, the variable to which the struct is assigned holds the struct&#39;s actual data. This contrasts with reference types, where the variable references the object&#39;s data, not the actual data itself.</p>
<p>Structs are useful for small data structures that have value semantics. They can contain fields, methods, and constructors just like classes, but there are some differences:</p>
<ul>
<li>Structs do not support inheritance, while classes do. However, both structs and classes can implement interfaces.</li>
<li>Structs are instantiated without using the <code>new</code> keyword, and their constructors are called automatically.</li>
<li>A struct cannot be <code>null</code>, as it&#39;s a value type. A class can be <code>null</code> because it&#39;s a reference type.</li>
</ul>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Point
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> X { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Y { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y</span>)
    </span>{
        X = x;
        Y = y;
    }
}
</code></pre>
<p>In this example, <code>Point</code> is a struct that represents a point in two-dimensional space. It includes two properties (<code>X</code> and <code>Y</code>) and a constructor that initialises those properties.</p>
<h3 id="encapsulation">Encapsulation</h3>
<p>Encapsulation is one of the four fundamental principles of Object-Oriented Programming (OOP). It is often described as the bundling of data and the methods that operate on that data into a single unit known as a class. It serves as a protective shield that prevents the data from being accessed directly by outside code, hence enforcing data integrity and ensuring security.</p>
<p>In C#, data encapsulation is achieved through access modifiers, which control the visibility and accessibility of classes, methods, and other members. The key access modifiers are <code>public</code>, <code>private</code>, <code>protected</code>, and <code>internal</code>.</p>
<ul>
<li>A <code>public</code> member is accessible from any code in the program.</li>
<li>A <code>private</code> member is only accessible within its own class. This is the most restrictive level of access.</li>
<li>A <code>protected</code> member is accessible within its own class and by derived class instances.</li>
<li>An <code>internal</code> member is accessible only within files in the same assembly.</li>
</ul>
<p>The convention in C# is to make data members <code>private</code> to hide them from other classes (this is known as data hiding). Then, <code>public</code> methods known as getters and setters (or, more commonly, properties) are provided to get and set the values of the private fields. These methods serve as the interface to the outside world and protect the data from incorrect or inappropriate manipulation.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>
{
    <span class="hljs-comment">// Private member data (fields)</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">string</span> name;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;

    <span class="hljs-comment">// Public getter and setter methods (properties)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name
    {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> name; }
        <span class="hljs-keyword">set</span> { name = <span class="hljs-keyword">value</span>; }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Age
    {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> age; }
        <span class="hljs-keyword">set</span> 
        { 
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">value</span> &gt; <span class="hljs-number">0</span>)
                age = <span class="hljs-keyword">value</span>; 
            <span class="hljs-keyword">else</span> 
                Console.WriteLine(<span class="hljs-string">"Invalid age value"</span>);
        }
    }
}
</code></pre>
<p>In this example, the <code>Employee</code> class encapsulates the <code>name</code> and <code>age</code> fields. These fields are <code>private</code>, so they cannot be accessed directly from outside the <code>Employee</code> class. Instead, access is provided through the <code>public</code> properties <code>Name</code> and <code>Age</code>, which serve as the interface to the <code>Employee</code> class. Notice that the <code>Age</code> setter includes validation logic to ensure an invalid age cannot be set. This is an excellent example of encapsulation protecting the data in an object. The data (in this case, the <code>age</code>) is safeguarded and encapsulated within the <code>Employee</code> class.</p>
<h3 id="inheritance">Inheritance</h3>
<p>Inheritance is a fundamental principle of Object-Oriented Programming (OOP) that allows for the creation of hierarchical classifications of objects. It offers a mechanism where a new class can inherit members (fields, methods, etc.) of an existing class, thereby promoting code reusability and logical classification.</p>
<p>There are two types of inheritance: single inheritance and multilevel inheritance.</p>
<h4 id="single-inheritance">Single Inheritance</h4>
<p>In single inheritance, a class (aka a derived or child class) inherits from a single-parent class (also known as a base or superclass). This allows the derived class to reuse (or inherit) the fields and methods of the base class, as well as to introduce new ones.</p>
<p>Consider an example where we have a base class, <code>Vehicle</code>, and a derived class, <code>Car</code>.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> color;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>) </span>{
        Console.WriteLine(<span class="hljs-string">"Vehicle started"</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> : <span class="hljs-title">Vehicle</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> model;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Drive</span>(<span class="hljs-params"></span>) </span>{
        Console.WriteLine(<span class="hljs-string">"Driving car"</span>);
    }
}
</code></pre>
<p><code>Car</code> is a derived class that inherits from the <code>Vehicle</code> base class. It inherits the <code>color</code> field and the <code>Start()</code> method from <code>Vehicle</code> and also defines an additional field <code>model</code> and a method <code>Drive()</code>.</p>
<h4 id="multilevel-inheritance">Multilevel Inheritance</h4>
<p>Multilevel inheritance is a scenario where a derived class inherits from another. This creates a &quot;chain&quot; of inheritance where a class can inherit members from multiple levels up its inheritance hierarchy.</p>
<p>Let&#39;s extend the previous example to include a <code>SportsCar</code> class inherited from <code>Car</code>.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SportsCar</span> : <span class="hljs-title">Car</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> topSpeed;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TurboBoost</span>(<span class="hljs-params"></span>) </span>{
        Console.WriteLine(<span class="hljs-string">"Turbo boost activated"</span>);
    }
}
</code></pre>
<p>In this case, <code>SportsCar</code> is a derived class that inherits from the <code>Car</code> class, which in turn inherits from the <code>Vehicle</code> class. This means that <code>SportsCar</code> has access to the <code>color</code> field and <code>Start()</code> method from <code>Vehicle</code>, the <code>model</code> field and <code>Drive()</code> method from <code>Car</code>, and also defines its own field <code>topSpeed</code> and method <code>TurboBoost()</code>.</p>
<p>Remember that C# doesn&#39;t support multiple inheritance, meaning a class cannot directly inherit from more than one class at the same level. However, as we&#39;ve seen here, it supports multiple levels of inheritance and allows a class to implement multiple interfaces.</p>
<h4 id="base">base</h4>
<p>In C#, the <code>base</code> keyword is used to access base class members from within a derived class. This can include methods, properties, and fields of the base class. Furthermore, the <code>base</code> keyword is most commonly employed within the derived class&#39;s constructor to call the base class’s constructor.</p>
<p>To delve deeper, let&#39;s examine the use of the <code>base</code> keyword in a few examples. Consider a base-class <code>Vehicle</code> and a derived-class <code>Car</code>.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Color { <span class="hljs-keyword">get</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vehicle</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> color</span>)
    </span>{
        <span class="hljs-keyword">this</span>.Color = color;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayColor</span>(<span class="hljs-params"></span>)
    </span>{
        Console.WriteLine(<span class="hljs-string">$"Color: <span class="hljs-subst">{<span class="hljs-keyword">this</span>.Color}</span>"</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> : <span class="hljs-title">Vehicle</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Brand { <span class="hljs-keyword">get</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> color, <span class="hljs-keyword">string</span> brand</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">color</span>)
    </span>{
        <span class="hljs-keyword">this</span>.Brand = brand;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayCarInformation</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword">base</span>.DisplayColor();
        Console.WriteLine(<span class="hljs-string">$"Brand: <span class="hljs-subst">{<span class="hljs-keyword">this</span>.Brand}</span>"</span>);
    }
}
</code></pre>
<p>In the derived class <code>Car</code>, the <code>base</code> keyword is used in two distinct ways:</p>
<ol>
<li><code>Constructor</code>: Within the constructor of <code>Car</code>, <code>base(color)</code> is used to call the constructor of the base class <code>Vehicle</code>. Here, <code>base</code> allows <code>Car</code> to initialise the <code>Color</code> property defined in <code>Vehicle</code>.</li>
<li><code>Methods</code>: Within the <code>DisplayCarInformation</code> method of <code>Car</code>, <code>base.DisplayColor()</code> is used to call the <code>DisplayColor</code> method from the base class <code>Vehicle</code>.</li>
</ol>
<p>The <code>base</code> keyword hence provides an effective way to interact with the base class and utilise its members, enabling the principles of reuse and abstraction that are foundational to object-oriented programming. This leads to more manageable, scalable, and organised code.</p>
<h2 id="polymorphism-and-abstraction">Polymorphism and Abstraction</h2>
<hr>
<h3 id="polymorphism">Polymorphism</h3>
<p>Polymorphism is one of the four fundamental principles of Object-Oriented Programming (OOP), alongside Encapsulation, Inheritance, and Abstraction. The term originates from the Greek words &quot;poly,&quot; meaning many, and &quot;morph,&quot; meaning forms. Thus, polymorphism is the ability of an entity to take on many forms.</p>
<p>In C#, polymorphism is generally realised through method overloading and overriding.</p>
<h4 id="method-overloading">Method Overloading</h4>
<p>Method overloading, also known as static or compile-time polymorphism, is a technique that allows multiple methods with the same name but different parameters (in terms of number, type, or order) to coexist within a class.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Mathematics</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b</span>)
    </span>{
        <span class="hljs-keyword">return</span> a + b;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b</span>)
    </span>{
        <span class="hljs-keyword">return</span> a + b;
    }
}
</code></pre>
<p>In the above class <code>Mathematics</code>, the method <code>Add</code> is overloaded: one version of the <code>Add</code> method accepts two integers, while the other accepts two doubles. The correct version of the method is selected at compile time-based on the arguments supplied.</p>
<h4 id="method-overriding">Method Overriding</h4>
<p>Method overriding, on the other hand, is a form of dynamic or run-time polymorphism. It allows a derived class to provide a different implementation for a method already defined in its base class or one of its base classes. The method in the base class must be marked with the <code>virtual</code> keyword, and the method in the derived class must use the <code>override</code> keyword.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>(<span class="hljs-params"></span>)
    </span>{
        Console.WriteLine(<span class="hljs-string">"The animal makes a sound"</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>(<span class="hljs-params"></span>)
    </span>{
        Console.WriteLine(<span class="hljs-string">"The dog barks"</span>);
    }
}
</code></pre>
<p>In the above example, the <code>Dog</code> class overrides the <code>MakeSound</code> method of the <code>Animal</code> class. When <code>MakeSound</code> is called on an object of type <code>Dog</code>, the overridden version in the <code>Dog</code> class is executed.</p>
<p>The concepts of overloading and overriding extend to operators and properties, adding flexibility and expressiveness to C# programming.</p>
<h4 id="operator-overloading">Operator Overloading</h4>
<p>Just like methods, C# allows operators to be overloaded. This enables custom types to be manipulated using standard operators, enhancing code readability and intuitiveness. For example, for a <code>Vector</code> class representing a mathematical vector, you might overload the &#39;+&#39; operator to perform vector addition:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> X { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> Y { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Vector</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y</span>)
    </span>{
        X = x;
        Y = y;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector <span class="hljs-keyword">operator</span> +(Vector v1, Vector v2)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector(v1.X + v2.X, v1.Y + v2.Y);
    }
}
</code></pre>
<p>In this example, instances of <code>Vector</code> can be added using the <code>+</code> operator, just like primitive types:</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">Vector</span> v1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Vector</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-built_in">Vector</span> v2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Vector</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-built_in">Vector</span> sum = v1 + v2;  <span class="hljs-comment">// { X = 4, Y = 6 }</span>
</code></pre>
<h4 id="property-overriding">Property Overriding</h4>
<p>In C#, properties, like methods, can be overridden in derived classes. A base class declares a virtual property, and derived classes can override this property to change its behaviour.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> name</span>)
    </span>{
        Name = name;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> name</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">name</span>) </span>{ }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">string</span> Name
    {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.Name; }
        <span class="hljs-keyword">set</span> { <span class="hljs-keyword">base</span>.Name = <span class="hljs-keyword">value</span> + <span class="hljs-string">" the dog"</span>; }
    }
}
</code></pre>
<p>In this case, a <code>Dog</code> object modifies the behaviour of the <code>Name</code> property to append &quot; the dog&quot; to any name assigned to it:</p>
<pre><code class="lang-csharp">Dog myDog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">"Rex"</span>);
<span class="hljs-built_in">Console</span>.WriteLine(myDog.Name);  <span class="hljs-comment">// "Rex the dog"</span>
</code></pre>
<p>These examples underline the power of polymorphism in C# and object-oriented programming. It allows classes to provide tailored implementations of methods, operators, and properties, enabling more natural, expressive, and aligned code with the problem domain.</p>
<h3 id="abstraction">Abstraction</h3>
<p>In object-oriented programming, abstraction is the concept of simplifying complex reality by modelling classes appropriate to the problem and working at the most appropriate level of inheritance for a given aspect of the problem. It is a mechanism that represents the essential features without including the background details.</p>
<p>Abstraction in C# is achieved by using <code>abstract</code> classes and <code>interfaces</code>. An <code>abstract</code> class is a class that cannot be instantiated and is typically used as a base class for other classes. <code>Abstract</code> classes can have <code>abstract</code> methods which are declared in the <code>abstract</code> class and implemented in the derived classes.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>(<span class="hljs-params"></span>)</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>(<span class="hljs-params"></span>)
    </span>{
        Console.WriteLine(<span class="hljs-string">"The dog barks"</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">Animal</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>(<span class="hljs-params"></span>)
    </span>{
        Console.WriteLine(<span class="hljs-string">"The cat meows"</span>);
    }
}
</code></pre>
<p>In this example, <code>Animal</code> is an abstract class with an abstract method <code>Speak</code>. <code>Dog</code> and <code>Cat</code> classes are derived from <code>Animal</code> and provide their own implementation of <code>Speak</code>. When <code>Speak</code> is called on an object of type <code>Animal</code>, the appropriate version of <code>Speak</code> is invoked depending on the actual type of the object.</p>
<p>Abstraction using <code>Interfaces</code> is another way to achieve abstraction. An <code>interface</code> is like an <code>abstract</code> class with no implementation. It only declares the methods and properties but doesn&#39;t contain any code. A class that implements an interface must provide an implementation for all the interface methods.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IAnimal</span>
{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>(<span class="hljs-params"></span>)</span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">IAnimal</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>(<span class="hljs-params"></span>)
    </span>{
        Console.WriteLine(<span class="hljs-string">"The dog barks"</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">IAnimal</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Speak</span>(<span class="hljs-params"></span>)
    </span>{
        Console.WriteLine(<span class="hljs-string">"The cat meows"</span>);
    }
}
</code></pre>
<p>In this example, <code>IAnimal</code> is an interface with a method <code>Speak</code>. The classes <code>Dog</code> and <code>Cat</code> both implement <code>IAnimal</code> and provide their own implementation of <code>Speak</code>.</p>
<p>In both examples, the user does not need to understand how each animal speaks; they only need to know that all animals can speak. This is the essence of abstraction. It allows you to focus on what the object does instead of how it does it.</p>
<p>Abstraction has several benefits in software development:</p>
<ol>
<li><code>Complexity Management</code>: It simplifies the complexity of designing and maintaining large codebases. By creating abstract classes or interfaces, developers can develop methods and variables that apply to a broad range of related classes. It&#39;s easier to manage and understand a few abstract concepts than a larger number of detailed ones.</li>
<li><code>Reusability</code>: The use of abstraction promotes the reuse of code. Abstract classes and interfaces often create a template for future classes. Implementing these templates ensures consistent method use across classes and can reduce the amount of code that needs to be written.</li>
<li><code>Security</code>: Using abstraction, certain details of an object&#39;s implementation can be hidden from the user. This can prevent unauthorised or inappropriate use of an object&#39;s methods or variables.</li>
<li><code>Flexibility</code>: Abstraction provides a level of flexibility in the development process. As long as the interface between objects remains consistent, changes to the internal workings of an object do not affect the rest of the application. This allows for more freedom in future development and refactoring efforts.</li>
</ol>
<p>In addition to abstract classes and interfaces, encapsulation is another way to achieve abstraction in C#. Encapsulation refers to bundling data and the methods of operating it into a single unit. This is typically accomplished by defining a class. The data is stored in private fields, and accessed through public methods, protecting the data from being altered in unexpected ways.</p>
<p>For example, consider a <code>BankAccount</code> class:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BankAccount</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> balance;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Deposit</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> amount</span>)
    </span>{
        <span class="hljs-keyword">if</span> (amount &gt; <span class="hljs-number">0</span>)
        {
            balance += amount;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Withdraw</span>(<span class="hljs-params"><span class="hljs-keyword">double</span> amount</span>)
    </span>{
        <span class="hljs-keyword">if</span> (amount &gt; <span class="hljs-number">0</span> &amp;&amp; balance &gt;= amount)
        {
            balance -= amount;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">GetBalance</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword">return</span> balance;
    }
}
</code></pre>
<p>In this example, the <code>balance</code> field is private, meaning it cannot be accessed directly from outside the class. Instead, it is accessed through the <code>Deposit</code>, <code>Withdraw</code>, and <code>GetBalance</code> methods, which ensure the balance cannot be set to an invalid state. This is an example of encapsulation providing abstraction, as users of the <code>BankAccount</code> class do not need to know how the balance is stored or how the methods are implemented; they only need to know what methods are available to use.</p>
<h2 id="generics-in-c-">Generics in C\</h2>
<hr>
<p>Generics are a feature in C# that let you write type-safe and performant code that works with any data type. Without generics, developers often have to write separate versions of algorithms for different data types or resort to less type-safe options like casting to and from objects.</p>
<p>A type is a description of a set of data that specifies the kind of data that can be stored, the operations that can be performed on that data, and how the data is stored in memory. In C#, types are used extensively to ensure that code behaves as expected, i.e., a <code>string</code> can&#39;t be directly assigned to an <code>int</code> variable.</p>
<p>Generics extend this idea of types to type parameters. A generic type is a class, struct, interface, delegate, or method with a placeholder for one or more types it operates on. The actual types used by a generic type are specified when you create an instance of the type.</p>
<h4 id="benefits-of-generics">Benefits of Generics</h4>
<ol>
<li><code>Type safety</code>: Generics enforce compile-time type checking. They can carry out strongly typed methods, classes, interfaces, and delegates. With generics, you can create type-safe collection classes at compile time.</li>
<li><code>Performance</code>: With generics, performance is improved as boxing and unboxing are eliminated. For value types, this can represent a significant performance boost.</li>
<li><code>Code reusability</code>: Generics promote reusability. You can create a generic class that can be used with any data type.</li>
</ol>
<h3 id="generic-classes">Generic Classes</h3>
<p>A generic class declaration looks much like a non-generic class declaration, except that a type parameter list inside angle brackets follows the class name. The type parameters can then be used in the body of the class as placeholders for the types specified when the class is instantiated.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> GenericList&lt;T&gt;
{
    <span class="hljs-keyword">private</span> T[] elements;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">public</span> GenericList(<span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>)
    {
        elements = new T[<span class="hljs-built_in">size</span>];
    }

    <span class="hljs-keyword">public</span> void Add(T <span class="hljs-keyword">value</span>)
    {
        elements[<span class="hljs-built_in">count</span>] = <span class="hljs-keyword">value</span>;
        <span class="hljs-built_in">count</span>++;
    }

    <span class="hljs-keyword">public</span> T GetElement(<span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span>)
    {
        <span class="hljs-keyword">return</span> elements[<span class="hljs-built_in">index</span>];
    }
}
</code></pre>
<p>In the above example, <code>T</code> is the type parameter. This <code>GenericList</code> class can be instantiated with any type.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">var</span> list1 = <span class="hljs-keyword">new</span> GenericList&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>);
<span class="hljs-keyword">var</span> list2 = <span class="hljs-keyword">new</span> GenericList&lt;<span class="hljs-keyword">string</span>&gt;(<span class="hljs-number">5</span>);
</code></pre>
<h3 id="generic-methods">Generic Methods</h3>
<p>Generic methods are methods that are declared with type parameters. Like generic classes, you can create a method that defers the specification of one or more types until the method is called.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utilities</span>
{</span>
    <span class="hljs-keyword">public</span> T Max&lt;T&gt;(T a, T b) where <span class="hljs-string">T :</span> IComparable
    {
        <span class="hljs-keyword">return</span> a.CompareTo(b) &gt; <span class="hljs-number">0</span> ? a : b;
    }
}
</code></pre>
<p>In the <code>Max</code> method above, <code>T</code> represents any type that implements <code>IComparable</code>. This method can now be used with any comparable types, like integers, floats, strings, etc.</p>
<p>Code: csharp</p>
<pre><code class="lang-csharp">var utility = <span class="hljs-keyword">new</span> Utilities();
<span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = utility.Max&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// returns 4</span>
</code></pre>
<h3 id="generic-constraints">Generic Constraints</h3>
<p>You may want to restrict the types allowed as type arguments when designing generic classes or methods. For example, you might want to ensure that your generic method only operates on value types or classes, types that implement a particular interface, or types with a default constructor. This is done using generic constraints, which you can specify with the <code>where</code> keyword.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utilities</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-title">where</span> <span class="hljs-title">T</span> : <span class="hljs-type">IComparable</span>, <span class="hljs-type">new</span></span>()
{
    <span class="hljs-keyword">public</span> T Max(T a, T b)
    {
        <span class="hljs-keyword">return</span> a.CompareTo(b) &gt; <span class="hljs-number">0</span> ? a : b;
    }

    <span class="hljs-keyword">public</span> T Init()
    {
        <span class="hljs-keyword">return</span> new T();
    }
}
</code></pre>
<p>In the above example, the <code>Utilities</code> class has two constraints: <code>T</code> must implement <code>IComparable</code> and <code>T</code> must have a default constructor. Now, <code>Utilities</code> can be used with any type that satisfies these constraints.</p>
<pre><code class="lang-csharp">var utility = <span class="hljs-keyword">new</span> Utilities&lt;<span class="hljs-keyword">int</span>&gt;();
<span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = utility.Max(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// returns 4</span>
<span class="hljs-keyword">int</span> zero = utility.Init(); <span class="hljs-comment">// returns 0</span>
</code></pre>
<h2 id="asynchronous-programming">Asynchronous Programming</h2>
<p><code>Asynchronous programming</code> is a powerful technique in modern software development that allows programs to <code>perform non-blocking operations</code> and efficiently utilise system resources. It enables applications to <code>handle time-consuming tasks without blocking the main execution thread</code>, improving responsiveness and scalability.</p>
<p>In traditional <code>synchronous programming</code>, when a method is invoked, the <code>program waits until the method completes</code> its execution before proceeding to the following line of code. This blocking behaviour can lead to poor performance and unresponsive applications, especially when dealing with I/O-bound or long-running operations. You can see this behaviour in applications when they appear to <code>freeze randomly</code> and <code>become unresponsive</code> when you try to load a large file, for instance. <code>Asynchronous programming</code> addresses this issue by <code>allowing tasks to execute independently</code> without blocking the main thread, enabling other <code>work to be done concurrently</code>.</p>
<p>To understand this concept better, it&#39;s important to distinguish between <code>concurrent</code> and <code>parallel</code> operations. <code>Concurrent</code> operations refer to tasks that <code>appear to occur simultaneously</code> but may not necessarily do so. On the other hand, <code>parallel</code> operations involve tasks that are <code>executed at the same time</code> on different cores or processors. Asynchronous programming primarily deals with <code>concurrent operations</code>, enabling multiple tasks to <code>progress independently of each other</code>.</p>
<p>Asynchronous methods return a <code>Task</code> or <code>Task&lt;T&gt;</code> object representing an ongoing operation. The calling code can continue its execution while the asynchronous operation progresses in the background. Once the operation completes, the result can be retrieved or further processed.</p>
<p>There are a few very important things to be aware of when utilising asynchronous programming:</p>
<ul>
<li><code>Avoid Blocking Calls</code>: Use asynchronous versions of methods whenever possible to prevent blocking the main thread.</li>
<li><code>Configure async Methods Properly</code>: Ensure that <code>async</code> methods return <code>Task</code> or <code>Task&lt;T&gt;</code> and use the <code>await</code> keyword appropriately to await the completion of asynchronous operations.</li>
<li><code>Handle Exceptions</code>: Handle exceptions properly in asynchronous code. Use <code>try-catch</code> blocks to catch and handle exceptions that may occur during asynchronous operations. Unhandled exceptions can lead to unexpected application behaviour.</li>
<li><code>Use Cancellation Tokens</code>: Utilize cancellation tokens to allow the cancellation of asynchronous operations gracefully. This can improve the responsiveness and user experience of the application.</li>
</ul>
<h3 id="async-await">async &amp; await</h3>
<p>In C#, asynchronous programming is facilitated by the <code>async</code> and <code>await</code> keywords.</p>
<p>The <code>async</code> keyword is used to specify that a method, lambda expression, or anonymous method is asynchronous. These methods usually return a <code>Task</code> or <code>Task&lt;T&gt;</code> object, representing ongoing work.</p>
<p>On the other hand, the <code>await</code> keyword is used in an <code>async</code> method to suspend the execution of the method until a particular task completes; the program is <code>awaiting Task&lt;T&gt;</code> completion. <code>await</code> can only be used in an <code>async</code> method.</p>
<p>The basic structure of an asynchronous method using <code>async</code> and <code>await</code> would look like this:</p>
<pre><code class="lang-csharp"><span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;T&gt; <span class="hljs-title">MethodName</span>(<span class="hljs-params"></span>)
</span>{
    <span class="hljs-comment">//...Method body</span>
    <span class="hljs-keyword">await</span> SomeTask;
    <span class="hljs-comment">//...Continue after SomeTask finishes</span>
}
</code></pre>
<ul>
<li><code>async</code>: This keyword is used to specify that a method is asynchronous.</li>
<li><code>Task&lt;T&gt;</code>: An asynchronous method should return a <code>Task</code> or <code>Task&lt;T&gt;</code>. A <code>Task</code> represents an ongoing job that might not have been completed when your method returns. The job is executed concurrently with the rest of your program.</li>
<li><code>MethodName</code>: This is where you put the name of your method.</li>
<li>Inside the method body, you use the <code>await</code> keyword before a task to specify that the method can&#39;t continue until the awaited task completes—meanwhile, control returns to the caller of the method.</li>
</ul>
<pre><code class="lang-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">CalculateSumAsync</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b</span>)
</span>{
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">500</span>); <span class="hljs-comment">//Simulate some delay</span>
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallCalculateSumAsync</span>(<span class="hljs-params"></span>)
</span>{
    <span class="hljs-keyword">int</span> result = <span class="hljs-keyword">await</span> CalculateSumAsync(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);
    Console.WriteLine(<span class="hljs-string">$"The sum is <span class="hljs-subst">{result}</span>"</span>);
}
</code></pre>
<p>In this example, the method <code>CalculateSumAsync</code> is marked with the <code>async</code> keyword and returns a <code>Task&lt;int&gt;</code>. Inside the method, we simulate a delay with <code>Task.Delay</code>, which we <code>await</code>. This means that while we&#39;re waiting for the delay to finish, control can be given back to the caller of this method. After the delay is finished, we calculate the sum and return it. In <code>CallCalculateSumAsync</code>, we call our asynchronous method and immediately <code>await</code> its result. Once we have the result, we print it to the console.</p>
<p>Let&#39;s consider an example where we call a web service to fetch data. Fetching data from a web service can be time-consuming, so we will use <code>async</code> and <code>await</code> to ensure our application remains responsive during this operation.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">using</span> System.Net.Http; <span class="hljs-comment">// Network I/O is explained in more detail on the related page</span>
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> HttpClient client = <span class="hljs-keyword">new</span> HttpClient();

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword">string</span> responseBody = <span class="hljs-keyword">await</span> GetWebsiteContentAsync(<span class="hljs-string">"http://example.com"</span>);

        Console.WriteLine(responseBody);
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">GetWebsiteContentAsync</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> url</span>)
    </span>{
        HttpResponseMessage response = <span class="hljs-keyword">await</span> client.GetAsync(url);
        response.EnsureSuccessStatusCode();
        <span class="hljs-keyword">string</span> responseBody = <span class="hljs-keyword">await</span> response.Content.ReadAsStringAsync();

        <span class="hljs-keyword">return</span> responseBody;
    }
}
</code></pre>
<p>The <code>GetWebsiteContentAsync</code> method is responsible for fetching the content of a website. It uses an <code>HttpClient</code> to send an asynchronous GET request to the provided URL. The <code>await</code> keyword waits for the task to complete without blocking the rest of the code.</p>
<p>The <code>client.GetAsync</code> method returns a <code>Task&lt;HttpResponseMessage&gt;</code> representing the ongoing fetch operation. This task is awaited using the <code>await</code> keyword. After ensuring that the HTTP response status indicates success by calling the <code>EnsureSuccessStatusCode()</code> method, we read the content of the HTTP response message asynchronously using <code>response.Content.ReadAsStringAsync()</code>. This method returns a <code>Task&lt;string&gt;,</code> which is also awaited.</p>
<p>Finally, in our <code>Main</code> method, we call <code>GetWebsiteContentAsync</code> and await its result before writing it to the console.</p>
<h3 id="tasks">Tasks</h3>
<p>A Task can be in one of three states: <code>created</code>, <code>running</code>, or <code>completed</code>. Once a Task is completed, it can either result in a value, an exception, or nothing at all.</p>
<p>There are two types of tasks: <code>Task</code> and <code>Task&lt;T&gt;</code>.</p>
<ul>
<li>A <code>Task</code> represents a single operation that does not return a value and usually executes asynchronously. After the operation is completed, the Task is marked as completed. This is essentially a <code>void</code> async method.</li>
<li><code>Task&lt;T&gt;</code> represents an asynchronous operation that returns a value. The value type (denoted by <code>T</code>) is known and can be retrieved once the Task has finished execution.</li>
</ul>
<p>Creating tasks can be done using the <code>Task.Run</code> method or implement methods marked with the <code>async</code> keyword that return a <code>Task</code> or <code>Task&lt;T&gt;</code>. Here&#39;s an example of creating and running a task:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">Task</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">task</span> = <span class="hljs-keyword">Task</span>.Run(() =&gt; {
    <span class="hljs-comment">// Simulate work.</span>
    Thread.Sleep(<span class="hljs-number">1000</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">69</span>;
});
</code></pre>
<p>In this example, we create a task that sleeps for one second to simulate work and then returns the integer 69.</p>
<h3 id="task-cancellation">Task Cancellation</h3>
<p>If necessary, tasks can also be cancelled through the use of cancellation tokens.</p>
<pre><code class="lang-csharp">CancellationTokenSource cts = <span class="hljs-keyword">new</span> CancellationTokenSource();
Task&lt;int&gt; task = Task.<span class="hljs-keyword">Run</span>(() =&gt; {
    <span class="hljs-comment">// Simulate work.</span>
    Thread.<span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);
    cts.<span class="hljs-built_in">Token</span>.ThrowIfCancellationRequested();
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}, cts.<span class="hljs-built_in">Token</span>);

<span class="hljs-comment">// Cancel the task.</span>
cts.Cancel();
</code></pre>
<p><code>CancellationToken</code> is a struct that can be checked periodically by an operation, and if cancellation is requested, the operation can stop itself in a controlled manner.</p>
<p>Cancellation is signalled via the <code>CancellationTokenSource</code>. When you want to cancel one or more operations, you call <code>Cancel</code> on the <code>CancellationTokenSource</code>, which sends a signal to all linked <code>CancellationToken</code> instances.</p>
<pre><code class="lang-csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PerformOperationAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)
    {
        <span class="hljs-comment">// Simulate some work.</span>
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">100</span>);

        <span class="hljs-comment">// Check for cancellation.</span>
        cancellationToken.ThrowIfCancellationRequested();
    }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">MainAsync</span>(<span class="hljs-params"></span>)
</span>{
    <span class="hljs-keyword">var</span> cts = <span class="hljs-keyword">new</span> CancellationTokenSource();

    <span class="hljs-keyword">var</span> task = PerformOperationAsync(cts.Token);

    <span class="hljs-comment">// After 500 ms, cancel the operation.</span>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">500</span>);
    cts.Cancel();

    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">await</span> task;
    }
    <span class="hljs-keyword">catch</span> (OperationCanceledException)
    {
        Console.WriteLine(<span class="hljs-string">"Operation was cancelled."</span>);
    }
}
</code></pre>
<p>In this example, we pass a <code>CancellationToken</code> to the <code>PerformOperationAsync</code> method. Inside the method, after each unit of work (simulated with <code>Task.Delay</code>), we check if cancellation has been requested using <code>cancellationToken.ThrowIfCancellationRequested()</code>. This method throws an <code>OperationCanceledException</code> if a cancellation has been requested.</p>
<p>In the <code>MainAsync</code> method, we start the operation and cancel it after 500 ms by calling <code>cts.Cancel()</code>. This sends a signal to the associated cancellation token. When we await the task, it throws an <code>OperationCanceledException</code>, which we catch and handle.</p>
<h3 id="exception-handling-with-async-code">Exception Handling with Async Code</h3>
<p>Exception handling is a critical part of asynchronous programming. When you&#39;re dealing with asynchronous operations, there&#39;s always a possibility that something might go wrong. The operation could fail, the network could go down, data could be corrupted - the list goes on. Without proper exception handling, these errors could cause your application to crash or behave unpredictably.</p>
<p>Exceptions are propagated when you use <code>await</code> on the task. If the task has thrown any exceptions, <code>await</code> will re-throw that exception.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">try</span>
{
    <span class="hljs-keyword">string</span> result = <span class="hljs-keyword">await</span> GetWebsiteContentAsync();
}
<span class="hljs-keyword">catch</span> (HttpRequestException ex)
{
    Console.WriteLine(<span class="hljs-string">$"An error occurred: <span class="hljs-subst">{ex.Message}</span>"</span>);
}
</code></pre>
<p>In this example, we make a web request using the fictitious <code>FetchDataFromWebAsync</code> method. If the request fails and throws an <code>HttpRequestException</code>, our <code>catch</code> block will handle it and write an error message to the console.</p>
<p>If you&#39;re dealing with multiple <code>Tasks</code> and want to handle exceptions for each Task independently, you can use <code>Task.ContinueWith</code>. This method creates a continuation that executes when the task completes, regardless of the state of the antecedent task.</p>
<pre><code class="lang-csharp">var <span class="hljs-keyword">task</span> = FetchDataFromWebAsync();
<span class="hljs-keyword">task</span>.ContinueWith(t =&gt;
{
    <span class="hljs-keyword">if</span> (t.IsFaulted)
    {
        Console.<span class="hljs-keyword">WriteLine</span>($<span class="hljs-string">"An error occurred: {t.Exception.InnerException.Message}"</span>);
    }
});
</code></pre>
<p>In this example, <code>ContinueWith</code> is used to specify an action that will happen when the task completes. If the task is faulted (an unhandled exception was thrown), it writes an error message to the console.</p>
<h2 id="file-i-o">File I/O</h2>
<hr>
<p>File Input/Output (I/O) is a critical aspect of many applications and is well supported in C# through the <code>System.IO</code> namespace. This namespace provides numerous classes that enable reading from and writing to files, creating new files and directories, and performing operations such as moving, copying, or deleting files.</p>
<h3 id="filestream">FileStream</h3>
<p>The <code>FileStream</code> class, part of the <code>System.IO</code> namespace, provides a powerful and flexible interface for reading from and writing to files. As a core component of C#&#39;s I/O library, <code>FileStream</code> supports both sequential and random file access, allowing you to interact with a file&#39;s content anywhere, not just at its beginning or end.</p>
<p>A <code>FileStream</code> object can be seen as a cursor into the contents of a file, much like a text cursor that you move when editing a document. You can place this cursor at any position within the file and perform read or write operations.</p>
<h4 id="creating-a-filestream">Creating a FileStream</h4>
<p>There are several ways to create a <code>FileStream</code>. One common approach is using its constructor directly, as shown in the following code snippet:</p>
<pre><code class="lang-csharp"><span class="hljs-attribute">FileStream fs</span> = new FileStream(<span class="hljs-string">"test.dat"</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite);
</code></pre>
<p>In this example, the <code>FileStream</code> constructor takes three arguments:</p>
<ol>
<li>The first argument is a string specifying the path to the file.</li>
<li>The second argument is an enumeration of the type <code>FileMode</code>, which determines how the operating system should open the file. In this case, <code>FileMode.OpenOrCreate</code> means that the file should be opened if it exists; otherwise, a new file should be created.</li>
<li>The third argument is an enumeration of the type <code>FileAccess</code>, which indicates the type of access you want to the file. Here, <code>FileAccess.ReadWrite</code> grants the rights to read from and write to the file.</li>
</ol>
<h4 id="reading-and-writing-with-filestream">Reading and Writing with FileStream</h4>
<p>To write data to a file, you use the <code>Write</code> method of the <code>FileStream</code> class.</p>
<pre><code class="lang-csharp"><span class="hljs-title">byte</span>[] <span class="hljs-class"><span class="hljs-keyword">data</span> = new byte[] { 1, 2, 3, 4, 5 };</span>
<span class="hljs-title">fs</span>.<span class="hljs-type">Write</span>(<span class="hljs-class"><span class="hljs-keyword">data</span>, 0, <span class="hljs-keyword">data</span>.<span class="hljs-type">Length</span>);</span>
</code></pre>
<p>In this example, <code>Write</code> is called on the <code>FileStream</code> object <code>fs</code> to write the byte array <code>data</code> to the file. The second and third arguments to <code>Write</code> are the starting point in the array and the number of bytes to write, respectively.</p>
<p>To read data from a file, you can use the <code>Read</code> method of the <code>FileStream</code> class, as shown in the following example:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">byte[] </span><span class="hljs-meta">data</span> = new <span class="hljs-keyword">byte[1024];
</span><span class="hljs-symbol">int</span> <span class="hljs-keyword">bytesRead </span>= fs.Read(<span class="hljs-meta">data</span>, <span class="hljs-number">0</span>, <span class="hljs-meta">data</span>.Length)<span class="hljs-comment">;</span>
</code></pre>
<p>In this case, <code>Read</code> is called on the <code>FileStream</code> object <code>fs</code> to read bytes into the <code>data</code> array. The second and third arguments to <code>Read</code> are the starting point in the array and the maximum number of bytes to read, respectively. <code>Read</code> returns the actual number of bytes read, which may be less than the requested number if the end of the file is reached.</p>
<h4 id="manipulating-the-file-position">Manipulating the File Position</h4>
<p>An important feature of <code>FileStream</code> is the ability to get or set the position within the file, represented by the <code>Position</code> property. For example, you can move to the start of the file with the following code:</p>
<pre><code class="lang-csharp">fs.Position = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
</code></pre>
<p>Or, you can move to a specific position within the file:</p>
<pre><code class="lang-csharp">fs.Position = <span class="hljs-number">50</span>; <span class="hljs-comment">// Moves to the 51st byte in the file.</span>
</code></pre>
<p>This feature of random access is particularly useful when dealing with large files or when you need to jump to specific sections of a file.</p>
<h4 id="closing-the-filestream">Closing the FileStream</h4>
<p>Finally, when you&#39;re done with a <code>FileStream</code>, it&#39;s essential to close it to free up the resources it&#39;s using. You can do this with the <code>Close</code> method:</p>
<pre><code class="lang-csharp">fs.Close()<span class="hljs-comment">;</span>
</code></pre>
<p>Alternatively, since <code>FileStream</code> implements <code>IDisposable</code>, you can take advantage of the <code>using</code> statement to automatically close the stream:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">using</span> (FileStream fs = <span class="hljs-keyword">new</span> <span class="hljs-type">FileStream</span>(<span class="hljs-string">"test.dat"</span>, FileMode.OpenOrCreate, FileAccess.ReadWrite))
{
    <span class="hljs-comment">// perform file operations...</span>
}
</code></pre>
<p>When the <code>using</code> block is exited (either after normal execution or an exception), the <code>Dispose</code> method is called on <code>fs</code>, which in turn calls <code>Close</code>, ensuring that the file is properly closed.</p>
<h3 id="streamreader-and-streamwriter">StreamReader and StreamWriter</h3>
<p><code>StreamReader</code> and <code>StreamWriter</code> are powerful classes within the <code>System.IO</code> namespace for reading and writing character data. As high-level abstractions, they provide a more convenient interface for dealing with text files than the <code>FileStream</code> class.</p>
<h4 id="streamreader">StreamReader</h4>
<p>A <code>StreamReader</code> reads characters from a byte stream in a particular encoding (such as UTF-8). It&#39;s ideal for reading text files.</p>
<p><strong>Creating a StreamReader</strong></p>
<p>A <code>StreamReader</code> is typically instantiated with a <code>FileStream</code> or a file path. For example:</p>
<pre><code class="lang-csharp"><span class="hljs-attribute">StreamReader sr</span> = new StreamReader(<span class="hljs-string">"test.txt"</span>);
</code></pre>
<p>This code creates a <code>StreamReader</code> to read from the file <code>test.txt</code>.</p>
<p><strong>Reading Data with StreamReader</strong></p>
<p><code>StreamReader</code> provides several methods to read data from the stream. For instance, you can read one line at a time with <code>ReadLine</code>:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string</span> <span class="hljs-built_in">line</span> = sr.ReadLine();
</code></pre>
<p>To read the entire content of the file at once, you can use the <code>ReadToEnd</code> method:</p>
<pre><code class="lang-csharp"><span class="hljs-attribute">string content</span> = sr.ReadToEnd();
</code></pre>
<p>Remember to close the <code>StreamReader</code> when you&#39;re done with it:</p>
<pre><code class="lang-csharp">sr.Close()<span class="hljs-comment">;</span>
</code></pre>
<h4 id="streamwriter">StreamWriter</h4>
<p>While <code>StreamReader</code> is used for reading text data, <code>StreamWriter</code> is used for writing text data. It&#39;s an efficient way to write text to a file or a stream.</p>
<p><strong>Creating a StreamWriter</strong></p>
<p>A <code>StreamWriter</code> can be instantiated in a similar way to <code>StreamReader</code>. You can pass a <code>FileStream</code> or a file path to the constructor:</p>
<pre><code class="lang-csharp"><span class="hljs-attribute">StreamWriter sw</span> = new StreamWriter(<span class="hljs-string">"test.txt"</span>);
</code></pre>
<p>This code creates a <code>StreamWriter</code> that writes to the file &quot;test.txt&quot;.</p>
<p><strong>Writing Data with StreamWriter</strong></p>
<p><code>StreamWriter</code> provides several methods for writing data to the stream. You can write a string with the <code>Write</code> method:</p>
<pre><code class="lang-csharp">sw.Write(<span class="hljs-string">"Hello, World!"</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>To write a string and then immediately follow it with a newline, use <code>WriteLine</code>:</p>
<pre><code class="lang-csharp">sw.WriteLine(<span class="hljs-string">"Hello, World!"</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Remember to close the <code>StreamWriter</code> when you&#39;re done with it:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">sw</span>.<span class="hljs-keyword">Close</span>();
</code></pre>
<p>In StreamReader and StreamWriter, you can use the <code>using</code> statement, which automatically closes the stream when the <code>using</code> block is exited. This ensures that resources are correctly disposed of, even if an exception is thrown within the block:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">using</span> (StreamWriter sw = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamWriter</span>(<span class="hljs-string">"test.txt"</span>))
{
    sw.WriteLine(<span class="hljs-string">"Hello, World!"</span>);
}
</code></pre>
<h3 id="file-and-directory">File and Directory</h3>
<p>The <code>File</code> and <code>Directory</code> classes in the <code>System.IO</code> namespace contain static methods for creating, copying, deleting, moving, and opening files and directories and performing various other file and directory operations.</p>
<h4 id="file">File</h4>
<p>The <code>File</code> class allows you to work with files. It provides static methods, so you don&#39;t need to instantiate the class to use these methods.</p>
<p><strong>Creating and Writing to a File</strong></p>
<p>The <code>WriteAllText</code> method writes a specified string to a file. If the file already exists, it will be overwritten. If it doesn&#39;t exist, the method will create it:</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">File</span>.WriteAllText(<span class="hljs-string">"test.txt"</span>, <span class="hljs-string">"Hello, World!"</span>);
</code></pre>
<p><strong>Reading from a File</strong></p>
<p>The <code>ReadAllText</code> method reads all text from a file and returns it as a string:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string</span> content = <span class="hljs-built_in">File</span>.ReadAllText(<span class="hljs-string">"test.txt"</span>);
<span class="hljs-built_in">Console</span>.WriteLine(content);
</code></pre>
<p><strong>Checking if a File Exists</strong></p>
<p>You can check whether a file exists using the <code>Exists</code> method:</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">if</span> (<span class="hljs-built_in">File</span>.Exists(<span class="hljs-string">"test.txt"</span>))
{
    <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"The file exists."</span>);
}
</code></pre>
<h4 id="directory">Directory</h4>
<p>The <code>Directory</code> class provides static methods for manipulating directories.</p>
<p><strong>Creating a Directory</strong></p>
<p>You can create a directory using the <code>CreateDirectory</code> method:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">Directory</span>.<span class="hljs-keyword">CreateDirectory</span>(<span class="hljs-string">"TestDirectory"</span>);
</code></pre>
<p>This code creates a new directory named <code>TestDirectory</code>. If the directory already exists, this method does not create a new directory but doesn’t return an error.</p>
<p><strong>Checking if a Directory Exists</strong></p>
<p>You can check whether a directory exists using the <code>Exists</code> method:</p>
<pre><code class="lang-csharp"><span class="hljs-built_in">if</span> (Directory.Exists(<span class="hljs-string">"TestDirectory"</span>))
{
    <span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">"The directory exists."</span>);
}
</code></pre>
<p><strong>Getting Files and Subdirectories</strong></p>
<p>The <code>GetFiles</code> method returns the names of files in a directory, and the <code>GetDirectories</code> method returns the names of subdirectories:</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">string[] </span>files = Directory.GetFiles(<span class="hljs-string">"TestDirectory"</span>)<span class="hljs-comment">;</span>
<span class="hljs-keyword">string[] </span><span class="hljs-keyword">subdirectories </span>= Directory.GetDirectories(<span class="hljs-string">"TestDirectory"</span>)<span class="hljs-comment">;</span>
</code></pre>
<h2 id="network-i-o">Network I/O</h2>
<hr>
<p>Network Input/Output (I/O) forms the backbone of most modern applications. It&#39;s how applications interact with networks, allowing them to send and receive data to and from remote servers.</p>
<p>C# provides comprehensive support for <code>Network I/O</code> operations through its <code>System.Net</code> and <code>System.Net.Sockets</code> namespaces, among others. These namespaces include a variety of classes and methods that encapsulate the complexity of network programming, making it easier for developers to create network-centric applications.</p>
<h3 id="httpclient">HttpClient</h3>
<p>The <code>HttpClient</code> class in C# is a part of the <code>System.Net.Http</code> namespace and provides a modern, flexible, and highly configurable way to send HTTP requests and receive HTTP responses from a resource identified by a URI (Uniform Resource Identifier). It&#39;s frequently used to consume APIs, download files, or scrape web content.</p>
<p>The <code>HttpClient</code> class is designed to be re-used for multiple requests. As such, it&#39;s typically instantiated once and re-used throughout the life of an application, which can improve performance and system resource usage by allowing socket reuse.</p>
<p>The <code>HttpClient</code> class includes several methods to send HTTP requests. The primary methods are:</p>
<ul>
<li><code>GetAsync</code>: Sends a GET request to the specified URI and returns the response body as a string.</li>
<li><code>PostAsync</code>: Sends a POST request to the specified URI with a specified content.</li>
<li><code>PutAsync</code>: Sends a PUT request to the specified URI with a specified content.</li>
<li><code>DeleteAsync</code>: Sends a DELETE request to the specified URI.</li>
</ul>
<p>Code: csharp</p>
<pre><code class="lang-csharp">HttpClient client = <span class="hljs-keyword">new</span> HttpClient();

<span class="hljs-comment">// Send a GET request</span>
<span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> client.GetAsync(<span class="hljs-string">"https://api.example.com/data"</span>);

<span class="hljs-comment">// Ensure we get a successful response</span>
response.EnsureSuccessStatusCode();

<span class="hljs-comment">// Read the response content</span>
<span class="hljs-keyword">string</span> content = <span class="hljs-keyword">await</span> response.Content.ReadAsStringAsync();
</code></pre>
<p>In this example, we create an instance of <code>HttpClient</code>, send a <code>GET</code> request to a specified URI, ensure we received a successful response, and then read the response content into a string.</p>
<h4 id="getasync">GetAsync</h4>
<p><code>GetAsync</code> sends a <code>GET</code> request to a specified URI. This is an asynchronous operation, meaning the method returns immediately after calling without waiting for the HTTP response. Instead, it returns a Task representing the ongoing operation, which eventually produces the <code>HttpResponseMessage</code> once completed.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Net.Http;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> HttpClient client = <span class="hljs-keyword">new</span> HttpClient();

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword">try</span>
        {
            HttpResponseMessage response = <span class="hljs-keyword">await</span> client.GetAsync(<span class="hljs-string">"http://api.example.com/data"</span>);
            response.EnsureSuccessStatusCode();
            <span class="hljs-keyword">string</span> responseBody = <span class="hljs-keyword">await</span> response.Content.ReadAsStringAsync();
            Console.WriteLine(responseBody);
        }
        <span class="hljs-keyword">catch</span>(HttpRequestException e)
        {
            Console.WriteLine(<span class="hljs-string">"Exception Caught!"</span>);
            Console.WriteLine(<span class="hljs-string">$"Message: <span class="hljs-subst">{e.Message}</span>"</span>);
        }
    }
}
</code></pre>
<p>In this example, we send a <code>GET</code> request to <code>http://api.example.com/data</code>, and then read the response body into a string.</p>
<h4 id="postasync">PostAsync</h4>
<p><code>PostAsync</code> is another method in the <code>HttpClient</code> class. It sends a POST request to a specified URI and some HTTP content. Like <code>GetAsync</code>, it&#39;s an asynchronous operation and returns a <code>Task&lt;HttpResponseMessage&gt;</code>.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Net.Http;
<span class="hljs-keyword">using</span> System.Text;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> HttpClient client = <span class="hljs-keyword">new</span> HttpClient();

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword">try</span>
        {
            <span class="hljs-keyword">var</span> json = <span class="hljs-string">"{\"name\":\"John Doe\"}"</span>;
            HttpContent content = <span class="hljs-keyword">new</span> StringContent(json, Encoding.UTF8, <span class="hljs-string">"application/json"</span>);
            HttpResponseMessage response = <span class="hljs-keyword">await</span> client.PostAsync(<span class="hljs-string">"http://api.example.com/data"</span>, content);
            response.EnsureSuccessStatusCode();
            <span class="hljs-keyword">string</span> responseBody = <span class="hljs-keyword">await</span> response.Content.ReadAsStringAsync();
            Console.WriteLine(responseBody);
        }
        <span class="hljs-keyword">catch</span>(HttpRequestException e)
        {
            Console.WriteLine(<span class="hljs-string">"Exception Caught!"</span>);
            Console.WriteLine(<span class="hljs-string">$"Message: <span class="hljs-subst">{e.Message}</span>"</span>);
        }
    }
}
</code></pre>
<p>In this case, we send a JSON object as the body of our POST request.</p>
<h4 id="putasync">PutAsync</h4>
<p><code>PutAsync</code> works much like <code>PostAsync</code>, but it sends a <code>PUT</code> request instead. It&#39;s used when you want to update a resource at a specific URI with some new data.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Net.Http;
<span class="hljs-keyword">using</span> System.Text;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> HttpClient client = <span class="hljs-keyword">new</span> HttpClient();

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword">try</span>
        {
            <span class="hljs-keyword">var</span> json = <span class="hljs-string">"{\"id\":1,\"name\":\"John Doe Updated\"}"</span>;
            HttpContent content = <span class="hljs-keyword">new</span> StringContent(json, Encoding.UTF8, <span class="hljs-string">"application/json"</span>);
            HttpResponseMessage response = <span class="hljs-keyword">await</span> client.PutAsync(<span class="hljs-string">"http://api.example.com/data/1"</span>, content);
            response.EnsureSuccessStatusCode();
            <span class="hljs-keyword">string</span> responseBody = <span class="hljs-keyword">await</span> response.Content.ReadAsStringAsync();
            Console.WriteLine(responseBody);
        }
        <span class="hljs-keyword">catch</span>(HttpRequestException e)
        {
            Console.WriteLine(<span class="hljs-string">"Exception Caught!"</span>);
            Console.WriteLine(<span class="hljs-string">$"Message: <span class="hljs-subst">{e.Message}</span>"</span>);
        }
    }
}
</code></pre>
<p>In this example, we send a PUT request to update the resource at <code>http://api.example.com/data/1</code> with new data.</p>
<h4 id="deleteasync">DeleteAsync</h4>
<p>Finally, <code>DeleteAsync</code> sends a <code>DELETE</code> request to a specified URI. It&#39;s typically used when deleting a resource at a specific URI.</p>
<pre><code class="lang-csharp"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Net.Http;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> HttpClient client = <span class="hljs-keyword">new</span> HttpClient();

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)
    </span>{
        <span class="hljs-keyword">try</span>
        {
            HttpResponseMessage response = <span class="hljs-keyword">await</span> client.DeleteAsync(<span class="hljs-string">"http://api.example.com/data/1"</span>);
            response.EnsureSuccessStatusCode();
            <span class="hljs-keyword">string</span> responseBody = <span class="hljs-keyword">await</span> response.Content.ReadAsStringAsync();
            Console.WriteLine(responseBody);
        }
        <span class="hljs-keyword">catch</span>(HttpRequestException e)
        {
            Console.WriteLine(<span class="hljs-string">"Exception Caught!"</span>);
            Console.WriteLine(<span class="hljs-string">$"Message: <span class="hljs-subst">{e.Message}</span>"</span>);
        }
    }
}
</code></pre>
<p>In this case, we send a <code>DELETE</code> request to <code>http://api.example.com/data/1</code> to delete the resource.</p>
