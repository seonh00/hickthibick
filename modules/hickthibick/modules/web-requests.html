
<body>
  <div class="container">
<link rel="stylesheet" href="style.css">

<h1 id="1-web-requests">1. Web Requests</h1>
<h2 id="cheat-sheet">Cheat Sheet</h2>
<p>The cheat sheet is a useful command reference for this module.</p>
<h3 id="curl">cURL</h3>
<table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>curl -h</code></td>
<td>cURL help menu</td>
</tr>
<tr>
<td><code>curl inlanefreight.com</code></td>
<td>Basic GET request</td>
</tr>
<tr>
<td><code>curl -s -O inlanefreight.com/index.html</code></td>
<td>Download file</td>
</tr>
<tr>
<td><code>curl -k https://inlanefreight.com</code></td>
<td>Skip HTTPS (SSL) certificate validation</td>
</tr>
<tr>
<td><code>curl inlanefreight.com -v</code></td>
<td>Print full HTTP request/response details</td>
</tr>
<tr>
<td><code>curl -I https://www.inlanefreight.com</code></td>
<td>Send HEAD request (only prints response headers)</td>
</tr>
<tr>
<td><code>curl -i https://www.inlanefreight.com</code></td>
<td>Print response headers and response body</td>
</tr>
<tr>
<td><code>curl https://www.inlanefreight.com -A &#39;Mozilla/5.0&#39;</code></td>
<td>Set User-Agent header</td>
</tr>
<tr>
<td><code>curl -u admin:admin http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td>
<td>Set HTTP basic authorization credentials</td>
</tr>
<tr>
<td><code>curl http://admin:admin@&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td>
<td>Pass HTTP basic authorization credentials in the URL</td>
</tr>
<tr>
<td><code>curl -H &#39;Authorization: Basic YWRtaW46YWRtaW4=&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td>
<td>Set request header</td>
</tr>
<tr>
<td><code>curl &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/search.php?search=le&#39;</code></td>
<td>Pass GET parameters</td>
</tr>
<tr>
<td><code>curl -X POST -d &#39;username=admin&amp;password=admin&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td>
<td>Send POST request with POST data</td>
</tr>
<tr>
<td><code>curl -b &#39;PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td>
<td>Set request cookies</td>
</tr>
<tr>
<td><code>curl -X POST -d &#39;{&quot;search&quot;:&quot;london&quot;}&#39; -H &#39;Content-Type: application/json&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/search.php</code></td>
<td>Send POST request with JSON data</td>
</tr>
</tbody>
</table>
<h3 id="apis">APIs</h3>
<table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>curl http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london</code></td>
<td>Read entry</td>
</tr>
<tr>
<td>`curl -s http://<SERVER_IP>:<PORT>/api.php/city/ \</td>
<td>jq`</td>
<td>Read all entries</td>
</tr>
<tr>
<td><code>curl -X POST http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/ -d &#39;{&quot;city_name&quot;:&quot;HTB_City&quot;, &quot;country_name&quot;:&quot;HTB&quot;}&#39; -H &#39;Content-Type: application/json&#39;</code></td>
<td>Create (add) entry</td>
</tr>
<tr>
<td><code>curl -X PUT http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london -d &#39;{&quot;city_name&quot;:&quot;New_HTB_City&quot;, &quot;country_name&quot;:&quot;HTB&quot;}&#39; -H &#39;Content-Type: application/json&#39;</code></td>
<td>Update (modify) entry</td>
</tr>
<tr>
<td><code>curl -X DELETE http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/New_HTB_City</code></td>
<td>Delete entry</td>
</tr>
</tbody>
</table>
<h3 id="browser-devtools">Browser DevTools</h3>
<table>
<thead>
<tr>
<th><strong>Shortcut</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>[<code>CTRL+SHIFT+I</code>] or [<code>F12</code>]</td>
<td>Show devtools</td>
</tr>
<tr>
<td>[<code>CTRL+SHIFT+E</code>]</td>
<td>Show Network tab</td>
</tr>
<tr>
<td>[<code>CTRL+SHIFT+K</code>]</td>
<td>Show Console tab</td>
</tr>
</tbody>
</table>
<h2 id="hypertext-transfer-protocol-http-">HyperText Transfer Protocol (HTTP)</h2>
<p>Today, the majority of the applications we use constantly interact with the internet, both web and mobile applications. Most internet communications are made with web requests through the HTTP protocol. <a href="https://tools.ietf.org/html/rfc2616">HTTP</a> is an application-level protocol used to access the World Wide Web resources. The term <code>hypertext</code> stands for text containing links to other resources and text that the readers can easily interpret.</p>
<p>HTTP communication consists of a client and a server, where the client requests the server for a resource. The server processes the requests and returns the requested resource. The default port for HTTP communication is port <code>80</code>, though this can be changed to any other port, depending on the web server configuration. The same requests are utilized when we use the internet to visit different websites. We enter a <code>Fully Qualified Domain Name</code> (<code>FQDN</code>) as a <code>Uniform Resource Locator</code> (<code>URL</code>) to reach the desired website, like <a href="http://www.hackthebox.com/">www.hackthebox.com</a>.</p>
<hr>
<h3 id="url">URL</h3>
<p>Resources over HTTP are accessed via a <code>URL</code>, which offers many more specifications than simply specifying a website we want to visit. Let&#39;s look at the structure of a URL: <img src="https://academy.hackthebox.com/storage/modules/35/url_structure.png" alt="url\_structure"></p>
<p>Here is what each component stands for:</p>
<table>
<thead>
<tr>
<th><strong>Component</strong></th>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Scheme</code></td>
<td><code>http://</code> <code>https://</code></td>
<td>This is used to identify the protocol being accessed by the client, and ends with a colon and a double slash (<code>://</code>)</td>
</tr>
<tr>
<td><code>User Info</code></td>
<td><code>admin:password@</code></td>
<td>This is an optional component that contains the credentials (separated by a colon <code>:</code>) used to authenticate to the host, and is separated from the host with an at sign (<code>@</code>)</td>
</tr>
<tr>
<td><code>Host</code></td>
<td><code>inlanefreight.com</code></td>
<td>The host signifies the resource location. This can be a hostname or an IP address</td>
</tr>
<tr>
<td><code>Port</code></td>
<td><code>:80</code></td>
<td>The <code>Port</code> is separated from the <code>Host</code> by a colon (<code>:</code>). If no port is specified, <code>http</code> schemes default to port <code>80</code> and <code>https</code> default to port <code>443</code></td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>/dashboard.php</code></td>
<td>This points to the resource being accessed, which can be a file or a folder. If there is no path specified, the server returns the default index (e.g. <code>index.html</code>).</td>
</tr>
<tr>
<td><code>Query String</code></td>
<td><code>?login=true</code></td>
<td>The query string starts with a question mark (<code>?</code>), and consists of a parameter (e.g. <code>login</code>) and a value (e.g. <code>true</code>). Multiple parameters can be separated by an ampersand (<code>&amp;</code>).</td>
</tr>
<tr>
<td><code>Fragments</code></td>
<td><code>#status</code></td>
<td>Fragments are processed by the browsers on the client-side to locate sections within the primary resource (e.g. a header or section on the page).</td>
</tr>
</tbody>
</table>
<p>Not all components are required to access a resource. The main mandatory fields are the scheme and the host, without which the request would have no resource to request.</p>
<hr>
<h3 id="http-flow">HTTP Flow</h3>
<p><img src="https://academy.hackthebox.com/storage/modules/35/HTTP_Flow.png" alt="HTTP\_Flow"></p>
<p>The diagram above presents the anatomy of an HTTP request at a very high level. The first time a user enters the URL (<code>inlanefreight.com</code>) into the browser, it sends a request to a DNS (Domain Name Resolution) server to resolve the domain and get its IP. The DNS server looks up the IP address for <code>inlanefreight.com</code> and returns it. All domain names need to be resolved this way, as a server can&#39;t communicate without an IP address.</p>
<p>Note: Our browsers usually first look up records in the local &#39;<code>/etc/hosts</code>&#39; file, and if the requested domain does not exist within it, then they would contact other DNS servers. We can use the &#39;<code>/etc/hosts</code>&#39; to manually add records to for DNS resolution, by adding the IP followed by the domain name.</p>
<p>Once the browser gets the IP address linked to the requested domain, it sends a GET request to the default HTTP port (e.g. <code>80</code>), asking for the root <code>/</code> path. Then, the web server receives the request and processes it. By default, servers are configured to return an index file when a request for <code>/</code> is received.</p>
<p>In this case, the contents of <code>index.html</code> are read and returned by the web server as an HTTP response. The response also contains the status code (e.g. <code>200 OK</code>), which indicates that the request was successfully processed. The web browser then renders the <code>index.html</code> contents and presents it to the user.</p>
<p>Note: This module is mainly focused on HTTP web requests. For more on HTML and web applications, you may refer to the <a href="https://academy.hackthebox.com/module/details/75">Introduction to Web Applications</a> module.</p>
<hr>
<h3 id="curl">cURL</h3>
<p>In this module, we will be sending web requests through two of the most important tools for any web penetration tester, a Web Browser, like Chrome or Firefox, and the <code>cURL</code> command line tool.</p>
<p><a href="https://curl.haxx.se/">cURL</a> (client URL) is a command-line tool and library that primarily supports HTTP along with many other protocols. This makes it a good candidate for scripts as well as automation, making it essential for sending various types of web requests from the command line, which is necessary for many types of web penetration tests.</p>
<p>We can send a basic HTTP request to any URL by using it as an argument for cURL, as follows:</p>
<p>HyperText Transfer Protocol (HTTP)</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ curl inlanefreight.com

<span class="hljs-meta">&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
...SNIP...
</code></pre>
<p>We see that cURL does not render the HTML/JavaScript/CSS code, unlike a web browser, but prints it in its raw format. However, as penetration testers, we are mainly interested in the request and response context, which usually becomes much faster and more convenient than a web browser.</p>
<p>We may also use cURL to download a page or a file and output the content into a file using the <code>-O</code> flag. If we want to specify the output file name, we can use the <code>-o</code> flag and specify the name. Otherwise, we can use <code>-O</code> and cURL will use the remote file name, as follows:</p>
<p>HyperText Transfer Protocol (HTTP)</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ curl -O inlanefreight.<span class="hljs-keyword">com</span>/<span class="hljs-built_in">index</span>.html
root@htb[/htb]$ <span class="hljs-keyword">ls</span>
<span class="hljs-built_in">index</span>.html
</code></pre>
<p>As we can see, the output was not printed this time but rather saved into <code>index.html</code>. We noticed that cURL still printed some status while processing the request. We can silent the status with the <code>-s</code> flag, as follows:</p>
<p>HyperText Transfer Protocol (HTTP)</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ curl -s -O inlanefreight.com/index.html
</code></pre>
<p>This time, cURL did not print anything, as the output was saved into the <code>index.html</code> file. Finally, we may use the <code>-h</code> flag to see what other options we may use with cURL:</p>
<p>HyperText Transfer Protocol (HTTP)</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ curl -h
Usage: curl [<span class="hljs-keyword">options</span>...] <span class="hljs-symbol">&lt;url&gt;</span>
 -d, --data <span class="hljs-symbol">&lt;data&gt;</span>   HTTP POST data
 -h, --<span class="hljs-keyword">help</span> <span class="hljs-symbol">&lt;category&gt;</span> Get <span class="hljs-keyword">help</span> <span class="hljs-keyword">for</span> commands
 -i, --include       Include protocol response headers in the output
 -<span class="hljs-keyword">o</span>, --output <span class="hljs-symbol">&lt;file&gt;</span> Write <span class="hljs-keyword">to</span> <span class="hljs-keyword">file</span> instead of stdout
 -O, --remote-name   Write output <span class="hljs-keyword">to</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">file</span> named <span class="hljs-keyword">as</span> the remote <span class="hljs-keyword">file</span>
 -s, --<span class="hljs-keyword">silent</span>        Silent <span class="hljs-keyword">mode</span>
 -<span class="hljs-keyword">u</span>, --user &lt;user:password&gt; Server user <span class="hljs-built_in">and</span> password
 -A, --user-agent <span class="hljs-symbol">&lt;name&gt;</span> Send User-Agent <span class="hljs-symbol">&lt;name&gt;</span> <span class="hljs-keyword">to</span> server
 -v, --<span class="hljs-keyword">verbose</span>       Make the operation more talkative

This <span class="hljs-keyword">is</span> not the full <span class="hljs-keyword">help</span>, this <span class="hljs-keyword">menu</span> <span class="hljs-keyword">is</span> stripped into categories.
Use <span class="hljs-string">"--help category"</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">get</span> <span class="hljs-keyword">an</span> overview of <span class="hljs-keyword">all</span> categories.
Use the user manual `man curl` <span class="hljs-built_in">or</span> the <span class="hljs-string">"--help all"</span> flag <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">options</span>.
</code></pre>
<p>As the above message mentions, we may use <code>--help all</code> to print a more detailed help menu, or <code>--help category</code> (e.g. <code>-h http</code>) to print the detailed help of a specific flag. If we ever need to read more detailed documentation, we can use <code>man curl</code> to view the full cURL manual page.</p>
<p>In the upcoming sections, we will cover most of the above flags and see where we should use each of them.</p>
<h2 id="hypertext-transfer-protocol-secure-https-">Hypertext Transfer Protocol Secure (HTTPS)</h2>
<p>In the previous section, we discussed how HTTP requests are sent and processed. However, one of the significant drawbacks of HTTP is that all data is transferred in clear-text. This means that anyone between the source and destination can perform a Man-in-the-middle (MiTM) attack to view the transferred data.</p>
<p>To counter this issue, the <a href="https://tools.ietf.org/html/rfc2660">HTTPS (HTTP Secure) protocol</a> was created, in which all communications are transferred in an encrypted format, so even if a third party does intercept the request, they would not be able to extract the data out of it. For this reason, HTTPS has become the mainstream scheme for websites on the internet, and HTTP is being phased out, and soon most web browsers will not allow visiting HTTP websites.</p>
<hr>
<h3 id="https-overview">HTTPS Overview</h3>
<p>If we examine an HTTP request, we can see the effect of not enforcing secure communications between a web browser and a web application. For example, the following is the content of an HTTP login request: <img src="https://academy.hackthebox.com/storage/modules/35/https_clear.png" alt="http\_clear"></p>
<p>We can see that the login credentials can be viewed in clear-text. This would make it easy for someone on the same network (such as a public wireless network) to capture the request and reuse the credentials for malicious purposes.</p>
<p>In contrast, when someone intercepts and analyzes traffic from an HTTPS request, they would see something like the following: <img src="https://academy.hackthebox.com/storage/modules/35/https_google_enc.png" alt="https\_google\_enc"></p>
<p>As we can see, the data is transferred as a single encrypted stream, which makes it very difficult for anyone to capture information such as credentials or any other sensitive data.</p>
<p>Websites that enforce HTTPS can be identified through <code>https://</code> in their URL (e.g. <a href="https://www.google.com">https://www.google.com</a>), as well as the lock icon in the address bar of the web browser, to the left of the URL: <img src="https://academy.hackthebox.com/storage/modules/35/https_google.png" alt="https\_google"></p>
<p>So, if we visit a website that utilizes HTTPS, like Google, all traffic would be encrypted.</p>
<p>Note: Although the data transferred through the HTTPS protocol may be encrypted, the request may still reveal the visited URL if it contacted a clear-text DNS server. For this reason, it is recommended to utilize encrypted DNS servers (e.g. 8.8.8.8 or 1.1.1.1), or utilize a VPN service to ensure all traffic is properly encrypted.</p>
<hr>
<h3 id="https-flow">HTTPS Flow</h3>
<p>Let&#39;s look at how HTTPS operates at a high level: <img src="https://academy.hackthebox.com/storage/modules/35/HTTPS_Flow.png" alt="HTTPS\_Flow"></p>
<p>If we type <code>http://</code> instead of <code>https://</code> to visit a website that enforces HTTPS, the browser attempts to resolve the domain and redirects the user to the webserver hosting the target website. A request is sent to port <code>80</code> first, which is the unencrypted HTTP protocol. The server detects this and redirects the client to secure HTTPS port <code>443</code> instead. This is done via the <code>301 Moved Permanently</code> response code, which we will discuss in an upcoming section.</p>
<p>Next, the client (web browser) sends a &quot;client hello&quot; packet, giving information about itself. After this, the server replies with &quot;server hello&quot;, followed by a <a href="https://en.wikipedia.org/wiki/Key_exchange">key exchange</a> to exchange SSL certificates. The client verifies the key/certificate and sends one of its own. After this, an encrypted <a href="https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake">handshake</a> is initiated to confirm whether the encryption and transfer are working correctly.</p>
<p>Once the handshake completes successfully, normal HTTP communication is continued, which is encrypted after that. This is a very high-level overview of the key exchange, which is beyond this module&#39;s scope.</p>
<p>Note: Depending on the circumstances, an attacker may be able to perform an HTTP downgrade attack, which downgrades HTTPS communication to HTTP, making the data transferred in clear-text. This is done by setting up a Man-In-The-Middle (MITM) proxy to transfer all traffic through the attacker&#39;s host without the user&#39;s knowledge. However, most modern browsers, servers, and web applications protect against this attack.</p>
<hr>
<h3 id="curl-for-https">cURL for HTTPS</h3>
<p>cURL should automatically handle all HTTPS communication standards and perform a secure handshake and then encrypt and decrypt data automatically. However, if we ever contact a website with an invalid SSL certificate or an outdated one, then cURL by default would not proceed with the communication to protect against the earlier mentioned MITM attacks:</p>
<p>Hypertext Transfer Protocol Secure (HTTPS)</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ curl https:/</span>/inlanefreight.com
<span class="hljs-symbol">
curl:</span> (<span class="hljs-number">60</span>) SSL certificate <span class="hljs-string">problem:</span> Invalid certificate chain
More details <span class="hljs-string">here:</span> <span class="hljs-string">https:</span><span class="hljs-comment">//curl.haxx.se/docs/sslcerts.html</span>
...SNIP...
</code></pre>
<p>Modern web browsers would do the same, warning the user against visiting a website with an invalid SSL certificate.</p>
<p>We may face such an issue when testing a local web application or with a web application hosted for practice purposes, as such web applications may not yet have implemented a valid SSL certificate. To skip the certificate check with cURL, we can use the <code>-k</code> flag:</p>
<p>Hypertext Transfer Protocol Secure (HTTPS)</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ curl -k https://inlanefreight.com

<span class="hljs-meta">&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
...SNIP...
</code></pre>
<p>As we can see, the request went through this time, and we received the response data.</p>
<h2 id="http-requests-and-responses">HTTP Requests and Responses</h2>
<p>HTTP communications mainly consist of an HTTP request and an HTTP response. An HTTP request is made by the client (e.g. cURL/browser), and is processed by the server (e.g. web server). The requests contain all of the details we require from the server, including the resource (e.g. URL, path, parameters), any request data, headers or options we specify, and many other options we will discuss throughout this module.</p>
<p>Once the server receives the HTTP request, it processes it and responds by sending the HTTP response, which contains the response code, as discussed in a later section, and may contain the resource data if the requester has access to it.</p>
<hr>
<h3 id="http-request">HTTP Request</h3>
<p>Let&#39;s start by examining the following example HTTP request:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/35/raw_request.png" alt="raw\_request"></p>
<p>The image above shows an HTTP GET request to the URL:</p>
<ul>
<li><code>http://inlanefreight.com/users/login.html</code></li>
</ul>
<p>The first line of any HTTP request contains three main fields &#39;separated by spaces&#39;:</p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Method</code></td>
<td><code>GET</code></td>
<td>The HTTP method or verb, which specifies the type of action to perform.</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>/users/login.html</code></td>
<td>The path to the resource being accessed. This field can also be suffixed with a query string (e.g. <code>?username=user</code>).</td>
</tr>
<tr>
<td><code>Version</code></td>
<td><code>HTTP/1.1</code></td>
<td>The third and final field is used to denote the HTTP version.</td>
</tr>
</tbody>
</table>
<p>The next set of lines contain HTTP header value pairs, like <code>Host</code>, <code>User-Agent</code>, <code>Cookie</code>, and many other possible headers. These headers are used to specify various attributes of a request. The headers are terminated with a new line, which is necessary for the server to validate the request. Finally, a request may end with the request body and data.</p>
<p>Note: HTTP version 1.X sends requests as clear-text, and uses a new-line character to separate different fields and different requests. HTTP version 2.X, on the other hand, sends requests as binary data in a dictionary form.</p>
<hr>
<h3 id="http-response">HTTP Response</h3>
<p>Once the server processes our request, it sends its response. The following is an example HTTP response:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/35/raw_response.png" alt="raw\_response"></p>
<p>The first line of an HTTP response contains two fields separated by spaces. The first being the <code>HTTP version</code> (e.g. <code>HTTP/1.1</code>), and the second denotes the <code>HTTP response code</code> (e.g. <code>200 OK</code>).</p>
<p>Response codes are used to determine the request&#39;s status, as will be discussed in a later section. After the first line, the response lists its headers, similar to an HTTP request. Both request and response headers are discussed in the next section.</p>
<p>Finally, the response may end with a response body, which is separated by a new line after the headers. The response body is usually defined as <code>HTML</code> code. However, it can also respond with other code types such as <code>JSON</code>, website resources such as images, style sheets or scripts, or even a document such as a PDF document hosted on the webserver.</p>
<hr>
<h3 id="curl">cURL</h3>
<p>In our earlier examples with cURL, we only specified the URL and got the response body in return. However, cURL also allows us to preview the full HTTP request and the full HTTP response, which can become very handy when performing web penetration tests or writing exploits. To view the full HTTP request and response, we can simply add the <code>-v</code> verbose flag to our earlier commands, and it should print both the request and response:</p>
<p>HTTP Requests and Responses</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ curl inlanefreight.com -v

*   Trying SERVER_IP:<span class="hljs-number">80.</span>..
* TCP_NODELAY <span class="hljs-keyword">set</span>
* Connected <span class="hljs-keyword">to</span> inlanefreight.com (SERVER_IP) port <span class="hljs-number">80</span> (<span class="hljs-meta">#0)</span>
&gt; <span class="hljs-keyword">GET</span> / HTTP/<span class="hljs-number">1.1</span>
&gt; Host: inlanefreight.com
&gt; User-Agent: curl/<span class="hljs-number">7.65</span><span class="hljs-number">.3</span>
&gt; Accept: */*
&gt; Connection: close
&gt; 
* Mark bundle <span class="hljs-keyword">as</span> <span class="hljs-keyword">not</span> supporting multiuse
&lt; HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">401</span> Unauthorized
&lt; <span class="hljs-built_in">Date</span>: Tue, <span class="hljs-number">21</span> Jul <span class="hljs-number">2020</span> <span class="hljs-number">05</span>:<span class="hljs-number">20</span>:<span class="hljs-number">15</span> GMT
&lt; Server: Apache/X.Y.ZZ (Ubuntu)
&lt; WWW-Authenticate: Basic realm=<span class="hljs-string">"Restricted Content"</span>
&lt; Content-Length: <span class="hljs-number">464</span>
&lt; Content-Type: <span class="hljs-keyword">text</span>/html; charset=iso<span class="hljs-number">-8859</span><span class="hljs-number">-1</span>
&lt; 
&lt;!DOCTYPE HTML <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">"-//IETF//DTD HTML 2.0//EN"</span>&gt;
&lt;html&gt;&lt;head&gt;

...SNIP...
</code></pre>
<p>As we can see, this time, we get the full HTTP request and response. The request simply sent <code>GET / HTTP/1.1</code> along with the <code>Host</code>, <code>User-Agent</code> and <code>Accept</code> headers. In return, the HTTP response contained the <code>HTTP/1.1 401 Unauthorized</code>, which indicates that we do not have access over the requested resource, as we will see in an upcoming section. Similar to the request, the response also contained several headers sent by the server, including <code>Date</code>, <code>Content-Length</code>, and <code>Content-Type</code>. Finally, the response contained the response body in HTML, which is the same one we received earlier when using cURL without the <code>-v</code> flag.</p>
<p>Exercise: The <code>-vvv</code> flag shows an even more verbose output. Try to use this flag to see what extra request and response details get displayed with it.</p>
<hr>
<h3 id="browser-devtools">Browser DevTools</h3>
<p>Most modern web browsers come with built-in developer tools (<code>DevTools</code>), which are mainly intended for developers to test their web applications. However, as web penetration testers, these tools can be a vital asset in any web assessment we perform, as a browser (and its DevTools) are among the assets we are most likely to have in every web assessment exercise. In this module, we will also discuss how to utilize some of the basic browser devtools to assess and monitor different types of web requests.</p>
<p>Whenever we visit any website or access any web application, our browser sends multiple web requests and handles multiple HTTP responses to render the final view we see in the browser window. To open the browser devtools in either Chrome or Firefox, we can click [<code>CTRL+SHIFT+I</code>] or simply click [<code>F12</code>]. The devtools contain multiple tabs, each of which has its own use. We will mostly be focusing on the <code>Network</code> tab in this module, as it is responsible for web requests.</p>
<p>If we click on the Network tab and refresh the page, we should be able to see the list of requests sent by the page:</p>
<figure><img src="../../.gitbook/assets/image (334).png" alt=""><figcaption></figcaption></figure>

<p>As we can see, the devtools show us at a glance the response status (i.e. response code), the request method used (<code>GET</code>), the requested resource (i.e. URL/domain), along with the requested path. Furthermore, we can use <code>Filter URLs</code> to search for a specific request, in case the website loads too many to go through.</p>
<h2 id="http-headers">HTTP Headers</h2>
<p>We have seen examples of HTTP requests and response headers in the previous section. Such HTTP headers pass information between the client and the server. Some headers are only used with either requests or responses, while some other general headers are common to both.</p>
<p>Headers can have one or multiple values, appended after the header name and separated by a colon. We can divide headers into the following categories:</p>
<ol>
<li><code>General Headers</code></li>
<li><code>Entity Headers</code></li>
<li><code>Request Headers</code></li>
<li><code>Response Headers</code></li>
<li><code>Security Headers</code></li>
</ol>
<p>Let&#39;s discuss each of these categories.</p>
<hr>
<h3 id="general-headers">General Headers</h3>
<p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html">General headers</a> are used in both HTTP requests and responses. They are contextual and are used to <code>describe the message rather than its contents</code>.</p>
<table>
<thead>
<tr>
<th><strong>Header</strong></th>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Date</code></td>
<td><code>Date: Wed, 16 Feb 2022 10:38:44 GMT</code></td>
<td>Holds the date and time at which the message originated. It&#39;s preferred to convert the time to the standard <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time">UTC</a> time zone.</td>
</tr>
<tr>
<td><code>Connection</code></td>
<td><code>Connection: close</code></td>
<td>Dictates if the current network connection should stay alive after the request finishes. Two commonly used values for this header are <code>close</code> and <code>keep-alive</code>. The <code>close</code> value from either the client or server means that they would like to terminate the connection, while the <code>keep-alive</code> header indicates that the connection should remain open to receive more data and input.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="entity-headers">Entity Headers</h3>
<p>Similar to general headers, <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html">Entity Headers</a> can be <code>common to both the request and response</code>. These headers are used to <code>describe the content</code> (entity) transferred by a message. They are usually found in responses and POST or PUT requests.</p>
<table>
<thead>
<tr>
<th><strong>Header</strong></th>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Content-Type</code></td>
<td><code>Content-Type: text/html</code></td>
<td>Used to describe the type of resource being transferred. The value is automatically added by the browsers on the client-side and returned in the server response. The <code>charset</code> field denotes the encoding standard, such as <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>.</td>
</tr>
<tr>
<td><code>Media-Type</code></td>
<td><code>Media-Type: application/pdf</code></td>
<td>The <code>media-type</code> is similar to <code>Content-Type</code>, and describes the data being transferred. This header can play a crucial role in making the server interpret our input. The <code>charset</code> field may also be used with this header.</td>
</tr>
<tr>
<td><code>Boundary</code></td>
<td><code>boundary=&quot;b4e4fbd93540&quot;</code></td>
<td>Acts as a marker to separate content when there is more than one in the same message. For example, within a form data, this boundary gets used as <code>--b4e4fbd93540</code> to separate different parts of the form.</td>
</tr>
<tr>
<td><code>Content-Length</code></td>
<td><code>Content-Length: 385</code></td>
<td>Holds the size of the entity being passed. This header is necessary as the server uses it to read data from the message body, and is automatically generated by the browser and tools like cURL.</td>
</tr>
<tr>
<td><code>Content-Encoding</code></td>
<td><code>Content-Encoding: gzip</code></td>
<td>Data can undergo multiple transformations before being passed. For example, large amounts of data can be compressed to reduce the message size. The type of encoding being used should be specified using the <code>Content-Encoding</code> header.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="request-headers">Request Headers</h3>
<p>The client sends <a href="https://tools.ietf.org/html/rfc2616">Request Headers</a> in an HTTP transaction. These headers are <code>used in an HTTP request and do not relate to the content</code> of the message. The following headers are commonly seen in HTTP requests.</p>
<table>
<thead>
<tr>
<th><strong>Header</strong></th>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Host</code></td>
<td><code>Host: www.inlanefreight.com</code></td>
<td>Used to specify the host being queried for the resource. This can be a domain name or an IP address. HTTP servers can be configured to host different websites, which are revealed based on the hostname. This makes the host header an important enumeration target, as it can indicate the existence of other hosts on the target server.</td>
</tr>
<tr>
<td><code>User-Agent</code></td>
<td><code>User-Agent: curl/7.77.0</code></td>
<td>The <code>User-Agent</code> header is used to describe the client requesting resources. This header can reveal a lot about the client, such as the browser, its version, and the operating system.</td>
</tr>
<tr>
<td><code>Referer</code></td>
<td><code>Referer: http://www.inlanefreight.com/</code></td>
<td>Denotes where the current request is coming from. For example, clicking a link from Google search results would make <code>https://google.com</code> the referer. Trusting this header can be dangerous as it can be easily manipulated, leading to unintended consequences.</td>
</tr>
<tr>
<td><code>Accept</code></td>
<td><code>Accept: */*</code></td>
<td>The <code>Accept</code> header describes which media types the client can understand. It can contain multiple media types separated by commas. The <code>*/*</code> value signifies that all media types are accepted.</td>
</tr>
<tr>
<td><code>Cookie</code></td>
<td><code>Cookie: PHPSESSID=b4e4fbd93540</code></td>
<td>Contains cookie-value pairs in the format <code>name=value</code>. A <a href="https://en.wikipedia.org/wiki/HTTP_cookie">cookie</a> is a piece of data stored on the client-side and on the server, which acts as an identifier. These are passed to the server per request, thus maintaining the client&#39;s access. Cookies can also serve other purposes, such as saving user preferences or session tracking. There can be multiple cookies in a single header separated by a semi-colon.</td>
</tr>
<tr>
<td><code>Authorization</code></td>
<td><code>Authorization: BASIC cGFzc3dvcmQK</code></td>
<td>Another method for the server to identify clients. After successful authentication, the server returns a token unique to the client. Unlike cookies, tokens are stored only on the client-side and retrieved by the server per request. There are multiple types of authentication types based on the webserver and application type used.</td>
</tr>
</tbody>
</table>
<p>A complete list of request headers and their usage can be found <a href="https://tools.ietf.org/html/rfc7231#section-5">here</a>.</p>
<hr>
<h3 id="response-headers">Response Headers</h3>
<p><a href="https://tools.ietf.org/html/rfc7231#section-6">Response Headers</a> can be <code>used in an HTTP response and do not relate to the content</code>. Certain response headers such as <code>Age</code>, <code>Location</code>, and <code>Server</code> are used to provide more context about the response. The following headers are commonly seen in HTTP responses.</p>
<table>
<thead>
<tr>
<th><strong>Header</strong></th>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Server</code></td>
<td><code>Server: Apache/2.2.14 (Win32)</code></td>
<td>Contains information about the HTTP server, which processed the request. It can be used to gain information about the server, such as its version, and enumerate it further.</td>
</tr>
<tr>
<td><code>Set-Cookie</code></td>
<td><code>Set-Cookie: PHPSESSID=b4e4fbd93540</code></td>
<td>Contains the cookies needed for client identification. Browsers parse the cookies and store them for future requests. This header follows the same format as the <code>Cookie</code> request header.</td>
</tr>
<tr>
<td><code>WWW-Authenticate</code></td>
<td><code>WWW-Authenticate: BASIC realm=&quot;localhost&quot;</code></td>
<td>Notifies the client about the type of authentication required to access the requested resource.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="security-headers">Security Headers</h3>
<p>Finally, we have <a href="https://owasp.org/www-project-secure-headers/">Security Headers</a>. With the increase in the variety of browsers and web-based attacks, defining certain headers that enhanced security was necessary. HTTP Security headers are <code>a class of response headers used to specify certain rules and policies</code> to be followed by the browser while accessing the website.</p>
<table>
<thead>
<tr>
<th><strong>Header</strong></th>
<th><strong>Example</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Content-Security-Policy</code></td>
<td><code>Content-Security-Policy: script-src &#39;self&#39;</code></td>
<td>Dictates the website&#39;s policy towards externally injected resources. This could be JavaScript code as well as script resources. This header instructs the browser to accept resources only from certain trusted domains, hence preventing attacks such as <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">Cross-site scripting (XSS)</a>.</td>
</tr>
<tr>
<td><code>Strict-Transport-Security</code></td>
<td><code>Strict-Transport-Security: max-age=31536000</code></td>
<td>Prevents the browser from accessing the website over the plaintext HTTP protocol, and forces all communication to be carried over the secure HTTPS protocol. This prevents attackers from sniffing web traffic and accessing protected information such as passwords or other sensitive data.</td>
</tr>
<tr>
<td><code>Referrer-Policy</code></td>
<td><code>Referrer-Policy: origin</code></td>
<td>Dictates whether the browser should include the value specified via the <code>Referer</code> header or not. It can help in avoiding disclosing sensitive URLs and information while browsing the website.</td>
</tr>
</tbody>
</table>
<p>Note: This section only mentions a small subset of commonly seen HTTP headers. There are many other contextual headers that can be used in HTTP communications. It&#39;s also possible for applications to define custom headers based on their requirements. A complete list of standard HTTP headers can be found <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">here</a>.</p>
<hr>
<h3 id="curl">cURL</h3>
<p>In the previous section, we saw how using the <code>-v</code> flag with cURL shows us the full details of the HTTP request and response. If we were only interested in seeing the response headers, then we can use the <code>-I</code> flag to send a <code>HEAD</code> request and only display the response headers. Furthermore, we can use the <code>-i</code> flag to display both the headers and the response body (e.g. HTML code). The difference between the two is that <code>-I</code> sends a <code>HEAD</code> request (as will see in the next section), while <code>-i</code> sends any request we specify and prints the headers as well.</p>
<p>The following command shows an example output of using the <code>-I</code> flag:</p>
<p>HTTP Headers</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ curl -I https:/</span>/www.inlanefreight.com
<span class="hljs-symbol">
Host:</span> www.inlanefreight.com
User-<span class="hljs-string">Agent:</span> Mozilla<span class="hljs-regexp">/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/</span><span class="hljs-number">605.1</span><span class="hljs-number">.15</span> (KHTML, like Gecko)
<span class="hljs-string">Cookie:</span> cookie1=<span class="hljs-number">298</span>zf09hf012fh2; cookie2=u32t4o3tb3gg4
<span class="hljs-string">Accept:</span> text/plain
<span class="hljs-string">Referer:</span> <span class="hljs-string">https:</span><span class="hljs-comment">//www.inlanefreight.com/</span>
<span class="hljs-string">Authorization:</span> BASIC cGFzc3dvcmQK
<span class="hljs-symbol">
Date:</span> Sun, <span class="hljs-number">06</span> Aug <span class="hljs-number">2020</span> <span class="hljs-number">08</span>:<span class="hljs-number">49</span>:<span class="hljs-number">37</span> GMT
<span class="hljs-string">Connection:</span> keep-alive
Content-<span class="hljs-string">Length:</span> <span class="hljs-number">26012</span>
Content-<span class="hljs-string">Type:</span> text/html; charset=ISO<span class="hljs-number">-8859</span><span class="hljs-number">-4</span>
Content-<span class="hljs-string">Encoding:</span> gzip
<span class="hljs-string">Server:</span> Apache/<span class="hljs-number">2.2</span><span class="hljs-number">.14</span> (Win32)
Set-<span class="hljs-string">Cookie:</span> name1=value1,name2=value2; Expires=Wed, <span class="hljs-number">09</span> Jun <span class="hljs-number">2021</span> <span class="hljs-number">10</span>:<span class="hljs-number">18</span>:<span class="hljs-number">14</span> GMT
WWW-<span class="hljs-string">Authenticate:</span> BASIC realm=<span class="hljs-string">"localhost"</span>
Content-Security-<span class="hljs-string">Policy:</span> script-src <span class="hljs-string">'self'</span>
Strict-Transport-<span class="hljs-string">Security:</span> max-age=<span class="hljs-number">31536000</span>
Referrer-<span class="hljs-string">Policy:</span> origin
</code></pre>
<p>Exercise: Try to go through all of the above headers, and see whether you can recall the usage for each of them.</p>
<p>In addition to viewing headers, cURL also allows us to set request headers with the <code>-H</code> flag, as we will see in a later section. Some headers, like the <code>User-Agent</code> or <code>Cookie</code> headers, have their own flags. For example, we can use the <code>-A</code> to set our <code>User-Agent</code>, as follows:</p>
<p>HTTP Headers</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ curl https://www.inlanefreight.com -A 'Mozilla/5.0'

<span class="hljs-meta">&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
...SNIP...
</code></pre>
<p>Exercise: Try to use the <code>-I</code> or the <code>-v</code> flags with the above example, to ensure that we did change our User-Agent with the <code>-A</code> flag.</p>
<hr>
<h3 id="browser-devtools">Browser DevTools</h3>
<p>Finally, let&#39;s see how we can preview the HTTP headers using the browser devtools. Just as we did in the previous section, we can go to the <code>Network</code> tab to view the different requests made by the page. We can click on any of the requests to view its details:</p>
<figure><img src="../../.gitbook/assets/image (335).png" alt=""><figcaption></figcaption></figure>

<p>In the first <code>Headers</code> tab, we see both the HTTP request and HTTP response headers. The devtools automatically arrange the headers into sections, but we can click on the <code>Raw</code> button to view their details in their raw format. Furthermore, we can check the <code>Cookies</code> tab to see any cookies used by the request, as discussed in an upcoming section.</p>
<h2 id="http-methods-and-codes">HTTP Methods and Codes</h2>
<p>HTTP supports multiple methods for accessing a resource. In the HTTP protocol, several request methods allow the browser to send information, forms, or files to the server. These methods are used, among other things, to tell the server how to process the request we send and how to reply.</p>
<p>We saw different HTTP methods used in the HTTP requests we tested in the previous sections. With cURL, if we use <code>-v</code> to preview the full request, the first line contains the HTTP method (e.g. <code>GET / HTTP/1.1</code>), while with browser devtools, the HTTP method is shown in the <code>Method</code> column. Furthermore, the response headers also contain the HTTP response code, which states the status of processing our HTTP request.</p>
<hr>
<h3 id="request-methods">Request Methods</h3>
<p>The following are some of the commonly used methods:</p>
<table>
<thead>
<tr>
<th><strong>Method</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GET</code></td>
<td>Requests a specific resource. Additional data can be passed to the server via query strings in the URL (e.g. <code>?param=value</code>).</td>
</tr>
<tr>
<td><code>POST</code></td>
<td>Sends data to the server. It can handle multiple types of input, such as text, PDFs, and other forms of binary data. This data is appended in the request body present after the headers. The POST method is commonly used when sending information (e.g. forms/logins) or uploading data to a website, such as images or documents.</td>
</tr>
<tr>
<td><code>HEAD</code></td>
<td>Requests the headers that would be returned if a GET request was made to the server. It doesn&#39;t return the request body and is usually made to check the response length before downloading resources.</td>
</tr>
<tr>
<td><code>PUT</code></td>
<td>Creates new resources on the server. Allowing this method without proper controls can lead to uploading malicious resources.</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>Deletes an existing resource on the webserver. If not properly secured, can lead to Denial of Service (DoS) by deleting critical files on the web server.</td>
</tr>
<tr>
<td><code>OPTIONS</code></td>
<td>Returns information about the server, such as the methods accepted by it.</td>
</tr>
<tr>
<td><code>PATCH</code></td>
<td>Applies partial modifications to the resource at the specified location.</td>
</tr>
</tbody>
</table>
<p>The list only highlights a few of the most commonly used HTTP methods. The availability of a particular method depends on the server as well as the application configuration. For a full list of HTTP methods, you can visit this <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">link</a>.</p>
<p>Note: Most modern web applications mainly rely on the <code>GET</code> and <code>POST</code> methods. However, any web application that utilizes REST APIs also rely on <code>PUT</code> and <code>DELETE</code>, which are used to update and delete data on the API endpoint, respectively. Refer to the <a href="https://academy.hackthebox.com/module/details/75">Introduction to Web Applications</a> module for more details.</p>
<hr>
<h3 id="response-codes">Response Codes</h3>
<p>HTTP status codes are used to tell the client the status of their request. An HTTP server can return five types of response codes:</p>
<table>
<thead>
<tr>
<th><strong>Type</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1xx</code></td>
<td>Provides information and does not affect the processing of the request.</td>
</tr>
<tr>
<td><code>2xx</code></td>
<td>Returned when a request succeeds.</td>
</tr>
<tr>
<td><code>3xx</code></td>
<td>Returned when the server redirects the client.</td>
</tr>
<tr>
<td><code>4xx</code></td>
<td>Signifies improper requests <code>from the client</code>. For example, requesting a resource that doesn&#39;t exist or requesting a bad format.</td>
</tr>
<tr>
<td><code>5xx</code></td>
<td>Returned when there is some problem <code>with the HTTP server</code> itself.</td>
</tr>
</tbody>
</table>
<p>The following are some of the commonly seen examples from each of the above HTTP method types:</p>
<table>
<thead>
<tr>
<th><strong>Code</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>200 OK</code></td>
<td>Returned on a successful request, and the response body usually contains the requested resource.</td>
</tr>
<tr>
<td><code>302 Found</code></td>
<td>Redirects the client to another URL. For example, redirecting the user to their dashboard after a successful login.</td>
</tr>
<tr>
<td><code>400 Bad Request</code></td>
<td>Returned on encountering malformed requests such as requests with missing line terminators.</td>
</tr>
<tr>
<td><code>403 Forbidden</code></td>
<td>Signifies that the client doesn&#39;t have appropriate access to the resource. It can also be returned when the server detects malicious input from the user.</td>
</tr>
<tr>
<td><code>404 Not Found</code></td>
<td>Returned when the client requests a resource that doesn&#39;t exist on the server.</td>
</tr>
<tr>
<td><code>500 Internal Server Error</code></td>
<td>Returned when the server cannot process the request.</td>
</tr>
</tbody>
</table>
<p>For a full list of standard HTTP response codes, you can visit this <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">link</a>. Apart from the standard HTTP codes, various servers and providers such as <a href="https://support.cloudflare.com/hc/en-us/articles/115003014432-HTTP-Status-Codes">Cloudflare</a> or <a href="https://docs.aws.amazon.com/AmazonSimpleDB/latest/DeveloperGuide/APIError.html">AWS</a> implement their own codes.</p>
<h2 id="get">GET</h2>
<p>Whenever we visit any URL, our browsers default to a GET request to obtain the remote resources hosted at that URL. Once the browser receives the initial page it is requesting; it may send other requests using various HTTP methods. This can be observed through the Network tab in the browser devtools, as seen in the previous section.</p>
<p>Exercise: Pick any website of your choosing, and monitor the Network tab in the browser devtools as you visit it to understand what the page is performing. This technique can be used to thoroughly understand how a web application interacts with its backend, which can be an essential exercise for any web application assessment or bug bounty exercise.</p>
<hr>
<h3 id="http-basic-auth">HTTP Basic Auth</h3>
<p>When we visit the exercise found at the end of this section, it prompts us to enter a username and a password. Unlike the usual login forms, which utilize HTTP parameters to validate the user credentials (e.g. POST request), this type of authentication utilizes a <code>basic HTTP authentication</code>, which is handled directly by the webserver to protect a specific page/directory, without directly interacting with the web application.</p>
<p>To access the page, we have to enter a valid pair of credentials, which are <code>admin</code>:<code>admin</code> in this case:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/35/http_auth_login.jpg" alt=""></p>
<p>Once we enter the credentials, we would get access to the page:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/35/http_auth_index.jpg" alt=""></p>
<p>Let&#39;s try to access the page with cURL, and we&#39;ll add <code>-i</code> to view the response headers:</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ curl -i http:/</span><span class="hljs-regexp">/&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">401</span> Authorization Required
<span class="hljs-string">Date:</span> Mon, <span class="hljs-number">21</span> Feb <span class="hljs-number">2022</span> <span class="hljs-number">13</span>:<span class="hljs-number">11</span>:<span class="hljs-number">46</span> GMT
<span class="hljs-string">Server:</span> Apache/<span class="hljs-number">2.4</span><span class="hljs-number">.41</span> (Ubuntu)
Cache-<span class="hljs-string">Control:</span> no-cache, must-revalidate, max-age=<span class="hljs-number">0</span>
WWW-<span class="hljs-string">Authenticate:</span> Basic realm=<span class="hljs-string">"Access denied"</span>
Content-<span class="hljs-string">Length:</span> <span class="hljs-number">13</span>
Content-<span class="hljs-string">Type:</span> text/html; charset=UTF<span class="hljs-number">-8</span>

Access denied
</code></pre>
<p>As we can see, we get <code>Access denied</code> in the response body, and we also get <code>Basic realm=&quot;Access denied&quot;</code> in the <code>WWW-Authenticate</code> header, which confirms that this page indeed uses <code>basic HTTP auth</code>, as discussed in the Headers section. To provide the credentials through cURL, we can use the <code>-u</code> flag, as follows:</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ curl -u admin:admin http://<span class="hljs-tag">&lt;<span class="hljs-name">SERVER_IP</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">PORT</span>&gt;</span>/

<span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
...SNIP...
</code></pre>
<p>This time we do get the page in the response. There is another method we can provide the <code>basic HTTP auth</code> credentials, which is directly through the URL as (<code>username:password@URL</code>), as we discussed in the first section. If we try the same with cURL or our browser, we do get access to the page as well:</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ curl http://admin:admin@<span class="hljs-tag">&lt;<span class="hljs-name">SERVER_IP</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">PORT</span>&gt;</span>/

<span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
...SNIP...
</code></pre>
<p>We may also try visiting the same URL on a browser, and we should get authenticated as well.</p>
<p>Exercise: Try to view the response headers by adding -i to the above request, and see how an authenticated response differs from an unauthenticated one.</p>
<hr>
<h3 id="http-authorization-header">HTTP Authorization Header</h3>
<p>If we add the <code>-v</code> flag to either of our earlier cURL commands:</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ curl -v http://admin:admin@<span class="hljs-variable">&lt;SERVER_IP&gt;</span>:<span class="hljs-variable">&lt;PORT&gt;</span>/

*   Trying <span class="hljs-variable">&lt;SERVER_IP&gt;</span>:<span class="hljs-variable">&lt;PORT&gt;</span>...
* Connected <span class="hljs-keyword">to</span> <span class="hljs-variable">&lt;SERVER_IP&gt;</span> (<span class="hljs-variable">&lt;SERVER_IP&gt;</span>) <span class="hljs-keyword">port</span> PORT (<span class="hljs-comment">#0)</span>
* Server auth using Basic with <span class="hljs-keyword">user</span> 'admin'
&gt; GET / HTTP/<span class="hljs-number">1.1</span>
&gt; Host: <span class="hljs-variable">&lt;SERVER_IP&gt;</span>
&gt; Authorization: Basic YWRtaW46YWRtaW4=
&gt; User-Agent: curl/<span class="hljs-number">7.77</span>.<span class="hljs-number">0</span>
&gt; Accept: */*
&gt; 
* Mark bundle as not supporting multiuse
<span class="hljs-variable">&lt; HTTP/1.1 200 OK
&lt; Date: Mon, 21 Feb 2022 13:19:57 GMT
&lt; Server: Apache/2.4.41 (Ubuntu)
&lt; Cache-Control: no-store, no-cache, must-revalidate
&lt; Expires: Thu, 19 Nov 1981 08:52:00 GMT
&lt; Pragma: no-cache
&lt; Vary: Accept-Encoding
&lt; Content-Length: 1453
&lt; Content-Type: text/html; charset=UTF-8
&lt; 

&lt;!DOCTYPE html&gt;</span>
<span class="hljs-variable">&lt;html lang="en"&gt;</span>

<span class="hljs-variable">&lt;head&gt;</span>
...SNIP...
</code></pre>
<p>As we are using <code>basic HTTP auth</code>, we see that our HTTP request sets the <code>Authorization</code> header to <code>Basic YWRtaW46YWRtaW4=</code>, which is the base64 encoded value of <code>admin:admin</code>. If we were using a modern method of authentication (e.g. <code>JWT</code>), the <code>Authorization</code> would be of type <code>Bearer</code> and would contain a longer encrypted token.</p>
<p>Let&#39;s try to manually set the <code>Authorization</code>, without supplying the credentials, to see if it does allow us access to the page. We can set the header with the <code>-H</code> flag, and will use the same value from the above HTTP request. We can add the <code>-H</code> flag multiple times to specify multiple headers:</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ curl -H 'Authorization: Basic YWRtaW46YWRtaW4=' http://<span class="hljs-tag">&lt;<span class="hljs-name">SERVER_IP</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">PORT</span>&gt;</span>/

<span class="hljs-meta">&lt;!DOCTYPE html
&lt;html lang="en"&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
...SNIP...
</code></pre>
<p>As we see, this also gave us access to the page. These are a few methods we can use to authenticate to the page. Most modern web applications use login forms built with the back-end scripting language (e.g. PHP), which utilize HTTP POST requests to authenticate the users and then return a cookie to maintain their authentication.</p>
<hr>
<h3 id="get-parameters">GET Parameters</h3>
<p>Once we are authenticated, we get access to a <code>City Search</code> function, in which we can enter a search term and get a list of matching cities:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/35/http_auth_index.jpg" alt=""></p>
<p>As the page returns our results, it may be contacting a remote resource to obtain the information, and then display them on the page. To verify this, we can open the browser devtools and go to the Network tab, or use the shortcut [<code>CTRL+SHIFT+E</code>] to get to the same tab. Before we enter our search term and view the requests, we may need to click on the <code>trash</code> icon on the top left, to ensure we clear any previous requests and only monitor newer requests:</p>
<p>After that, we can enter any search term and hit enter, and we will immediately notice a new request being sent to the backend:</p>
<p><img src="../../.gitbook/assets/image (338" alt="">.png&gt;)When we click on the request, it gets sent to <code>search.php</code> with the GET parameter <code>search=le</code> used in the URL. This helps us understand that the search function requests another page for the results.</p>
<p>Now, we can send the same request directly to <code>search.php</code> to get the full search results, though it will probably return them in a specific format (e.g. JSON) without having the HTML layout shown in the above screenshot.</p>
<p>To send a GET request with cURL, we can use the exact same URL seen in the above screenshots since GET requests place their parameters in the URL. However, browser devtools provide a more convenient method of obtaining the cURL command. We can right-click on the request and select <code>Copy&gt;Copy as cURL</code>. Then, we can paste the copied command in our terminal and execute it, and we should get the exact same response:</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ curl <span class="hljs-string">'http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/search.php?search=le'</span> -H <span class="hljs-string">'Authorization: Basic YWRtaW46YWRtaW4='</span>

Leeds (UK)
Leicester (UK)
</code></pre>
<p>Note: The copied command will contain all headers used in the HTTP request. However, we can remove most of them and only keep necessary authentication headers, like the <code>Authorization</code> header.</p>
<p>We can also repeat the exact request right within the browser devtools, by selecting <code>Copy&gt;Copy as Fetch</code>. This will copy the same HTTP request using the JavaScript Fetch library. Then, we can go to the JavaScript console tab by clicking [<code>CTRL+SHIFT+K</code>], paste our Fetch command and hit enter to send the request:</p>
<figure><img src="../../.gitbook/assets/image (336).png" alt=""><figcaption></figcaption></figure>

<p>As we see, the browser sent our request, and we can see the response returned after it. We can click on the response to view its details, expand various details, and read them.</p>
<h2 id="post">POST</h2>
<p>In the previous section, we saw how <code>GET</code> requests may be used by web applications for functionalities like search and accessing pages. However, whenever web applications need to transfer files or move the user parameters from the URL, they utilize <code>POST</code> requests.</p>
<p>Unlike HTTP <code>GET</code>, which places user parameters within the URL, HTTP <code>POST</code> places user parameters within the HTTP Request body. This has three main benefits:</p>
<ul>
<li><code>Lack of Logging</code>: As POST requests may transfer large files (e.g. file upload), it would not be efficient for the server to log all uploaded files as part of the requested URL, as would be the case with a file uploaded through a GET request.</li>
<li><code>Less Encoding Requirements</code>: URLs are designed to be shared, which means they need to conform to characters that can be converted to letters. The POST request places data in the body which can accept binary data. The only characters that need to be encoded are those that are used to separate parameters.</li>
<li><code>More data can be sent</code>: The maximum URL Length varies between browsers (Chrome/Firefox/IE), web servers (IIS, Apache, nginx), Content Delivery Networks (Fastly, Cloudfront, Cloudflare), and even URL Shorteners (bit.ly, amzn.to). Generally speaking, a URL&#39;s lengths should be kept to below 2,000 characters, and so they cannot handle a lot of data.</li>
</ul>
<p>So, let&#39;s see some examples of how POST requests work, and how we can utilize tools like cURL or browser devtools to read and send POST requests.</p>
<hr>
<h3 id="login-forms">Login Forms</h3>
<p>The exercise at the end of this section is similar to the example we saw in the GET section. However, once we visit the web application, we see that it utilizes a PHP login form instead of HTTP basic auth:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/35/web_requests_post_login.jpg" alt=""></p>
<p>If we try to login with <code>admin</code>:<code>admin</code>, we get in and see a similar search function to the one we saw earlier in the GET section:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/35/web_requests_login_search.jpg" alt=""></p>
<p>If we clear the Network tab in our browser devtools and try to log in again, we will see many requests being sent. We can filter the requests by our server IP, so it would only show requests going to the web application&#39;s web server (i.e. filter out external requests), and we will notice the following POST request being sent: <img src="https://academy.hackthebox.com/storage/modules/35/web_requests_login_request.jpg" alt="web\_requests\_login\_request"></p>
<p>We can click on the request, click on the <code>Request</code> tab (which shows the request body), and then click on the <code>Raw</code> button to show the raw request data. We see the following data is being sent as the POST request data:</p>
<pre><code class="lang-bash"><span class="hljs-attr">username</span>=admin&amp;password=admin
</code></pre>
<p>With the request data at hand, we can try to send a similar request with cURL, to see whether this would allow us to login as well. Furthermore, as we did in the previous section, we can simply right-click on the request and select <code>Copy&gt;Copy as cURL</code>. However, it is important to be able to craft POST requests manually, so let&#39;s try to do so.</p>
<p>We will use the <code>-X POST</code> flag to send a <code>POST</code> request. Then, to add our POST data, we can use the <code>-d</code> flag and add the above data after it, as follows:</p>
<pre><code class="lang-shell-session">[!bash!]$ curl -X POST -d <span class="hljs-string">'username=admin&amp;password=admin'</span> http:<span class="hljs-comment">//&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>

..<span class="hljs-selector-class">.SNIP</span>...
        &lt;em&gt;Type <span class="hljs-selector-tag">a</span> city name and hit &lt;strong&gt;Enter&lt;/strong&gt;&lt;/em&gt;
..<span class="hljs-selector-class">.SNIP</span>...
</code></pre>
<p>If we examine the HTML code, we will not see the login form code, but will see the search function code, which indicates that we did indeed get authenticated.</p>
<p>Tip: Many login forms would redirect us to a different page once authenticated (e.g. /dashboard.php). If we want to follow the redirection with cURL, we can use the <code>-L</code> flag.</p>
<hr>
<h3 id="authenticated-cookies">Authenticated Cookies</h3>
<p>If we were successfully authenticated, we should have received a cookie so our browsers can persist our authentication, and we don&#39;t need to login every time we visit the page. We can use the <code>-v</code> or <code>-i</code> flags to view the response, which should contain the <code>Set-Cookie</code> header with our authenticated cookie:</p>
<pre><code class="lang-shell-session">[!bash!]$ curl -X POST -d <span class="hljs-string">'username=admin&amp;password=admin'</span> http:<span class="hljs-comment">//&lt;SERVER_IP&gt;:&lt;PORT&gt;/ -i</span>

HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
<span class="hljs-built_in">Date</span>: 
Server: Apache/<span class="hljs-number">2.4</span>.<span class="hljs-number">41</span> (Ubuntu)
<span class="hljs-built_in">Set</span>-Cookie: PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1; path=/

...SNIP...
        &lt;em&gt;<span class="hljs-built_in">Type</span> a city <span class="hljs-built_in">name</span> <span class="hljs-built_in">and</span> hit &lt;strong&gt;Enter&lt;/strong&gt;&lt;/em&gt;
...SNIP...
</code></pre>
<p>With our authenticated cookie, we should now be able to interact with the web application without needing to provide our credentials every time. To test this, we can set the above cookie with the <code>-b</code> flag in cURL, as follows:</p>
<pre><code class="lang-shell-session">[!bash!]$ curl -<span class="hljs-selector-tag">b</span> <span class="hljs-string">'PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1'</span> http:<span class="hljs-comment">//&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>

..<span class="hljs-selector-class">.SNIP</span>...
        &lt;em&gt;Type <span class="hljs-selector-tag">a</span> city name and hit &lt;strong&gt;Enter&lt;/strong&gt;&lt;/em&gt;
..<span class="hljs-selector-class">.SNIP</span>...
</code></pre>
<p>As we can see, we were indeed authenticated and got to the search function. It is also possible to specify the cookie as a header, as follows:</p>
<pre><code class="lang-bash">curl -H <span class="hljs-string">'Cookie: PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1'</span> <span class="hljs-string">http:</span><span class="hljs-comment">//&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>
</code></pre>
<p>We may also try the same thing with our browsers. Let&#39;s first logout, and then we should get back to the login page. Then, we can go to the <code>Storage</code> tab in the devtools with [<code>SHIFT+F9</code>]. In the <code>Storage</code> tab, we can click on <code>Cookies</code> in the left pane and select our website to view our current cookies. We may or may not have existing cookies, but if we were logged out, then our PHP cookie should not be authenticated, which is why if we get the login form and not the search function: <img src="https://academy.hackthebox.com/storage/modules/35/web_requests_cookies.jpg" alt="web\_requests\_cookies"></p>
<p>Now, let&#39;s try to use our earlier authenticated cookie, and see if we do get in without needing to provide our credentials. To do so, we can simply replace the cookie value with our own. Otherwise, we can right-click on the cookie and select <code>Delete All</code>, and the click on the <code>+</code> icon to add a new cookie. After that, we need to enter the cookie name, which is the part before the <code>=</code> (<code>PHPSESSID</code>), and then the cookie value, which is the part after the <code>=</code> (<code>c1nsa6op7vtk7kdis7bcnbadf1</code>). Then, once our cookie is set, we can refresh the page, and we will see that we do indeed get authenticated without needing to login, simply by using an authenticated cookie: <img src="https://academy.hackthebox.com/storage/modules/35/web_requests_auth_cookie.jpg" alt="web\_requests\_auth\_cookie"></p>
<p>As we can see, having a valid cookie may be enough to get authenticated into many web applications. This can be an essential part of some web attacks, like Cross-Site Scripting.</p>
<hr>
<h3 id="json-data">JSON Data</h3>
<p>Finally, let&#39;s see what requests get sent when we interact with the <code>City Search</code> function. To do so, we will go to the Network tab in the browser devtools, and then click on the trash icon to clear all requests. Then, we can make any search query to see what requests get sent: <img src="https://academy.hackthebox.com/storage/modules/35/web_requests_search_request.jpg" alt="web\_requests\_search\_request"></p>
<p>As we can see, the search form sends a POST request to <code>search.php</code>, with the following data:</p>
<pre><code class="lang-json">{<span class="hljs-attr">"search"</span>:<span class="hljs-string">"london"</span>}
</code></pre>
<p>The POST data appear to be in JSON format, so our request must have specified the <code>Content-Type</code> header to be <code>application/json</code>. We can confirm this by right-clicking on the request, and selecting <code>Copy&gt;Copy Request Headers</code>:</p>
<pre><code class="lang-bash"><span class="hljs-keyword">POST</span> <span class="hljs-string">/search.php</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: server_ip
<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:97.0) Gecko/20100101 Firefox/97.0
<span class="hljs-attribute">Accept</span>: */*
<span class="hljs-attribute">Accept-Language</span>: en-US,en;q=0.5
<span class="hljs-attribute">Accept-Encoding</span>: gzip, deflate
<span class="hljs-attribute">Referer</span>: http://server_ip/index.php
<span class="hljs-attribute">Content-Type</span>: application/json
<span class="hljs-attribute">Origin</span>: http://server_ip
<span class="hljs-attribute">Content-Length</span>: 19
<span class="hljs-attribute">DNT</span>: 1
<span class="hljs-attribute">Connection</span>: keep-alive
<span class="hljs-attribute">Cookie</span>: PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1
</code></pre>
<p>Indeed, we do have <code>Content-Type: application/json</code>. Let&#39;s try to replicate this request as we did earlier, but include both the cookie and content-type headers, and send our request to <code>search.php</code>:</p>
<pre><code class="lang-shell-session">[<span class="hljs-name">!bash!</span>]$ curl -X POST -d '{<span class="hljs-string">"search"</span>:<span class="hljs-string">"london"</span>}' -b <span class="hljs-symbol">'PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1</span>' -H <span class="hljs-symbol">'Content-Type:</span> application/json' http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/search.php
[<span class="hljs-string">"London (UK)"</span>]
</code></pre>
<p>As we can see, we were able to interact with the search function directly without needing to login or interact with the web application front-end. This can be an essential skill when performing web application assessments or bug bounty exercises, as it is much faster to test web applications this way.</p>
<p>Exercise: Try to repeat the above request without adding the cookie or content-type headers, and see how the web app would act differently.</p>
<p>Finally, let&#39;s try to repeat the same above request by using <code>Fetch</code>, as we did in the previous section. We can right-click on the request and select <code>Copy&gt;Copy as Fetch</code>, and then go to the <code>Console</code> tab and execute our code there: <img src="https://academy.hackthebox.com/storage/modules/35/web_requests_fetch_post.jpg" alt="web\_requests\_fetch\_post"></p>
<p>Our request successfully returns the same data we got with cURL. <code>Try to search for different cities by directly interacting with the search.php through Fetch or cURL.</code></p>
<h2 id="crud-api">CRUD API</h2>
<p>We saw examples of a <code>City Search</code> web application that uses PHP parameters to search for a city name in the previous sections. This section will look at how such a web application may utilize APIs to perform the same thing, and we will directly interact with the API endpoint.</p>
<hr>
<h3 id="apis">APIs</h3>
<p>There are several types of APIs. Many APIs are used to interact with a database, such that we would be able to specify the requested table and the requested row within our API query, and then use an HTTP method to perform the operation needed. For example, for the <code>api.php</code> endpoint in our example, if we wanted to update the <code>city</code> table in the database, and the row we will be updating has a city name of <code>london</code>, then the URL would look something like this:</p>
<p>Code: bash</p>
<pre><code class="lang-bash">curl -X PUT http://<span class="hljs-tag">&lt;<span class="hljs-name">SERVER_IP</span>&gt;</span>:<span class="hljs-tag">&lt;<span class="hljs-name">PORT</span>&gt;</span>/api.php/city/london ...SNIP...
</code></pre>
<h3 id="crud">CRUD</h3>
<p>As we can see, we can easily specify the table and the row we want to perform an operation on through such APIs. Then we may utilize different HTTP methods to perform different operations on that row. In general, APIs perform 4 main operations on the requested database entity:</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>HTTP Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Create</code></td>
<td><code>POST</code></td>
<td>Adds the specified data to the database table</td>
</tr>
<tr>
<td><code>Read</code></td>
<td><code>GET</code></td>
<td>Reads the specified entity from the database table</td>
</tr>
<tr>
<td><code>Update</code></td>
<td><code>PUT</code></td>
<td>Updates the data of the specified database table</td>
</tr>
<tr>
<td><code>Delete</code></td>
<td><code>DELETE</code></td>
<td>Removes the specified row from the database table</td>
</tr>
</tbody>
</table>
<p>These four operations are mainly linked to the commonly known CRUD APIs, but the same principle is also used in REST APIs and several other types of APIs. Of course, not all APIs work in the same way, and the user access control will limit what actions we can perform and what results we can see. The <a href="https://academy.hackthebox.com/module/details/75">Introduction to Web Applications</a> module further explains these concepts, so you may refer to it for more details about APIs and their usage.</p>
<hr>
<h3 id="read">Read</h3>
<p>The first thing we will do when interacting with an API is reading data. As mentioned earlier, we can simply specify the table name after the API (e.g. <code>/city</code>) and then specify our search term (e.g. <code>/london</code>), as follows:</p>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ curl http:/</span><span class="hljs-regexp">/&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>api.php<span class="hljs-regexp">/city/</span>london

[{<span class="hljs-string">"city_name"</span>:<span class="hljs-string">"London"</span>,<span class="hljs-string">"country_name"</span>:<span class="hljs-string">"(UK)"</span>}]
</code></pre>
<p>We see that the result is sent as a JSON string. To have it properly formatted in JSON format, we can pipe the output to the <code>jq</code> utility, which will format it properly. We will also silent any unneeded cURL output with <code>-s</code>, as follows:</p>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ curl -s http:/</span><span class="hljs-regexp">/&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>api.php<span class="hljs-regexp">/city/</span>london | jq

[
  {
    <span class="hljs-string">"city_name"</span>: <span class="hljs-string">"London"</span>,
    <span class="hljs-string">"country_name"</span>: <span class="hljs-string">"(UK)"</span>
  }
]
</code></pre>
<p>As we can see, we got the output in a nicely formatted output. We can also provide a search term and get all matching results:</p>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ curl -s http:/</span><span class="hljs-regexp">/&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>api.php<span class="hljs-regexp">/city/</span>le | jq

[
  {
    <span class="hljs-string">"city_name"</span>: <span class="hljs-string">"Leeds"</span>,
    <span class="hljs-string">"country_name"</span>: <span class="hljs-string">"(UK)"</span>
  },
  {
    <span class="hljs-string">"city_name"</span>: <span class="hljs-string">"Dudley"</span>,
    <span class="hljs-string">"country_name"</span>: <span class="hljs-string">"(UK)"</span>
  },
  {
    <span class="hljs-string">"city_name"</span>: <span class="hljs-string">"Leicester"</span>,
    <span class="hljs-string">"country_name"</span>: <span class="hljs-string">"(UK)"</span>
  },
  ...SNIP...
]
</code></pre>
<p>Finally, we can pass an empty string to retrieve all entries in the table:</p>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ curl -s http:/</span><span class="hljs-regexp">/&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>api.php<span class="hljs-regexp">/city/</span> | jq

[
  {
    <span class="hljs-string">"city_name"</span>: <span class="hljs-string">"London"</span>,
    <span class="hljs-string">"country_name"</span>: <span class="hljs-string">"(UK)"</span>
  },
  {
    <span class="hljs-string">"city_name"</span>: <span class="hljs-string">"Birmingham"</span>,
    <span class="hljs-string">"country_name"</span>: <span class="hljs-string">"(UK)"</span>
  },
  {
    <span class="hljs-string">"city_name"</span>: <span class="hljs-string">"Leeds"</span>,
    <span class="hljs-string">"country_name"</span>: <span class="hljs-string">"(UK)"</span>
  },
  ...SNIP...
]
</code></pre>
<p><code>Try visiting any of the above links using your browser, to see how the result is rendered.</code></p>
<hr>
<h3 id="create">Create</h3>
<p>To add a new entry, we can use an HTTP POST request, which is quite similar to what we have performed in the previous section. We can simply POST our JSON data, and it will be added to the table. As this API is using JSON data, we will also set the <code>Content-Type</code> header to JSON, as follows:</p>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb[/htb]$</span> curl -X POST http://<span class="hljs-variable">&lt;SERVER_IP&gt;</span>:<span class="hljs-variable">&lt;PORT&gt;</span>/api.php/city/ -d '{<span class="hljs-string">"city_name"</span>:<span class="hljs-string">"HTB_City"</span>, <span class="hljs-string">"country_name"</span>:<span class="hljs-string">"HTB"</span>}' -H 'Content-Type: application/json'
</code></pre>
<p>Now, we can read the content of the city we added (<code>HTB_City</code>), to see if it was successfully added:</p>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ curl -s http:/</span><span class="hljs-regexp">/&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>api.php<span class="hljs-regexp">/city/</span>HTB_City | jq

[
  {
    <span class="hljs-string">"city_name"</span>: <span class="hljs-string">"HTB_City"</span>,
    <span class="hljs-string">"country_name"</span>: <span class="hljs-string">"HTB"</span>
  }
]
</code></pre>
<p>As we can see, a new city was created, which did not exist before.</p>
<p>Exercise: Try adding a new city through the browser devtools, by using one of the Fetch POST requests you used in the previous section.</p>
<hr>
<h3 id="update">Update</h3>
<p>Now that we know how to read and write entries through APIs, let&#39;s start discussing two other HTTP methods we have not used so far: <code>PUT</code> and <code>DELETE</code>. As mentioned at the beginning of the section, <code>PUT</code> is used to update API entries and modify their details, while <code>DELETE</code> is used to remove a specific entity.</p>
<p>Note: The HTTP <code>PATCH</code> method may also be used to update API entries instead of <code>PUT</code>. To be precise, <code>PATCH</code> is used to partially update an entry (only modify some of its data &quot;e.g. only city_name&quot;), while <code>PUT</code> is used to update the entire entry. We may also use the HTTP <code>OPTIONS</code> method to see which of the two is accepted by the server, and then use the appropriate method accordingly. In this section, we will be focusing on the <code>PUT</code> method, though their usage is quite similar.</p>
<p>Using <code>PUT</code> is quite similar to <code>POST</code> in this case, with the only difference being that we have to specify the name of the entity we want to edit in the URL, otherwise the API will not know which entity to edit. So, all we have to do is specify the <code>city</code> name in the URL, change the request method to <code>PUT</code>, and provide the JSON data like we did with POST, as follows:</p>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb[/htb]$</span> curl -X PUT http://<span class="hljs-variable">&lt;SERVER_IP&gt;</span>:<span class="hljs-variable">&lt;PORT&gt;</span>/api.php/city/london -d '{<span class="hljs-string">"city_name"</span>:<span class="hljs-string">"New_HTB_City"</span>, <span class="hljs-string">"country_name"</span>:<span class="hljs-string">"HTB"</span>}' -H 'Content-Type: application/json'
</code></pre>
<p>We see in the example above that we first specified <code>/city/london</code> as our city, and passed a JSON string that contained <code>&quot;city_name&quot;:&quot;New_HTB_City&quot;</code> in the request data. So, the london city should no longer exist, and a new city with the name <code>New_HTB_City</code> should exist. Let&#39;s try reading both to confirm:</p>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb[/htb]$</span> curl -s http://<span class="hljs-variable">&lt;SERVER_IP&gt;</span>:<span class="hljs-variable">&lt;PORT&gt;</span>/api.php/city/london |<span class="hljs-string"> jq</span>
</code></pre>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ curl -s http:/</span><span class="hljs-regexp">/&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>api.php<span class="hljs-regexp">/city/</span>New_HTB_City | jq

[
  {
    <span class="hljs-string">"city_name"</span>: <span class="hljs-string">"New_HTB_City"</span>,
    <span class="hljs-string">"country_name"</span>: <span class="hljs-string">"HTB"</span>
  }
]
</code></pre>
<p>Indeed, we successfully replaced the old city name with the new city.</p>
<p>Note: In some APIs, the <code>Update</code> operation may be used to create new entries as well. Basically, we would send our data, and if it does not exist, it would create it. For example, in the above example, even if an entry with a <code>london</code> city did not exist, it would create a new entry with the details we passed. In our example, however, this is not the case. Try to update a non-existing city and see what you would get.</p>
<hr>
<h3 id="delete">DELETE</h3>
<p>Finally, let&#39;s try to delete a city, which is as easy as reading a city. We simply specify the city name for the API and use the HTTP <code>DELETE</code> method, and it would delete the entry, as follows:</p>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ curl -X DELETE http:/</span><span class="hljs-regexp">/&lt;SERVER_IP&gt;:&lt;PORT&gt;/</span>api.php<span class="hljs-regexp">/city/</span>New_HTB_City
</code></pre>
<p>CRUD API</p>
<pre><code class="lang-shell-session">root@htb[<span class="hljs-regexp">/htb]$ curl -s http:/</span><span class="hljs-regexp">/&lt;SERVER_IP&gt;:&lt;PORT&gt;/api</span>.php/city/New_HTB_City | j<span class="hljs-string">q
[]</span>
</code></pre>
<p>As we can see, after we deleted <code>New_HTB_City</code>, we get an empty array when we try reading it, meaning it no longer exists.</p>
<p>With this, we are able to perform all 4 <code>CRUD</code> operations through cURL. In a real web application, such actions may not be allowed for all users, or it would be considered a vulnerability if anyone can modify or delete any entry. Each user would have certain privileges on what they can <code>read</code> or <code>write</code>, where <code>write</code> refers to adding, modifying, or deleting data. To authenticate our user to use the API, we would need to pass a cookie or an authorization header (e.g. JWT), as we did in an earlier section. Other than that, the operations are similar to what we practiced in this section.</p>
