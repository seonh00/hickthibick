
<body>
  <div class="container">
<link rel="stylesheet" href="style.css">

<h1 id="intro-to-assembly-language">Intro to Assembly Language</h1>
<h2 id="cheat-sheet">Cheat Sheet</h2>
<h3 id="registers">Registers</h3>
<table><thead><tr><th width="354.75">Description</th><th>64-bit Register (8-bytes)</th><th>8-bit Register (1-bytes)</th></tr></thead><tbody><tr><td><strong>Data/Arguments Registers</strong></td><td></td><td></td></tr><tr><td>Syscall Number/Return value</td><td><code>rax</code></td><td><code>al</code></td></tr><tr><td>Callee Saved</td><td><code>rbx</code></td><td><code>bl</code></td></tr><tr><td>1st arg</td><td><code>rdi</code></td><td><code>dil</code></td></tr><tr><td>2nd arg</td><td><code>rsi</code></td><td><code>sil</code></td></tr><tr><td>3rd arg</td><td><code>rdx</code></td><td><code>dl</code></td></tr><tr><td>4th arg - Loop Counter</td><td><code>rcx</code></td><td><code>cl</code></td></tr><tr><td>5th arg</td><td><code>r8</code></td><td><code>r8b</code></td></tr><tr><td>6th arg</td><td><code>r9</code></td><td><code>r9b</code></td></tr><tr><td><strong>Pointer Registers</strong></td><td></td><td></td></tr><tr><td>Base Stack Pointer</td><td><code>rbp</code></td><td><code>bpl</code></td></tr><tr><td>Current/Top Stack Pointer</td><td><code>rsp</code></td><td><code>spl</code></td></tr><tr><td>Instruction Pointer &#39;call only&#39;</td><td><code>rip</code></td><td><code>ipl</code></td></tr></tbody></table>

<h3 id="assembly-and-disassembly">Assembly and Disassembly</h3>
<table data-header-hidden><thead><tr><th width="335.75"></th><th></th></tr></thead><tbody><tr><td><strong>Command</strong></td><td><strong>Description</strong></td></tr><tr><td><code>nasm -f elf64 helloWorld.s</code></td><td>Assemble code</td></tr><tr><td><code>ld -o helloWorld helloWorld.o</code></td><td>Link code</td></tr><tr><td><code>ld -o fib fib.o -lc --dynamic-linker /lib64/ld-linux-x86-64.so.2</code></td><td>Link code with libc functions</td></tr><tr><td><code>objdump -M intel -d helloWorld</code></td><td>Disassemble <code>.text</code> section</td></tr><tr><td><code>objdump -M intel --no-show-raw-insn --no-addresses -d helloWorld</code></td><td>Show binary assembly code</td></tr><tr><td><code>objdump -sj .data helloWorld</code></td><td>Disassemble <code>.data</code> section</td></tr></tbody></table>

<h3 id="gdb">GDB</h3>
<table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gdb -q ./helloWorld</code></td>
<td>Open binary in gdb</td>
</tr>
<tr>
<td><code>info functions</code></td>
<td>View binary functions</td>
</tr>
<tr>
<td><code>info variables</code></td>
<td>View binary variables</td>
</tr>
<tr>
<td><code>registers</code></td>
<td>View registers</td>
</tr>
<tr>
<td><code>disas _start</code></td>
<td>Disassemble label/function</td>
</tr>
<tr>
<td><code>b _start</code></td>
<td>Break label/function</td>
</tr>
<tr>
<td><code>b *0x401000</code></td>
<td>Break address</td>
</tr>
<tr>
<td><code>r</code></td>
<td>Run the binary</td>
</tr>
<tr>
<td><code>x/4xg $rip</code></td>
<td>Examine register &quot;x/ count-format-size $register&quot;</td>
</tr>
<tr>
<td><code>si</code></td>
<td>Step to the next instruction</td>
</tr>
<tr>
<td><code>s</code></td>
<td>Step to the next line of code</td>
</tr>
<tr>
<td><code>ni</code></td>
<td>Step to the next function</td>
</tr>
<tr>
<td><code>c</code></td>
<td>Continue to the next break point</td>
</tr>
<tr>
<td><code>patch string 0x402000 &quot;Patched!\\x0a&quot;</code></td>
<td>Patch address value</td>
</tr>
<tr>
<td><code>set $rdx=0x9</code></td>
<td>Set register value</td>
</tr>
</tbody>
</table>
<h3 id="assembly-instructions">Assembly Instructions</h3>
<table>
<thead>
<tr>
<th><strong>Instruction</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Data Movement</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>mov</code></td>
<td>Move data or load immediate data</td>
<td><code>mov rax, 1</code> -&gt; <code>rax = 1</code></td>
</tr>
<tr>
<td><code>lea</code></td>
<td>Load an address pointing to the value</td>
<td><code>lea rax, [rsp+5]</code> -&gt; <code>rax = rsp+5</code></td>
</tr>
<tr>
<td><code>xchg</code></td>
<td>Swap data between two registers or addresses</td>
<td><code>xchg rax, rbx</code> -&gt; <code>rax = rbx, rbx = rax</code></td>
</tr>
<tr>
<td><strong>Unary Arithmetic Instructions</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>inc</code></td>
<td>Increment by 1</td>
<td><code>inc rax</code> -&gt; <code>rax++</code> or <code>rax += 1</code> -&gt; <code>rax = 2</code></td>
</tr>
<tr>
<td><code>dec</code></td>
<td>Decrement by 1</td>
<td><code>dec rax</code> -&gt; <code>rax--</code> or <code>rax -= 1</code> -&gt; <code>rax = 0</code></td>
</tr>
<tr>
<td><strong>Binary Arithmetic Instructions</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>add</code></td>
<td>Add both operands</td>
<td><code>add rax, rbx</code> -&gt; <code>rax = 1 + 1</code> -&gt; <code>2</code></td>
</tr>
<tr>
<td><code>sub</code></td>
<td>Subtract Source from Destination (<em>i.e <code>rax = rax - rbx</code></em>)</td>
<td><code>sub rax, rbx</code> -&gt; <code>rax = 1 - 1</code> -&gt; <code>0</code></td>
</tr>
<tr>
<td><code>imul</code></td>
<td>Multiply both operands</td>
<td><code>imul rax, rbx</code> -&gt; <code>rax = 1 * 1</code> -&gt; <code>1</code></td>
</tr>
<tr>
<td><strong>Bitwise Arithmetic Instructions</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>not</code></td>
<td>Bitwise NOT (<em>invert all bits, 0-&gt;1 and 1-&gt;0</em>)</td>
<td><code>not rax</code> -&gt; <code>NOT 00000001</code> -&gt; <code>11111110</code></td>
</tr>
<tr>
<td><code>and</code></td>
<td>Bitwise AND (<em>if both bits are 1 -&gt; 1, if bits are different -&gt; 0</em>)</td>
<td><code>and rax, rbx</code> -&gt; <code>00000001 AND 00000010</code> -&gt; <code>00000000</code></td>
</tr>
<tr>
<td><code>or</code></td>
<td>Bitwise OR (<em>if either bit is 1 -&gt; 1, if both are 0 -&gt; 0</em>)</td>
<td><code>or rax, rbx</code> -&gt; <code>00000001 OR 00000010</code> -&gt; <code>00000011</code></td>
</tr>
<tr>
<td><code>xor</code></td>
<td>Bitwise XOR (<em>if bits are the same -&gt; 0, if bits are different -&gt; 1</em>)</td>
<td><code>xor rax, rbx</code> -&gt; <code>00000001 XOR 00000010</code> -&gt; <code>00000011</code></td>
</tr>
<tr>
<td><strong>Loops</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>mov rcx, x</code></td>
<td>Sets loop (<code>rcx</code>) counter to <code>x</code></td>
<td><code>mov rcx, 3</code></td>
</tr>
<tr>
<td><code>loop</code></td>
<td>Jumps back to the start of <code>loop</code> until counter reaches <code>0</code></td>
<td><code>loop exampleLoop</code></td>
</tr>
<tr>
<td><strong>Branching</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>jmp</code></td>
<td>Jumps to specified label, address, or location</td>
<td><code>jmp loop</code></td>
</tr>
<tr>
<td><code>jz</code></td>
<td>Destination <strong>equal to Zero</strong></td>
<td><code>D = 0</code></td>
</tr>
<tr>
<td><code>jnz</code></td>
<td>Destination <strong>Not equal to Zero</strong></td>
<td><code>D != 0</code></td>
</tr>
<tr>
<td><code>js</code></td>
<td>Destination <strong>is Negative</strong></td>
<td><code>D &lt; 0</code></td>
</tr>
<tr>
<td><code>jns</code></td>
<td>Destination <strong>is Not Negative</strong> (i.e. 0 or positive)</td>
<td><code>D &gt;= 0</code></td>
</tr>
<tr>
<td><code>jg</code></td>
<td>Destination <strong>Greater than</strong> Source</td>
<td><code>D &gt; S</code></td>
</tr>
<tr>
<td><code>jge</code></td>
<td>Destination <strong>Greater than or Equal</strong> Source</td>
<td><code>D &gt;= S</code></td>
</tr>
<tr>
<td><code>jl</code></td>
<td>Destination <strong>Less than</strong> Source</td>
<td><code>D &lt; S</code></td>
</tr>
<tr>
<td><code>jle</code></td>
<td>Destination <strong>Less than or Equal</strong> Source</td>
<td><code>D &lt;= S</code></td>
</tr>
<tr>
<td><code>cmp</code></td>
<td>Sets <code>RFLAGS</code> by subtracting second operand from first operand (<em>i.e. first - second</em>)</td>
<td><code>cmp rax, rbx</code> -&gt; <code>rax - rbx</code></td>
</tr>
<tr>
<td><strong>Stack</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>push</code></td>
<td>Copies the specified register/address to the top of the stack</td>
<td><code>push rax</code></td>
</tr>
<tr>
<td><code>pop</code></td>
<td>Moves the item at the top of the stack to the specified register/address</td>
<td><code>pop rax</code></td>
</tr>
<tr>
<td><strong>Functions</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>call</code></td>
<td>push the next instruction pointer <code>rip</code> to the stack, then jumps to the specified procedure</td>
<td><code>call printMessage</code></td>
</tr>
<tr>
<td><code>ret</code></td>
<td>pop the address at <code>rsp</code> into <code>rip</code>, then jump to it</td>
<td><code>ret</code></td>
</tr>
</tbody>
</table>
<h3 id="functions">Functions</h3>
<table data-header-hidden><thead><tr><th width="495.5"></th><th></th></tr></thead><tbody><tr><td><strong>Command</strong></td><td><strong>Description</strong></td></tr><tr><td><code>cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h | grep write</code></td><td>Locate <code>write</code> syscall number</td></tr><tr><td><code>man -s 2 write</code></td><td><code>write</code> syscall man page</td></tr><tr><td><code>man -s 3 printf</code></td><td><code>printf</code> libc man page</td></tr></tbody></table>

<p><strong>Syscall Calling Convention</strong></p>
<ol>
<li>Save registers to stack</li>
<li>Set its syscall number in <code>rax</code></li>
<li>Set its arguments in the registers</li>
<li>Use the <code>syscall</code> assembly instruction to call it</li>
</ol>
<p><strong>Function Calling Convention</strong></p>
<ol>
<li><code>Save Registers</code> on the stack (<em><code>Caller Saved</code></em>)</li>
<li>Pass <code>Function Arguments</code> (<em>like syscalls</em>)</li>
<li>Fix <code>Stack Alignment</code></li>
<li>Get Function&#39;s <code>Return Value</code> (<em>in <code>rax</code></em>)</li>
</ol>
<h3 id="shellcoding">Shellcoding</h3>
<table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pwn asm &#39;push rax&#39; -c &#39;amd64&#39;</code></td>
<td>Instruction to shellcode</td>
</tr>
<tr>
<td><code>pwn disasm &#39;50&#39; -c &#39;amd64&#39;</code></td>
<td>Shellcode to instructions</td>
</tr>
<tr>
<td><code>python3 shellcoder.py helloworld</code></td>
<td>Extract binary shellcode</td>
</tr>
<tr>
<td><code>python3 loader.py &#39;4831..0f05</code></td>
<td>Run shellcode</td>
</tr>
<tr>
<td><code>python assembler.py &#39;4831..0f05</code></td>
<td>Assemble shellcode into binary</td>
</tr>
<tr>
<td><strong>Shellcraft</strong></td>
<td></td>
</tr>
<tr>
<td><code>pwn shellcraft -l &#39;amd64.linux&#39;</code></td>
<td>List available syscalls</td>
</tr>
<tr>
<td><code>pwn shellcraft amd64.linux.sh</code></td>
<td>Generate syscalls shellcode</td>
</tr>
<tr>
<td><code>pwn shellcraft amd64.linux.sh -r</code></td>
<td>Run syscalls shellcode</td>
</tr>
<tr>
<td><strong>Msfvenom</strong></td>
<td></td>
</tr>
<tr>
<td>`msfvenom -l payloads \</td>
<td>grep &#39;linux/x64&#39;`</td>
<td>List available syscalls</td>
</tr>
<tr>
<td><code>msfvenom -p &#39;linux/x64/exec&#39; CMD=&#39;sh&#39; -a &#39;x64&#39; --platform &#39;linux&#39; -f &#39;hex&#39;</code></td>
<td>Generate syscalls shellcode</td>
</tr>
<tr>
<td><code>msfvenom -p &#39;linux/x64/exec&#39; CMD=&#39;sh&#39; -a &#39;x64&#39; --platform &#39;linux&#39; -f &#39;hex&#39; -e &#39;x64/xor&#39;</code></td>
<td>Generate encoded syscalls shellcode</td>
</tr>
</tbody>
</table>
<p><strong>Shellcoding Requirements</strong></p>
<ol>
<li>Does not contain variables</li>
<li>Does not refer to direct memory addresses</li>
<li>Does not contain any NULL bytes <code>00</code>&#x20;</li>
</ol>
<hr>
<h2 id="assembly-language">Assembly Language</h2>
<hr>
<p>Most of our interaction with our personal computers and smartphones is done through the operating system and other applications. These applications are usually developed using high-level languages, like C++, Java, Python, and many others. We also know that each of these devices has a core processor that runs all of the necessary processes to execute systems and applications, along with Random Access Memory (RAM), Video Memory, and other similar components.</p>
<p>However, these physical components cannot interpret or understand high-level languages, as they can essentially only process <code>1</code>&#39;s and <code>0</code>&#39;s. This is where Assembly language comes in, as a low-level language that can write direct instructions the processors can understand. Since the processor can only process binary data &quot;i.e. <code>1</code>&#39;s and <code>0</code>&#39;s&quot;, it would be challenging for humans to interact with processors without referring to manuals to know which hex code runs which instruction.</p>
<p>This is why low-level assembly languages were built. By using Assembly, developers can write human-readable machine instructions, which are then assembled into their machine code equivalent, so that the processor can directly run them. This is why some refer to Assembly language as symbolic machine code. For example, the Assembly code &#39;<code>add rax, 1</code>&#39; is much more intuitive and easier to remember than its equivalent machine shellcode &#39;<code>4883C001</code>&#39;, and easier to remember than the equivalent binary machine code &#39;<code>01001000 10000011 11000000 00000001</code>&#39;. As we can see, without Assembly language, it is very challenging to write machine instructions or directly interact with the processor.</p>
<p>Machine code is often represented as <code>Shellcode</code>, a hex representation of machine code bytes. Shellcode can be translated back to its Assembly counterpart and can also be loaded directly into memory as binary instructions to be executed.</p>
<hr>
<h3 id="high-level-vs-low-level">High-level vs. Low-level</h3>
<p>As there are different processor designs, each processor understands a different set of machine instructions and a different Assembly language. In the past, applications had to be written in assembly for each processor, so it was not easy to develop an application for multiple processors. In the early 1970&#39;s, high-level languages (like <code>C</code>) were developed to make it possible to write a single easy to understand code that can work on any processor without rewriting it for each processor. To be more specific, this was made possible by creating compilers for each language.</p>
<p>When high-level code is compiled, it is translated into assembly instructions for the processor it is being compiled for, which is then assembled into machine code to run on the processor. This is why compilers are built for various languages and various processors to convert the high-level code into assembly code and then machine code that matches the running processor.</p>
<p>Later on, interpreted languages were developed, like <code>Python</code>, <code>PHP</code>, <code>Bash</code>, <code>JavaScript</code>, and others, which are usually not compiled but are interpreted during run time. These types of languages utilize pre-built libraries to run their instructions. These libraries are typically written and compiled in other high-level languages like <code>C</code> or <code>C++</code>. So when we issue a command in an interpreted language, it would use the compiled library to run that command, which uses its assembly code/machine code to perform all the instructions necessary to run this command on the processor.</p>
<hr>
<h3 id="compilation-stages">Compilation Stages</h3>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_Compilation_Stages_1_.png" alt="Image showing the translation of &#39;Hello World!&#39; from Python to C, Assembly, Hex, and Binary. Python uses print(&quot;Hello World!&quot;). C uses write(1,&quot;Hello World!&quot;,12); \_exit(0);. Assembly shows mov and syscall instructions. Hex and Binary represent machine code."></p>
<p>Let&#39;s take a basic &#39;<code>Hello World!</code>&#39; program that prints these words on the screen and show how it changes from high-level to machine code. In an interpreted language, like Python, it would be the following basic line:</p>
<p>Code: python</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">"Hello World!"</span>)</span></span>
</code></pre>
<p>If we run this Python line, it would be essentially executing the following <code>C</code> code:</p>
<p>Code: c</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    write(<span class="hljs-number">1</span>, <span class="hljs-string">"Hello World!"</span>, <span class="hljs-number">12</span>);
    _exit(<span class="hljs-number">0</span>);
}
</code></pre>
<p>Note: the actual <code>C</code> source code is much longer, but the above is the essence of how the string &#39;<code>Hello World!</code>&#39; is printed. If you are ever interested in knowing more, you can check out the source code of the Python3 print function at this <a href="https://github.com/python/cpython/blob/0332e569c12d3dc97171546c6dc10e42c27de34b/Python/bltinmodule.c#L1829">link</a> and this <a href="https://github.com/python/cpython/blob/9975cc5008c795e069ce11e2dbed2110cc12e74e/Objects/fileobject.c#L119">link</a></p>
<p>The above <code>C</code> code uses the Linux <code>write</code> syscall, built-in for processes to write to the screen. The same syscall called in Assembly looks like the following:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, message
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">12</span>
<span class="hljs-keyword">syscall</span>

<span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
<span class="hljs-keyword">syscall</span>
</code></pre>
<p>As we can see, when the <code>write</code> syscall is called in <code>C</code> or Assembly, both are using <code>1</code>, the text, and <code>12</code> as the arguments. This will be covered more in-depth later in the module. From this point, Assembly code, shellcode, and binary machine code are mostly identical but written in different formats. The previous Assembly code can be assembled into the following hex machine code (i.e., shellcode):</p>
<p>Code: shellcode</p>
<pre><code class="lang-shellcode"><span class="hljs-symbol">48 </span>c7 c0 <span class="hljs-number">01</span>
<span class="hljs-symbol">48 </span>c7 c7 <span class="hljs-number">01</span>
<span class="hljs-symbol">48 </span><span class="hljs-number">8</span>b <span class="hljs-number">34</span> <span class="hljs-number">25</span>
<span class="hljs-symbol">48 </span>c7 c2 <span class="hljs-number">0</span>c
<span class="hljs-number">0</span>f <span class="hljs-number">05</span>

<span class="hljs-symbol">48 </span>c7 c0 <span class="hljs-number">3</span>c
<span class="hljs-symbol">48 </span>c7 c7 <span class="hljs-number">00</span>
<span class="hljs-number">0</span>f <span class="hljs-number">05</span>
</code></pre>
<p>Finally, for the processor to execute the instructions linked to this machine, it would have to be translated into binary, which would look like the following:</p>
<p>Code: binary</p>
<pre><code class="lang-binary"><span class="hljs-symbol">01001000 </span><span class="hljs-number">11000111</span> <span class="hljs-number">11000000</span> <span class="hljs-number">00000001</span>
<span class="hljs-symbol">01001000 </span><span class="hljs-number">11000111</span> <span class="hljs-number">11000111</span> <span class="hljs-number">00000001</span>
<span class="hljs-symbol">01001000 </span><span class="hljs-number">10001011</span> <span class="hljs-number">00110100</span> <span class="hljs-number">00100101</span>
<span class="hljs-symbol">01001000 </span><span class="hljs-number">11000111</span> <span class="hljs-number">11000010</span> <span class="hljs-number">00001101</span> 
<span class="hljs-symbol">00001111 </span><span class="hljs-number">00000101</span>

<span class="hljs-symbol">01001000 </span><span class="hljs-number">11000111</span> <span class="hljs-number">11000000</span> <span class="hljs-number">00111100</span> 
<span class="hljs-symbol">01001000 </span><span class="hljs-number">11000111</span> <span class="hljs-number">11000111</span> <span class="hljs-number">00000000</span> 
<span class="hljs-symbol">00001111 </span><span class="hljs-number">00000101</span>
</code></pre>
<p>A CPU uses different electrical charges for a <code>1</code> and a <code>0</code>, and hence can calculate these instructions from the binary data once it receives them.</p>
<p>Note: With multi-platform languages, like <code>Java</code>, the code is compiled into a Java Bytecode, which is the same for all processors/systems, and is then compiled to machine code by the local Java Runtime environment. <em>This is what makes Java relatively slower than other languages like C++ that compile directly into machine code. Languages like C++ are more suitable for processor intensive applications like games.</em></p>
<p>We now see how computer languages progressed from assembly language unique for each processor to high-level languages that can work on any device without even needing to be compiled.</p>
<hr>
<h3 id="value-for-pentesters">Value for Pentesters</h3>
<p>Understanding assembly language instructions is critical for binary exploitation, which is an essential part of penetration testing. When it comes to exploiting compiled programs, the only way to attack them would be through their binaries. To disassemble, debug, and follow binary instructions in memory and find potential vulnerabilities, we must have a basic understanding of Assembly language and how it flows through the CPU components.</p>
<p>This is why once we start learning binary exploitation techniques, like buffer overflows, ROP chains, heap exploitation, and others, we will be dealing a lot with assembly instructions and following them in memory. Furthermore, to exploit these vulnerabilities, we will have to build custom exploits that use assembly instructions to manipulate the code while in memory and inject assembly shellcode to be executed.</p>
<p>Learning Intel x86 Assembly Language is crucial for writing exploits for binaries on modern machines. In addition to Intel x86, ARM is becoming more common, as most modern smartphones and some modern laptops like the M1 MacBook Pro feature ARM processors. Exploiting binaries in these systems requires ARM Assembly knowledge. This module will not cover ARM Assembly Language. That being said, Assembly Language basics will undoubtedly be helpful to anyone willing to learn ARM Assembly since the two languages have a lot of similarities.</p>
<hr>
<h2 id="computer-architecture">Computer Architecture</h2>
<hr>
<p>Today, most modern computers are built on what is known as the <a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">Von Neumann Architecture</a>, which was developed back in 1945 by <code>Von Neumann</code> to enable the creation of &quot;General-Purpose Computers&quot; as <code>Alan Turing</code> described them at the time. <code>Alan Turing</code> in turn, based his ideas on <code>Charles Babbage</code>&#39;s mid-19th century &quot;Programmable Computer&quot; concept. Note that all of these people were mathematicians.</p>
<p>This architecture executes machine code to perform specific algorithms. It mainly consists of the following elements:</p>
<ul>
<li>Central Processing Unit (CPU)</li>
<li>Memory Unit</li>
<li>Input/Output Devices<ul>
<li>Mass Storage Unit</li>
<li>Keyboard</li>
<li>Display</li>
</ul>
</li>
</ul>
<p>Furthermore, the CPU itself consists of three main components:</p>
<ul>
<li>Control Unit (CU)</li>
<li>Arithmetic/Logic Unit (ALU)</li>
<li>Registers</li>
</ul>
<p><img src="https://academy.hackthebox.com/storage/modules/85/von_neumann_arch.jpg" alt="Diagram showing CPU interaction with Memory and I/O. CPU includes CU, ALU, and Registers. Memory consists of Cache and RAM. I/O includes Keyboard, Display, and Storage. Arrows indicate data flow between components."></p>
<p>Though very old, this architecture is still the basis of most modern computers, servers, and even smartphones.</p>
<p>Assembly languages mainly work with the CPU and memory. This is why it is crucial to understand the general design of computer architecture, so when we start using assembly instructions to move and process data, we know where it&#39;s going and coming from and how fast/expensive each instruction is.</p>
<p>Furthermore, basic and advanced binary exploitation requires a proper understanding of computer architecture. With basic stack overflows, we only need to be aware of the general design. Once we start using ROP and Heap exploits, our understanding should be profound. Let us now take a deeper look into some essential components.</p>
<hr>
<h3 id="memory">Memory</h3>
<p>A computer&#39;s memory is where the <code>temporary</code> data and instructions of currently running programs are located. A computer&#39;s memory is also known as Primary Memory. It is the primary location the CPU uses to retrieve and process data. It does so very frequently (billions of times a second), so the memory must be extremely fast in storing and retrieving data and instructions.</p>
<p>There are two main types of memory:</p>
<ol>
<li><code>Cache</code></li>
<li><code>Random Access Memory (RAM)</code></li>
</ol>
<p><strong>Cache</strong></p>
<p>Cache memory is usually located within the CPU itself and hence is extremely fast compared to RAM, as it runs at the same clock speed as the CPU. However, it is very limited in size and very sophisticated, and expensive to manufacture due to it being so close to the CPU core.</p>
<p>Since RAM clock speed is usually much slower than the CPU cores, in addition to it being far from the CPU, if a CPU had to wait for the RAM to retrieve each instruction, it would effectively be running at much lower clock speeds. This is the main benefit of cache memory. It enables the CPU to access the upcoming instructions and data quicker than retrieving them from RAM.</p>
<p>There are usually three levels of cache memory, depending on their closeness to the CPU core:</p>
<table>
<thead>
<tr>
<th><strong>Level</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Level 1 Cache</code></td>
<td>Usually in kilobytes, the fastest memory available, located in each CPU core. (Only registers are faster.)</td>
</tr>
<tr>
<td><code>Level 2 Cache</code></td>
<td>Usually in megabytes, extremely fast (but slower than L1), shared between all CPU cores.</td>
</tr>
<tr>
<td><code>Level 3 Cache</code></td>
<td>Usually in megabytes (larger than L2), faster than RAM but slower than L1/L2. (Not all CPUs use L3.)</td>
</tr>
</tbody>
</table>
<p><strong>RAM</strong></p>
<p>RAM is much larger than cache memory, coming in sizes ranging from gigabytes up to terabytes. RAM is also located far away from the CPU cores and is much slower than cache memory. Accessing data from RAM addresses takes many more instructions.</p>
<p>For example, retrieving an instruction from the registers takes only one clock cycle, and retrieving it from the L1 cache takes a few cycles, while retrieving it from RAM takes around 200 cycles. When this is done billions of times a second, it makes a massive difference in the overall execution speed.</p>
<p>In the past, with 32-bit addresses, memory addresses were limited from <code>0x00000000</code> to <code>0xffffffff</code>. This meant that the maximum possible RAM size was 2<sup>32</sup> bytes, which is only 4 gigabytes, at which point we run out of unique addresses. With 64-bit addresses, the range is now up to <code>0xffffffffffffffff</code>, with a theoretical maximum RAM size of 2<sup>64</sup> bytes, which is around 18.5 exabytes (18.5 million terabytes), so we shouldn&#39;t be running out of memory addresses anytime soon.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/memory_structure.jpg" alt="Diagram of memory layout with Stack at high address, Heap growing upwards, Data, and Text at low address."></p>
<p>When a program is run, all of its data and instructions are moved from the storage unit to the RAM to be accessed when needed by the CPU. This happens because accessing them from the storage unit is much slower and will increase data processing times. When a program is closed, its data is removed or made available to re-use from the RAM.</p>
<p>As we can see, the RAM is split into four main <code>segments</code>:</p>
<table>
<thead>
<tr>
<th>Segment</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Stack</code></td>
<td>Has a Last-in First-out (LIFO) design and is fixed in size. Data in it can only be accessed in a specific order by push-ing and pop-ing data.</td>
</tr>
<tr>
<td><code>Heap</code></td>
<td>Has a hierarchical design and is therefore much larger and more versatile in storing data, as data can be stored and retrieved in any order. However, this makes the heap slower than the Stack.</td>
</tr>
<tr>
<td><code>Data</code></td>
<td>Has two parts: <code>Data</code>, which is used to hold variables, and <code>.bss</code>, which is used to hold unassigned variables (i.e., buffer memory for later allocation).</td>
</tr>
<tr>
<td><code>Text</code></td>
<td>Main assembly instructions are loaded into this segment to be fetched and executed by the CPU.</td>
</tr>
</tbody>
</table>
<p>Although this segmentation applies to the entire RAM, <code>each application is allocated its Virtual Memory when it is run</code>. This means that each application would have its own <code>stack</code>, <code>heap</code>, <code>data</code>, and <code>text</code> segments.</p>
<hr>
<h3 id="io-storage">IO/Storage</h3>
<p>Finally, we have the Input/Output devices, like the keyboard, the screen, or the long-term storage unit, also known as Secondary Memory. The processor can access and control IO devices using <code>Bus Interfaces</code>, which act as &#39;highways&#39; to transfer data and addresses, using electrical charges for binary data.</p>
<p>Each Bus has a capacity of bits (or electrical charges) it can carry simultaneously. This usually is a multiple of 4-bits, ranging up to 128-bits. Bus interfaces are also usually used to access memory and other components outside the CPU itself. If we take a closer look at a CPU or a motherboard, we can see the bus interfaces all over them:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/cpu_bus.jpg" alt="Close-up of a blue circuit board showing intricate pathways and components."></p>
<p>Unlike primary memory that is volatile and stores temporary data and instructions as the programs are running, the storage unit stores permanent data, like the operating system files or entire applications and their data.</p>
<p>The storage unit is the slowest to access. First, because they are the farthest away from the CPU, accessing them through bus interfaces like SATA or USB takes much longer to store and retrieve the data. They are also slower in their design to allow more data storage. Αs long as there is more data to go through, they will be slower.</p>
<p>There has been a shift from classic magnetic storage units, like tapes or Hard Disk Drives (HDD), to Solid-State Drives (SSD) in recent years. This is because SSD&#39;s utilize a similar design to RAM&#39;s, using non-volatile circuitry that retains data even without electricity. This made storage units much faster in storing and retrieving data. Still, since they are far away from the CPU and connected through special interfaces, they are the slowest unit to access.</p>
<hr>
<h3 id="speed">Speed</h3>
<p>As we can see from the above, the further away a component is from the CPU core, the slower it is. Also, the more data it can hold, the slower it is, as it simply has to go through more to fetch the data. The below table summarizes each component, its size, and its speed:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Speed</th>
<th>Size</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Registers</code></td>
<td>Fastest</td>
<td>Bytes</td>
</tr>
<tr>
<td><code>L1 Cache</code></td>
<td>Fastest, other than Registers</td>
<td>Kilobytes</td>
</tr>
<tr>
<td><code>L2 Cache</code></td>
<td>Very fast</td>
<td>Megabytes</td>
</tr>
<tr>
<td><code>L3 Cache</code></td>
<td>Fast, but slower than the above</td>
<td>Megabytes</td>
</tr>
<tr>
<td><code>RAM</code></td>
<td>Much slower than all of the above</td>
<td>Gigabytes-Terabytes</td>
</tr>
<tr>
<td><code>Storage</code></td>
<td>Slowest</td>
<td>Terabytes and more</td>
</tr>
</tbody>
</table>
<p>The speed here is relative depending on the CPU clock speed. Now that we have a general idea of the computer architecture, we&#39;ll discuss Registers and the CPU architecture in the next section.</p>
<hr>
<h2 id="cpu-architecture">CPU Architecture</h2>
<hr>
<p>The Central Processing Unit (CPU) is the main processing unit within a computer. The CPU contains both the <code>Control Unit</code> (CU), which is in charge of moving and controlling data, and the <code>Arithmetic/Logic Unit</code> (ALU), which is in charge of performing various arithmetics and logical calculations as requested by a program through the assembly instructions.</p>
<p>The manner in which and how efficiently a CPU processes its instructions depends on its <code>Instruction Set Architecture</code> (ISA). There are multiple ISA&#39;s in the industry, each having its way of processing data. <code>RISC</code> architecture is based on processing more simple instructions, which takes more cycles, but each cycle is shorter and takes less power. The <code>CISC</code> architecture is based on fewer, more complex instructions, which can finish the requested instructions in fewer cycles, but each instruction takes more time and power to be processed.</p>
<p>Let us take a look at both <code>RISC</code> and <code>CISC</code>, and learn more about instructions cycles and registers.</p>
<hr>
<h3 id="clock-speed-clock-cycle">Clock Speed &amp; Clock Cycle</h3>
<p>Each CPU has a clock speed that indicates its overall speed. Every tick of the clock runs a clock cycle that processes a basic instruction, such as fetching an address or storing an address. Specifically, this is done by the CU or ALU.</p>
<p>The frequency in which the cycles occur is counted is cycles per second (<code>Hertz</code>). If a CPU has a speed of 3.0 GHz, it can run 3 billion cycles every second (per core).</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_clock_cycle_0.jpg" alt="Diagram of a clock cycle with six phases labeled T1 to T6, showing a repeating waveform pattern."></p>
<p>Modern processors have a multi-core design, allowing them to have multiple cycles at the same time.</p>
<hr>
<h3 id="instruction-cycle">Instruction Cycle</h3>
<p>An <code>Instruction Cycle</code> is the cycle it takes the CPU to process a single machine instruction.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_instruction_cycle.jpg" alt="Diagram of CPU cycle showing stages: Fetch, Decode, Execute, and Store, in a circular flow around a CPU icon."></p>
<p>An instruction cycle consists of four stages: <code>Fetch</code>, <code>Decode</code>, <code>Execute</code>, and <code>Store</code>:</p>
<table>
<thead>
<tr>
<th><strong>Instruction</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1. Fetch</code></td>
<td>Takes the next instruction&#39;s address from the <code>Instruction Address Register</code> (IAR), which tells it where the next instruction is located.</td>
</tr>
<tr>
<td><code>2. Decode</code></td>
<td>Takes the instruction from the IAR, and decodes it from binary to see what is required to be executed.</td>
</tr>
<tr>
<td><code>3. Execute</code></td>
<td>Fetch instruction operands from register/memory, and process the instruction in the <code>ALU</code> or <code>CU</code>.</td>
</tr>
<tr>
<td><code>4. Store</code></td>
<td>Store the new value in the destination operand.</td>
</tr>
</tbody>
</table>
<p>All of the stages in the instruction cycle are carried out by the Control Unit, except when arithmetic instructions need to be executed &quot;add, sub, ..etc&quot;, which are executed by the ALU.</p>
<p>Each Instruction Cycle takes multiple clock cycles to finish, depending on the CPU architecture and the complexity of the instruction. Once a single instruction cycle ends, the CU increments to the next instruction and runs the same cycle on it, and so on.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_clock_cycle_1.jpg" alt="Diagram of a clock cycle with six phases, T1 to T6. Stages include Fetch in red, Decode in orange, and Execute in green, aligned with the waveform pattern."></p>
<p>For example, if we were to execute the assembly instruction <code>add rax, 1</code>, it would run through an instruction cycle:</p>
<ol>
<li>Fetch the instruction from the <code>rip</code> register, <code>48 83 C0 01</code> (in binary).</li>
<li>Decode &#39;<code>48 83 C0 01</code>&#39; to know it needs to perform an <code>add</code> of <code>1</code> to the value at <code>rax</code>.</li>
<li>Get the current value at <code>rax</code> (by <code>CU</code>), add <code>1</code> to it (by the <code>ALU</code>).</li>
<li>Store the new value back to <code>rax</code>.</li>
</ol>
<p>In the past, processors used to process instructions sequentially, so they had to wait for one instruction to finish to start the next. On the other hand, modern processors can process multiple instructions in parallel by having multiple instruction/clock cycles running at the same time. This is made possible by having a multi-thread and multi-core design.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_clock_cycle_2.jpg" alt="Diagram of a clock cycle with six phases, T1 to T6. Stages include Fetch 1, Decode 1, Execute 1, Fetch 2, Decode 2, Execute 2, Fetch 3, Decode 3, and Execute 3, aligned with the waveform pattern."></p>
<hr>
<h3 id="processor-specific">Processor Specific</h3>
<p>As previously mentioned, each processor understands a different set of instructions. For example, while an Intel processor based on the 64-bit x86 architecture may interpret the machine code <code>4883C001</code> as <code>add rax, 1</code>, an ARM processor translates the same machine code as the <code>biceq r8, r0, r8, asr #6</code> instruction. As we can see, the same machine code performs an entirely different instruction on each processor.</p>
<p>This is because each processor type has a different low-level assembly language architecture known as <code>Instruction Set Architectures</code> (ISA). For example, the add instruction seen above, <code>add rax, 1</code> is for Intel x86 64-bit processors. The same instruction written for the ARM processor assembly language is represented as <code>add r1, r1, 1</code>.</p>
<p><code>It is important to understand that each processor has its own set of instructions and corresponding machine code.</code></p>
<p>Furthermore, a single Instruction Set Architecture may have several syntax interpretations for the same assembly code. For example, the above <code>add</code> instruction is based on the x86 architecture, which is supported by multiple processors like Intel, AMD, and legacy AT\&amp;T processors. The instruction is written as <code>add rax, 1</code> with Intel syntax, and written as <code>addb $0x1,%rax</code> with AT\&amp;T syntax.</p>
<p>As we can see, even though we can tell that both instructions are similar and do the same thing, their syntax is different, and the locations of the source and destination operands are swapped as well. Still, both codes assemble the same machine code and perform the same instruction.</p>
<p><code>So, each processor type has its Instruction Set Architectures, and each architecture can be further represented in several syntax formats</code></p>
<p>This module will focus mainly on the Intel x86 64-bit assembly language (also known as x86_64 and AMD64), as the majority of modern computers and servers run on this processor architecture. We will be using the Intel syntax as well.</p>
<p>If we want to know whether our Linux system supports <code>x86_64</code> architecture, we can use the <code>lscpu</code> command:</p>
<p>&#x20; CPU Architecture</p>
<pre><code class="lang-shell-session"><span class="hljs-symbol">root</span><span class="hljs-comment">@htb[/htb]$ lscpu</span>
<span class="hljs-symbol">
Architecture:</span>                    x86_64
<span class="hljs-symbol">CPU</span> op-mode(s):                  <span class="hljs-number">32</span>-<span class="hljs-keyword">bit, </span><span class="hljs-number">64</span>-<span class="hljs-keyword">bit
</span><span class="hljs-keyword">Byte </span>Order:                      Little Endian

&lt;SNIP&gt;
</code></pre>
<p>As we can see in the above output, the CPU architecture is <code>x86_64</code>, and supports 32-bit and 64-bit. The byte order is Little Endian. We can also use the <code>uname -m</code> command to get the CPU architecture. We will discuss the two most common Instruction Set Architectures in the next section: <code>CISC</code> and <code>RISC</code>.</p>
<hr>
<h2 id="instruction-set-architectures">Instruction Set Architectures</h2>
<hr>
<p>An <code>Instruction Set Architecture</code> (<code>ISA</code>) specifies the syntax and semantics of the assembly language on each architecture. It is not just a different syntax but is built in the core design of a processor, as it affects the way and order instructions are executed and their level of complexity. <code>ISA</code> mainly consists of the following components:</p>
<ul>
<li>Instructions</li>
<li>Registers</li>
<li>Memory Addresses</li>
<li>Data Types</li>
</ul>
<table>
<thead>
<tr>
<th>Component</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Instructions</code></td>
<td>The instruction to be processed in the <code>opcode operand_list</code> format. There are usually 1,2, or 3 comma-separated operands.</td>
<td><code>add rax, 1</code>, <code>mov rsp, rax</code>, <code>push rax</code></td>
</tr>
<tr>
<td><code>Registers</code></td>
<td>Used to store operands, addresses, or instructions temporarily.</td>
<td><code>rax</code>, <code>rsp</code>, <code>rip</code></td>
</tr>
<tr>
<td><code>Memory Addresses</code></td>
<td>The address in which data or instructions are stored. May point to memory or registers.</td>
<td><code>0xffffffffaa8a25ff</code>, <code>0x44d0</code>, <code>$rax</code></td>
</tr>
<tr>
<td><code>Data Types</code></td>
<td>The type of stored data.</td>
<td><code>byte</code>, <code>word</code>, <code>double word</code></td>
</tr>
</tbody>
</table>
<p>These are the main components that distinguish different ISA&#39;s and assembly languages. We will cover each of them in more depth in the coming sections, and we&#39;ll learn how to use various instructions.</p>
<p>There are two main Instruction Set Architectures that are widely used:</p>
<ol>
<li><code>Complex Instruction Set Computer</code> (<code>CISC</code>) - Used in <code>Intel</code> and <code>AMD</code> processors in most computers and servers.</li>
<li><code>Reduced Instruction Set Computer</code> (<code>RISC</code>) - Used in <code>ARM</code> and <code>Apple</code> processors, in most smartphones, and some modern laptops.</li>
</ol>
<p>Let us see the pros and cons of each and the main differences between them.</p>
<hr>
<h3 id="cisc">CISC</h3>
<p>The CISC architecture was one of the earliest ISA&#39;s ever developed. As its name suggests, the CISC architecture favors more complex instructions to be run at a time to reduce the overall number of instructions. This is done to rely as much as possible on the CPU by combining minor instructions into more complex instructions.</p>
<p>For example, suppose we were to add two registers with the &#39;<code>add rax, rbx</code>&#39; instruction. In that case, a CISC processor can do this in a single &#39;Fetch-Decode-Execute-Store&#39; instruction cycle, without having to split it into multiple instructions to fetch <code>rax</code>, then fetch <code>rbx</code>, then add them, and then store them in `rax, each of which would take its own &#39;Fetch-Decode-Execute-Store&#39; instruction cycle.</p>
<p>Two main reasons drove this:</p>
<ol>
<li>To enable more instructions to be executed at once by designing the processor to run more advanced instructions in its core.</li>
<li>In the past, memory and transistors were limited, so it was preferred to write shorter programs by combining multiple instructions into one.</li>
</ol>
<p>To enable the processors to execute complex instructions, the processor&#39;s design becomes more complicated, as it is designed to execute a vast amount of different complex instructions, each of which has its own unit to execute it.</p>
<p>Furthermore, even though it takes a single instruction cycle to execute a single instruction, as the instructions are more complex, each instruction cycle takes more clock cycles. This fact leads to more power consumption and heat to execute each instruction.</p>
<hr>
<h3 id="risc">RISC</h3>
<p>The RISC architecture favors splitting instructions into minor instructions, and so the CPU is designed only to handle simple instructions. This is done to relay the optimization to the software by writing the most optimized assembly code.</p>
<p>For example, the same previous <code>add r1, r2, r3</code> instruction on a RISC processor would fetch <code>r2</code>, then fetch <code>r3</code>, add them, and finally store them in <code>r1</code>. Every instruction of these takes an entire &#39;Fetch-Decode-Execute-Store&#39; instruction cycle, which leads, as can be expected, to a larger number of total instructions per program, and hence a longer assembly code.</p>
<p>By not supporting various types of complex instructions, RISC processors only support a limited number of instructions (<code>~200</code>) compared to CISC processors (<code>~1500</code>). So, to execute complex instructions, this has to be done through a combination of minor instructions through Assembly.</p>
<p>It is said that we can build a general-purpose computer with a processor that only supports one instruction! This indicates that we can create very complex instructions using the <code>sub</code> instruction only. Can you think of how this may be achieved?</p>
<p>On the other hand, an advantage of splitting complex instructions into minor ones is having all instructions of the same length either 32-bit or 64-bit long. This enables designing the CPU clock speed around the instruction length so that executing each stage in the instruction cycle would always take precisely one machine clock cycle.</p>
<p>The below diagram shows how CISC instructions take a variable amount of clock cycles, while RISC instructions take a fixed amount: <img src="https://academy.hackthebox.com/storage/modules/85/assembly_cisc_risk_cycles.jpg" alt="Diagram comparing CISC and RISC clock cycles. CISC shows Fetch, Decode, and Execute stages over six phases. RISC shows overlapping Fetch, Decode, and Execute stages for multiple instructions, demonstrating pipelining."></p>
<p>Executing each instruction stage in a single clock cycle and only executing simple instructions leads to RISC processors consuming a fraction of the power consumed by CISC processors, which makes these processors ideal for devices that run on batteries, like smartphones and laptops.</p>
<hr>
<h3 id="cisc-vs-risc">CISC vs. RISC</h3>
<p>The following table summarizes the main differences between CISC and RISC:</p>
<table>
<thead>
<tr>
<th>Area</th>
<th>CISC</th>
<th>RISC</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Complexity</code></td>
<td>Favors complex instructions</td>
<td>Favors simple instructions</td>
</tr>
<tr>
<td><code>Length of instructions</code></td>
<td>Longer instructions - Variable length &#39;multiples of 8-bits&#39;</td>
<td>Shorter instructions - Fixed length &#39;32-bit/64-bit&#39;</td>
</tr>
<tr>
<td><code>Total instructions per program</code></td>
<td>Fewer total instructions - Shorter code</td>
<td>More total instructions - Longer code</td>
</tr>
<tr>
<td><code>Optimization</code></td>
<td>Relies on hardware optimization (in CPU)</td>
<td>Relies on software optimization (in Assembly)</td>
</tr>
<tr>
<td><code>Instruction Execution Time</code></td>
<td>Variable - Multiple clock cycles</td>
<td>Fixed - One clock cycle</td>
</tr>
<tr>
<td><code>Instructions supported by CPU</code></td>
<td>Many instructions (~1500)</td>
<td>Fewer instructions (~200)</td>
</tr>
<tr>
<td><code>Power Consumption</code></td>
<td>High</td>
<td>Very low</td>
</tr>
<tr>
<td><code>Examples</code></td>
<td>Intel, AMD</td>
<td>ARM, Apple</td>
</tr>
</tbody>
</table>
<p>In the past, having a longer assembly code due to a larger number of total instructions per program was a significant disadvantage for RISC processors due to the limited resources in memory and storage. However, today this is no longer as big of an issue, as memory and storage are not as expensive and limited as they used to be in the past.</p>
<p>Furthermore, with new assemblers and compilers writing extremely optimized code on the software level, RISC processors are becoming faster than CISC processors, even in executing and processing heavy applications, all while consuming much less power.</p>
<p>All of this is making RISC processors more common in recent years. RISC may become the dominant architecture in the upcoming years. But as we speak, the overwhelming majority of computers and servers we will be pentesting are running on Intel/AMD processors with the CISC architecture, making learning CISC assembly our priority. As the basics of all Assembly language variants are pretty similar, learning ARM Assembly should be more straightforward after completing this module.</p>
<hr>
<h2 id="registers-addresses-and-data-types">Registers, Addresses, and Data Types</h2>
<hr>
<p>Now that we understand general computer and processor architecture, we need to understand a few assembly elements before we start learning Assembly: <code>Registers</code>, <code>Memory Addresses</code>, <code>Address Endianness</code>, and <code>Data Types</code>. Each of these elements is important, and properly understanding them will help us avoid issues and hours of troubleshooting while writing and debugging assembly code.</p>
<hr>
<h3 id="registers">Registers</h3>
<p>As previously mentioned, each CPU core has a set of registers. The registers are the fastest components in any computer, as they are built within the CPU core. However, registers are very limited in size and can only hold a few bytes of data at a time. There are many registers in the x86 architecture, but we will only focus on the ones necessary for learning basic Assembly and essential for future binary exploitation.</p>
<p>There are two main types of registers we will be focusing on: <code>Data Registers</code> and <code>Pointer Registers</code>.</p>
<table>
<thead>
<tr>
<th><strong>Data Registers</strong></th>
<th><strong>Pointer Registers</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rax</code></td>
<td><code>rbp</code></td>
</tr>
<tr>
<td><code>rbx</code></td>
<td><code>rsp</code></td>
</tr>
<tr>
<td><code>rcx</code></td>
<td><code>rip</code></td>
</tr>
<tr>
<td><code>rdx</code></td>
<td></td>
</tr>
<tr>
<td><code>r8</code></td>
<td></td>
</tr>
<tr>
<td><code>r9</code></td>
<td></td>
</tr>
<tr>
<td><code>r10</code></td>
</tr>
</tbody>
</table>
<ul>
<li><code>Data Registers</code> - are usually used for storing instructions/syscall arguments. The primary data registers are: <code>rax</code>, <code>rbx</code>, <code>rcx</code>, and <code>rdx</code>. The <code>rdi</code> and <code>rsi</code> registers also exist and are usually used for the instruction <code>destination</code> and <code>source</code> operands. Then, we have secondary data registers that can be used when all previous registers are in use, which are <code>r8</code>, <code>r9</code>, and <code>r10</code>.</li>
<li><code>Pointer Registers</code> - are used to store specific important address pointers. The main pointer registers are the Base Stack Pointer <code>rbp</code>, which points to the beginning of the Stack, the Current Stack Pointer <code>rsp</code>, which points to the current location within the Stack (top of the Stack), and the Instruction Pointer <code>rip</code>, which holds the address of the next instruction.</li>
</ul>
<hr>
<h3 id="sub-registers">Sub-Registers</h3>
<p>Each <code>64-bit</code> register can be further divided into smaller sub-registers containing the lower bits, at one byte <code>8-bits</code>, 2 bytes <code>16-bits</code>, and 4 bytes <code>32-bits</code>. Each sub-register can be used and accessed on its own, so we don&#39;t have to consume the full 64-bits if we have a smaller amount of data.</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/assembly_register_parts.jpg" alt="Diagram of a 64-bit register showing subdivisions: RAX (64 bits), EAX (32 bits), AX (16 bits), and AL (8 bits)."></p>
<p>Sub-registers can be accessed as:</p>
<table>
<thead>
<tr>
<th>Size in bits</th>
<th>Size in bytes</th>
<th>Name</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>16-bit</code></td>
<td><code>2 bytes</code></td>
<td>the base name</td>
<td><code>ax</code></td>
</tr>
<tr>
<td><code>8-bit</code></td>
<td><code>1 bytes</code></td>
<td>base name and/or ends with <code>l</code></td>
<td><code>al</code></td>
</tr>
<tr>
<td><code>32-bit</code></td>
<td><code>4 bytes</code></td>
<td>base name + starts with the <code>e</code> prefix</td>
<td><code>eax</code></td>
</tr>
<tr>
<td><code>64-bit</code></td>
<td><code>8 bytes</code></td>
<td>base name + starts with the <code>r</code> prefix</td>
<td><code>rax</code></td>
</tr>
</tbody>
</table>
<p>For example, for the <code>bx</code> data register, the 16-bit is <code>bx</code>, so the 8-bit is <code>bl</code>, the 32-bit would be <code>ebx</code>, and the 64-bit would be <code>rbx</code>. The same goes for pointer registers. If we take the base stack pointer <code>bp</code>, its 16-bit sub-register is <code>bp</code>, so the 8-bit is <code>bpl</code>, the 32-bit is <code>ebp</code>, and the 64-bit is <code>rbp</code>.</p>
<p>The following are the names of the sub-registers for all of the essential registers in an x86_64 architecture:</p>
<table>
<thead>
<tr>
<th>Description</th>
<th>64-bit Register</th>
<th>32-bit Register</th>
<th>16-bit Register</th>
<th>8-bit Register</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Data/Arguments Registers</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Syscall Number/Return value</td>
<td><code>rax</code></td>
<td><code>eax</code></td>
<td><code>ax</code></td>
<td><code>al</code></td>
</tr>
<tr>
<td>Callee Saved</td>
<td><code>rbx</code></td>
<td><code>ebx</code></td>
<td><code>bx</code></td>
<td><code>bl</code></td>
</tr>
<tr>
<td>1st arg - Destination operand</td>
<td><code>rdi</code></td>
<td><code>edi</code></td>
<td><code>di</code></td>
<td><code>dil</code></td>
</tr>
<tr>
<td>2nd arg - Source operand</td>
<td><code>rsi</code></td>
<td><code>esi</code></td>
<td><code>si</code></td>
<td><code>sil</code></td>
</tr>
<tr>
<td>3rd arg</td>
<td><code>rdx</code></td>
<td><code>edx</code></td>
<td><code>dx</code></td>
<td><code>dl</code></td>
</tr>
<tr>
<td>4th arg - Loop counter</td>
<td><code>rcx</code></td>
<td><code>ecx</code></td>
<td><code>cx</code></td>
<td><code>cl</code></td>
</tr>
<tr>
<td>5th arg</td>
<td><code>r8</code></td>
<td><code>r8d</code></td>
<td><code>r8w</code></td>
<td><code>r8b</code></td>
</tr>
<tr>
<td>6th arg</td>
<td><code>r9</code></td>
<td><code>r9d</code></td>
<td><code>r9w</code></td>
<td><code>r9b</code></td>
</tr>
<tr>
<td><strong>Pointer Registers</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Base Stack Pointer</td>
<td><code>rbp</code></td>
<td><code>ebp</code></td>
<td><code>bp</code></td>
<td><code>bpl</code></td>
</tr>
<tr>
<td>Current/Top Stack Pointer</td>
<td><code>rsp</code></td>
<td><code>esp</code></td>
<td><code>sp</code></td>
<td><code>spl</code></td>
</tr>
<tr>
<td>Instruction Pointer &#39;call only&#39;</td>
<td><code>rip</code></td>
<td><code>eip</code></td>
<td><code>ip</code></td>
<td><code>ipl</code></td>
</tr>
</tbody>
</table>
<p>As we go through the module, we&#39;ll discuss how to use each of these registers.</p>
<p>There are other various registers, but we will not cover them in this module, as they are not needed for basic Assembly usage. As an example, there&#39;s the <code>RFLAGS</code> register, which is used to maintain various flags used by the CPU, like the zero flag <code>ZF</code>, which is used for conditional instructions.</p>
<hr>
<h3 id="memory-addresses">Memory Addresses</h3>
<p>As previously mentioned, x86 64-bit processors have 64-bit wide addresses that range from <code>0x0</code> to <code>0xffffffffffffffff</code>, so we expect the addresses to be in this range. However, RAM is segmented into various regions, like the Stack, the heap, and other program and kernel-specific regions. Each memory region has specific <code>read</code>, <code>write</code>, <code>execute</code> permissions that specify whether we can read from it, write to it, or call an address in it.</p>
<p>Whenever an instruction goes through the Instruction Cycle to be executed, the first step is to fetch the instruction from the address it&#39;s located at, as previously discussed. There are several types of address fetching (i.e., addressing modes) in the x86 architecture:</p>
<table>
<thead>
<tr>
<th>Addressing Mode</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Immediate</code></td>
<td>The value is given within the instruction</td>
<td><code>add 2</code></td>
</tr>
<tr>
<td><code>Register</code></td>
<td>The register name that holds the value is given in the instruction</td>
<td><code>add rax</code></td>
</tr>
<tr>
<td><code>Direct</code></td>
<td>The direct full address is given in the instruction</td>
<td><code>call 0xffffffffaa8a25ff</code></td>
</tr>
<tr>
<td><code>Indirect</code></td>
<td>A reference pointer is given in the instruction</td>
<td><code>call 0x44d000</code> or <code>call [rax]</code></td>
</tr>
<tr>
<td><code>Stack</code></td>
<td>Address is on top of the stack</td>
<td><code>add rsp</code></td>
</tr>
</tbody>
</table>
<p>In the above table, lower is slower. The less immediate the value is, the slower it is to fetch it.</p>
<p>Even though speed isn&#39;t our biggest concern when learning basic Assembly, we should understand where and how each address is located. Having this understanding will help us in future binary exploitation, with Buffer Overflow exploits, for example. The same understanding will have an even more significant implication with advanced binary exploitation, like ROP or Heap exploitation.</p>
<hr>
<h3 id="address-endianness">Address Endianness</h3>
<p>An address endianness is the order of its bytes in which they are stored or retrieved from memory. There are two types of endianness: <code>Little-Endian</code> and <code>Big-Endian</code>. With Little-Endian processors, the little-end byte of the address is filled/retrieved first <code>right-to-left</code>, while with Big-Endian processors, the big-end byte is filled/retrieved first <code>left-to-right</code>.</p>
<p>For example, if we have the address <code>0x0011223344556677</code> to be stored in memory, little-endian processors would store the <code>0x00</code> byte on the right-most bytes, and then the <code>0x11</code> byte would be filled after it, so it becomes <code>0x1100</code>, and then the <code>0x22</code> byte, so it becomes <code>0x221100</code>, and so on. Once all bytes are in place, they would look like <code>0x7766554433221100</code>, which is the reverse of the original value. Of course, when retrieving the value back, the processor will also use little-endian retrieval, so the value retrieved would be the same as the original value.</p>
<p>Another example that shows how this can affect the stored values is binary. For example, if we had the 2-byte integer <code>426</code>, its binary representation is <code>00000001 10101010</code>. The order in which these two bytes are stored would change its value. For example, if we stored it in reverse as <code>10101010 00000001</code>, its value becomes <code>43521</code>.</p>
<p>The big-endian processors would store these bytes as <code>00000001 10101010</code> <code>left-to-right</code>, while little-endian processors store them as <code>10101010 00000001</code> <code>right-to-left</code>. When retrieving the value, the processor has to use the same endianness used when storing them, or it will get the wrong value. This indicates that the order in which the bytes are stored/retrieved makes a big difference.</p>
<p>The following table demonstrates how endianness works:</p>
<table>
<thead>
<tr>
<th><strong>Address</strong></th>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
<th><strong>6</strong></th>
<th><strong>7</strong></th>
<th><strong>Address Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Little Endian</strong></td>
<td>77</td>
<td>66</td>
<td>55</td>
<td>44</td>
<td>33</td>
<td>22</td>
<td>11</td>
<td>00</td>
<td>0x</td>
</tr>
<tr>
<td><strong>Big Endian</strong></td>
<td>00</td>
<td>11</td>
<td>22</td>
<td>33</td>
<td>44</td>
<td>55</td>
<td>66</td>
<td>77</td>
<td>0x</td>
</tr>
</tbody>
</table>
<p>Address: 0x0011223344556677</p>
<p>Load Address\</p>
<p>You can click on the &quot;Load Address&quot; button to visualize how each endianness loads data/addresses into memory.</p>
<p>As we can see, this means that an address written in little-endian or in big-endian would refer to different locations in the memory, as it would be read differently by each processor type.</p>
<p>This module will always use little-endian byte order, as it is used with Intel/AMD x86 in most modern operating systems, so the shellcode is always represented right-to-left.</p>
<p><code>The important thing we need to take from this is knowing that our bytes are stored into memory from right-to-left.</code> So, if we were to push an address or a string with Assembly, we would have to push it in reverse. For example, if we want to store the word <code>Hello</code>, we would push its bytes in reverse: <code>o</code>, <code>l</code>, <code>l</code>, <code>e</code>, and finally <code>H</code>.</p>
<p>This may seem a bit counter-intuitive since most people are used to reading from left-to-right. However, this has multiple advantages when processing data, like being able to retrieve a sub-register without having to go through the entire register or being able to perform arithmetic in the correct order right-to-left.</p>
<hr>
<h3 id="data-types">Data Types</h3>
<p>Finally, the x86 architecture supports many types of data sizes, which can be used with various instructions. The following are the most common data types we will be using with instructions:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Length</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>byte</code></td>
<td>8 bits</td>
<td><code>0xab</code></td>
</tr>
<tr>
<td><code>word</code></td>
<td>16 bits - 2 bytes</td>
<td><code>0xabcd</code></td>
</tr>
<tr>
<td><code>double word (dword)</code></td>
<td>32 bits - 4 bytes</td>
<td><code>0xabcdef12</code></td>
</tr>
<tr>
<td><code>quad word (qword)</code></td>
<td>64 bits - 8 bytes</td>
<td><code>0xabcdef1234567890</code></td>
</tr>
</tbody>
</table>
<p><code>Whenever we use a variable with a certain data type or use a data type with an instruction, both operands should be of the same size.</code></p>
<p>For example, we can&#39;t use a variable defined as <code>byte</code> with <code>rax</code>, as <code>rax</code> has a size of 8 bytes. In this case, we would have to use <code>al</code>, which has the same size of 1 byte. The following table shows the appropriate data type for each sub-register:</p>
<table>
<thead>
<tr>
<th>Sub-register</th>
<th>Data Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>al</code></td>
<td><code>byte</code></td>
</tr>
<tr>
<td><code>ax</code></td>
<td><code>word</code></td>
</tr>
<tr>
<td><code>eax</code></td>
<td><code>dword</code></td>
</tr>
<tr>
<td><code>rax</code></td>
<td><code>qword</code></td>
</tr>
</tbody>
</table>
<p>We will discuss this further in the upcoming sections. With all fundamentals of Assembly covered, we can start learning about x86 assembly instructions and writing basic Assembly code.</p>
<hr>
<h2 id="assembly-file-structure">Assembly File Structure</h2>
<hr>
<p>As we learn various Assembly instructions in the coming sections, we&#39;ll constantly be writing code, assembling it, and debugging it. This is the best way to learn what each instruction does. So, we need to learn the basic structure of an Assembly code file and then assemble it and debug it.</p>
<p>In this section, we&#39;ll go through the basic structure of an Assembly file, and in the following two sections, we will cover assembling it and debugging it. We will be working on a template <code>Hello World!</code> Assembly code as a sample, to first learn the general structure of an assembly file and then how to assemble it and debug it. Let us start by taking a look at and dissecting a sample <code>Hello World!</code> Assembly code template:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">         <span class="hljs-meta">global</span>  _start

         <span class="hljs-meta">section</span> .data
<span class="hljs-symbol">message:</span> <span class="hljs-built_in">db</span>      <span class="hljs-string">"Hello HTB Academy!"</span>

         <span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>
         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>
         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rsi</span>, message
         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rdx</span>, <span class="hljs-number">18</span>
         <span class="hljs-keyword">syscall</span>

         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
         <span class="hljs-keyword">syscall</span>
</code></pre>
<p>This Assembly code (once assembled and linked) should print the string &#39;<code>Hello HTB Academy!</code>&#39; to the screen. We won&#39;t go into detail on how this is processed just yet, but we need to understand the main elements of the code template.</p>
<hr>
<h3 id="assembly-file-structure">Assembly File Structure</h3>
<p>First, let&#39;s examine the way the code is distributed:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/nasm_structure.jpg" alt="Assembly code diagram with sections: Directives, Labels, Instructions, and Operands. Shows global, section, db, mov, syscall commands, and a message &#39;Hello HTB Academy!&#39;."></p>
<p>Looking at the vertical parts of the code, each line can have three elements:</p>
<table>
<thead>
<tr>
<th>1. <code>Labels</code></th>
<th>2. <code>Instructions</code></th>
<th>3. <code>Operands</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>We have discussed the <code>instructions</code> and their <code>operands</code> in the previous sections, and we&#39;ll go into detail on various assembly instructions in the coming sections. In addition to that, we can define a <code>label</code> at each line. Each label can be referred to by <code>instructions</code> or by <code>directives</code>.</p>
<p>Next, if we look at the code line-by-line, we see that it has three main parts:</p>
<table>
<thead>
<tr>
<th>Section</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>global _start</code></td>
<td>This is a <code>directive</code> that directs the code to start executing at the <code>_start</code> label defined below.</td>
</tr>
<tr>
<td><code>section .data</code></td>
<td>This is the <code>data</code> section, which should contain all of the variables.</td>
</tr>
<tr>
<td><code>section .text</code></td>
<td>This is the <code>text</code> section containing all of the code to be executed.</td>
</tr>
</tbody>
</table>
<p>Both the <code>.data</code> and <code>.text</code> sections refer to the <code>data</code> and <code>text</code> memory segments, in which these instructions will be stored.</p>
<hr>
<h3 id="directives">Directives</h3>
<p>An Assembly code is line-based, which means that the file is processed line-by-line, executing the instruction of each line. We see at the first line a directive <code>global _start</code>, which instructs the machine to start processing the instructions after the <code>_start</code> label. So, the machine goes to the <code>_start</code> label and starts executing the instructions there, which will print the message on the screen. This will be covered more thoroughly in the <code>Control Instructions</code> sections.</p>
<hr>
<h3 id="variables">Variables</h3>
<p>Next, we have the <code>.data</code> section. The <code>data</code> section holds our variables to make it easier for us to define variables and reuse them without writing them multiple times. Once we run our program, all of our variables will be loaded into memory in the <code>data</code> segment.</p>
<p>When we run the program, it will load any variables we have defined into memory so that they will be ready for usage when we call them. We will notice later in the module that by the time we start executing instructions at the <code>_start</code> label, all of our variables will be already loaded into memory.</p>
<p>We can define variables using <code>db</code> for a list of bytes, <code>dw</code> for a list of words, <code>dd</code> for a list of digits, and so on. We can also label any of our variables so we can call it or reference it later. The following are some examples of defining variables:</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>db 0x0a</code></td>
<td>Defines the byte <code>0x0a</code>, which is a new line.</td>
</tr>
<tr>
<td><code>message db 0x41, 0x42, 0x43, 0x0a</code></td>
<td>Defines the label <code>message =&gt; abc</code>.</td>
</tr>
<tr>
<td><code>message db &quot;Hello World!&quot;, 0x0a</code></td>
<td>Defines the label <code>message =&gt; Hello World!</code>.</td>
</tr>
</tbody>
</table>
<p>Furthermore, we can use the <code>equ</code> instruction with the <code>$</code> token to evaluate an expression, like the length of a defined variable&#39;s string. However, the labels defined with the <code>equ</code> instruction are constants, and they cannot be changed later.</p>
<p>For example, the following code defines a variable and then defines a constant for its length:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-selector-tag">section</span> <span class="hljs-selector-class">.data</span>
    message db <span class="hljs-string">"Hello World!"</span>, <span class="hljs-number">0</span>x0a
    length  equ $-message
</code></pre>
<p>Note: the <code>$</code> token indicates the current distance from the beginning of the current section. As the <code>message</code> variable is at the beginning of the <code>data</code> section, the current location, i.e,. value of <code>$</code>, equals the length of the string. For the scope of this module, we will only use this token to calculate lengths of strings, using the same line of code shown above.</p>
<hr>
<h3 id="code">Code</h3>
<p>The second (and most important) section is the <code>.text</code> section. This section holds all of the assembly instructions and loads them to the <code>text</code> memory segment. Once all instructions are loaded into the <code>text</code> segment, the processor starts executing them one after another.</p>
<p>The default convention is to have the <code>_start</code> label at the beginning of the <code>.text</code> section, which -as per the <code>global _start</code> directive- starts the main code that will be executed as the program runs. As we will see later in the module, we can define other labels within the <code>.text</code> section, for loops and other functions.</p>
<p>The <code>text</code> segment within the memory is read-only, so we cannot write any variables within it. The <code>data</code> section, on the other hand, is read/write, which is why we write our variables to it. However, the <code>data</code> segment within the memory is not executable, so any code we write to it cannot be executed. This separation is part of memory protections to mitigate things like buffer overflows and other types of binary exploitation.</p>
<p>Tip: We can add comments to our assembly code with a semi-colon <code>;</code>. We can use comments to explain the purpose of each part of the code, and what each line is doing. Doing so will save us a lot of time in the future if we ever revisit the code and need to understand it.</p>
<p>With this, we should understand the basic structure of an Assembly file.</p>
<hr>
<h2 id="assembling-disassembling">Assembling &amp; Disassembling</h2>
<hr>
<p>Now that we understand the basic structure and elements of an Assembly file, we can start assembling it using the <code>nasm</code> tool. The entire assembly file structure we learned in the previous section is based on the <code>nasm</code> file structure. Upon assembling our code with <code>nasm</code>, it understands the various parts of the file and then correctly assembles them to be properly run during run time.</p>
<p>After we assemble our code with <code>nasm</code>, we can link it using <code>ld</code> to utilize various OS features and libraries.</p>
<hr>
<h3 id="assembling">Assembling</h3>
<p>First, we will copy the code below into a file called <code>helloWorld.s</code>.</p>
<p>Note: assembly files usually use the <code>.s</code> or the <code>.asm</code> extensions. We will be using <code>.s</code> in this module.</p>
<p>We don&#39;t have to keep using tabs to separate parts of an assembly file, as this was only for demonstration purposes. We can write the following code into our <code>helloWorld.s</code> file:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span> _start

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Hello HTB Academy!"</span>
    length <span class="hljs-built_in">equ</span> $-message

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, message
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, length
    <span class="hljs-keyword">syscall</span>

    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<p>Note how we used <code>equ</code> to dynamically calculate the length of <code>message</code>, instead of using a static <code>18</code>. This will become very handy later on. Once we do, we will assemble the file using <code>nasm</code>, with the following command:</p>
<p>&#x20; Assembling &amp; Disassembling</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ nasm -f elf64 helloWorld.s
</code></pre>
<p>Note: The <code>-f elf64</code> flag is used to note that we want to assemble a 64-bit assembly code. If we wanted to assemble a 32-bit code, we would use <code>-f elf</code>.</p>
<p>This should output a <code>helloWorld.o</code> object file, which is then assembled into machine code, along with the details of all variables and sections. This file is not executable just yet.</p>
<hr>
<h3 id="linking">Linking</h3>
<p>The final step is to link our file using <code>ld</code>. The <code>helloWorld.o</code> object file, though assembled, still cannot be executed. This is because many references and labels used by <code>nasm</code> need to be resolved into actual addresses, along with linking the file with various OS libraries that may be needed.</p>
<p>This is why a Linux binary is called <code>ELF</code>, which stands for an <code>Executable and Linkable Format</code>. To link a file using <code>ld</code>, we can use the following command:</p>
<p>&#x20; Assembling &amp; Disassembling</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ ld -o helloWorld helloWorld.o
</code></pre>
<p>Note: if we were to assemble a 32-bit binary, we need to add the &#39;<code>-m elf_i386</code>&#39; flag.</p>
<p>Once we link the file with <code>ld</code>, we should have the final executable file:</p>
<p>&#x20; Assembling &amp; Disassembling</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ ./helloWorld
Hello HTB Academy!
</code></pre>
<p>We have successfully assembled and linked our first assembly file. We will be assembling, linking, and running our code frequently through this module, so let us build a simple <code>bash</code> script to make it easier:</p>
<p>Code: bash</p>
<pre><code class="lang-bash"><span class="hljs-meta">#!/bin/bash
</span>
fileName=<span class="hljs-string">"<span class="hljs-variable">${1%%.*}</span>"</span> <span class="hljs-comment"># remove .s extension</span>

nasm <span class="hljs-_">-f</span> elf64 <span class="hljs-variable">${fileName}</span><span class="hljs-string">".s"</span>
ld <span class="hljs-variable">${fileName}</span><span class="hljs-string">".o"</span> -o <span class="hljs-variable">${fileName}</span>
[ <span class="hljs-string">"<span class="hljs-variable">$2</span>"</span> == <span class="hljs-string">"-g"</span> ] &amp;&amp; gdb -q <span class="hljs-variable">${fileName}</span> || ./<span class="hljs-variable">${fileName}</span>
</code></pre>
<p>Now we can write this script to <code>assembler.sh</code>, <code>chmod +x</code> it, and then run it on our assembly file. It will assemble it, link it, and run it:</p>
<p>&#x20; Assembling &amp; Disassembling</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ./assembler<span class="hljs-selector-class">.sh</span> helloWorld<span class="hljs-selector-class">.s</span>
Hello HTB Academy!
</code></pre>
<p>Great! Before we move on, let&#39;s disassemble and examine our files to learn more about the process we just did.</p>
<hr>
<h3 id="disassembling">Disassembling</h3>
<p>To disassemble a file, we will use the <code>objdump</code> tool, which dumps machine code from a file and interprets the assembly instruction of each hex code. We can disassemble a binary using the <code>-D</code> flag.</p>
<p>Note: we will also use the flag <code>-M intel</code>, so that <code>objdump</code> would write the instructions in the Intel syntax, which we are using, as we discussed before.</p>
<p>Let&#39;s start by disassembling our final <code>ELF</code> executable file:</p>
<p>&#x20; Assembling &amp; Disassembling</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ objdump -M intel -d helloWorld

helloWorld:     file format elf64-x86-64

Disassembly of section .text:

0000000000401000 &lt;_start&gt;:
  401000:    b8<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00           mov    eax,0x1
  401005:    bf<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00           mov    edi,0x1
  40100a:   <span class="hljs-number"> 48 </span>be<span class="hljs-number"> 00 </span>20<span class="hljs-number"> 40 </span>00<span class="hljs-number"> 00 </span>    movabs rsi,0x402000
  401011:   <span class="hljs-number"> 00 </span>00 00
  401014:    ba<span class="hljs-number"> 12 </span>00<span class="hljs-number"> 00 </span>00           mov    edx,0x12
  401019:    0f<span class="hljs-number"> 05 </span>                   syscall
  40101b:    b8 3c<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>          mov    eax,0x3c
  401020:    bf<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00           mov    edi,0x0
  401025:    0f<span class="hljs-number"> 05 </span>                   syscall
</code></pre>
<p>We see that our original assembly code is highly preserved, with the only change being <code>0x402000</code> used in place of the <code>message</code> variable and replacing the <code>length</code> constant with its value of <code>0x12</code>. We also see that <code>nasm</code> efficiently changed our <code>64-bit</code> registers to the <code>32-bit</code> sub-registers where possible, to use less memory when possible, like changing <code>mov rax, 1</code> to <code>mov eax,0x1</code>.</p>
<p>If we wanted to only show the assembly code, without machine code or addresses, we could add the <code>--no-show-raw-insn --no-addresses</code> flags, as follows:</p>
<p>&#x20; Assembling &amp; Disassembling</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ objdump -M intel --no-show-raw-insn --no-addresses -d helloWorld
<span class="hljs-symbol">
helloWorld:</span>     file format elf64-x86-<span class="hljs-number">64</span>

Disassembly of <span class="hljs-meta">section</span> .text:

&lt;_start&gt;:
        <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x1</span>
        <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>,<span class="hljs-number">0x1</span>
        movabs <span class="hljs-built_in">rsi</span>,<span class="hljs-number">0x402000</span>
        <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>,<span class="hljs-number">0x12</span>
        <span class="hljs-keyword">syscall</span> 
        <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x3c</span>
        <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>,<span class="hljs-number">0x0</span>
        <span class="hljs-keyword">syscall</span>
</code></pre>
<p>Note: Note that <code>objdump</code> has changed the third instruction into <code>movabs</code>. This is the same as <code>mov</code>, so in case you need to reassemble the code, you can change it back to <code>mov</code>.</p>
<p>The <code>-d</code> flag will only disassemble the <code>.text</code> section of our code. To dump any strings, we can use the <code>-s</code> flag, and add <code>-j .data</code> to only examine the <code>.data</code> section. This means that we also do not need to add <code>-M intel</code>. The final command is as follows:</p>
<p>&#x20; Assembling &amp; Disassembling</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ objdump -sj <span class="hljs-selector-class">.data</span> helloWorld

helloWorld:     file format elf64-x86-<span class="hljs-number">64</span>

Contents of <span class="hljs-selector-tag">section</span> <span class="hljs-selector-class">.data</span>:
 <span class="hljs-number">402000</span> <span class="hljs-number">48656</span>c6c <span class="hljs-number">6</span>f204854 <span class="hljs-number">42204163</span> <span class="hljs-number">6164656</span>d  Hello HTB Academ
 <span class="hljs-number">402010</span> <span class="hljs-number">7921</span>                                 y!
</code></pre>
<p>As we can see, the <code>.data</code> section indeed contains the <code>message</code> variable with the string <code>Hello HTB Academy!</code>. This should give us a better idea of how our code was assembled into machine code and how it looks after we assemble it. Next, let us go through the basics of code debugging, which is a critical skill we need to learn.</p>
<hr>
<h2 id="gnu-debugger-gdb-">GNU Debugger (GDB)</h2>
<hr>
<p>Debugging is an important skill to learn for developers and pentesters alike. Debugging is a term used for finding and removing issues (i.e., bugs) from our code, hence the name de-bugging. When we develop a program, we will very frequently run into bugs in our code. It is not efficient to keep changing our code until it does what we expect of it. Instead, we perform debugging by setting breakpoints and seeing how our program acts on each of them and how our input changes between them, which should give us a clear idea of what is causing the <code>bug</code>.</p>
<p>Programs written in high-level languages can set breakpoints on specific lines and run the program through a debugger to monitor how they act. With Assembly, we deal with machine code represented as assembly instructions, so our breakpoints are set in the memory location in which our machine code is loaded, as we will see.</p>
<p>To debug our binaries, we will be using a well-known debugger for Linux programs called <a href="https://www.gnu.org/software/gdb/">GNU Debugger</a> (<code>GDB</code>). There are other similar debuggers for Linux, like <a href="https://www.radare.org/r/">Radare</a> and <a href="https://www.hopperapp.com/">Hopper</a>, and for Windows, like <a href="https://www.immunityinc.com/products/debugger/">Immunity Debugger</a> and <a href="http://wingdb.com/">WinGDB</a>. There are also powerful debuggers available for many platforms, like <a href="https://www.hex-rays.com/products/ida/">IDA Pro</a> and <a href="https://github.com/eteran/edb-debugger">EDB</a>. In this module, we will be using GDB. It is the most reliable for Linux binaries since it is built and maintained directly by GNU, which gives it an excellent integration with the Linux system and its components.</p>
<hr>
<h3 id="installation">Installation</h3>
<p>GDB is installed in many Linux distributions, and it is also installed by default in Parrot OS and PwnBox. In case it is not installed in your VM, you can use <code>apt</code> to install it with the following commands:</p>
<p>&#x20; GNU Debugger (GDB)</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[/htb]$ sudo apt-<span class="hljs-keyword">get</span> update
root<span class="hljs-meta">@htb</span>[/htb]$ sudo apt-<span class="hljs-keyword">get</span> install gdb
</code></pre>
<p>One of the great features of <code>GDB</code> is its support for third-party plugins. An excellent plugin that is well maintained and has good documentation is <a href="https://github.com/hugsy/gef">GEF</a>. GEF is a free and open-source GDB plugin that is built precisely for reverse engineering and binary exploitation. This fact makes it a great tool to learn.</p>
<p>To add GEF to GDB, we can use the following commands:</p>
<p>&#x20; GNU Debugger (GDB)</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ wget -O ~/<span class="hljs-selector-class">.gdbinit-gef</span><span class="hljs-selector-class">.py</span> -<span class="hljs-selector-tag">q</span> https:<span class="hljs-comment">//gef.blah.cat/py</span>
root@htb[/htb]$ echo source ~/<span class="hljs-selector-class">.gdbinit-gef</span><span class="hljs-selector-class">.py</span> &gt;&gt; ~/.gdbinit
</code></pre>
<hr>
<h3 id="getting-started">Getting Started</h3>
<p>Now that we have both tools installed, we can run gdb to debug our <code>HelloWorld</code> binary using the following commands, and GEF will be loaded automatically:</p>
<p>&#x20; GNU Debugger (GDB)</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ gdb -<span class="hljs-selector-tag">q</span> ./helloWorld
..<span class="hljs-selector-class">.SNIP</span>...
gef➤
</code></pre>
<p>As we can see from <code>gef➤</code>, GEF is loaded when GDB is run. If you ever run into any issues with <code>GEF</code>, you can consult with the <a href="https://hugsy.github.io/gef/">GEF Documentation</a>, and you will likely find a solution.</p>
<p>Going forward, we will frequently be assembling and linking our assembly code and then running it with <code>gdb</code>. To do so quickly, we can use the <code>assembler.sh</code> script we wrote in the previous section with the <code>-g</code> flag. It will assemble and link the code, and then run it with <code>gdb</code>, as follows:</p>
<p>&#x20; GNU Debugger (GDB)</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ./assembler<span class="hljs-selector-class">.sh</span> helloWorld<span class="hljs-selector-class">.s</span> -g
..<span class="hljs-selector-class">.SNIP</span>...
gef➤
</code></pre>
<hr>
<h3 id="info">Info</h3>
<p>Once <code>GDB</code> is started, we can use the <code>info</code> command to view general information about the program, like its functions or variables.</p>
<p>Tip: If we want to understand how any command runs within <code>GDB</code>, we can use the <code>help CMD</code> command to get its documentation. For example, we can try executing <code>help info</code></p>
<p><strong>Functions</strong></p>
<p>To start, we will use the <code>info</code> command to check which <code>functions</code> are defined within the binary:</p>
<p>&#x20; GNU Debugger (GDB)</p>
<pre><code class="lang-shell-session">gef➤  info functions

All defined <span class="hljs-keyword">function</span><span class="hljs-variable">s:</span>

Non-debugging symbol<span class="hljs-variable">s:</span>
<span class="hljs-number">0</span>x0000000000401000  _start
</code></pre>
<p>As we can see, we found our main <code>_start</code> function.</p>
<p><strong>Variables</strong></p>
<p>We can also use the <code>info variables</code> command to view all available variables within the program:</p>
<p>&#x20; GNU Debugger (GDB)</p>
<pre><code class="lang-shell-session">gef➤  info <span class="hljs-keyword">variables</span>

All <span class="hljs-comment">defined variables:</span>

Non-debugging <span class="hljs-comment">symbols:</span>
0x0000000000402000  <span class="hljs-comment">message</span>
0x0000000000402012  <span class="hljs-comment">__bss_start</span>
0x0000000000402012  <span class="hljs-comment">_edata</span>
0x0000000000402018  <span class="hljs-comment">_end</span>
</code></pre>
<p>As we can see, we find the <code>message</code>, along with some other default variables that define memory segments. We can do many things with functions, but we will focus on two main points: Disassembly and Breakpoints.</p>
<hr>
<h3 id="disassemble">Disassemble</h3>
<p>To view the instructions within a specific function, we can use the <code>disassemble</code> or <code>disas</code> command along with the function name, as follows:</p>
<p>&#x20; GNU Debugger (GDB)</p>
<pre><code class="lang-shell-session">gef➤  disas _start

Dump of assembler code for function _start:
   <span class="hljs-number">0x0000000000401000</span> &lt;+<span class="hljs-number">0</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x1</span>
   <span class="hljs-number">0x0000000000401005</span> &lt;+<span class="hljs-number">5</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>,<span class="hljs-number">0x1</span>
   <span class="hljs-number">0x000000000040100a</span> &lt;+<span class="hljs-number">10</span>&gt;:    movabs <span class="hljs-built_in">rsi</span>,<span class="hljs-number">0x402000</span>
   <span class="hljs-number">0x0000000000401014</span> &lt;+<span class="hljs-number">20</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>,<span class="hljs-number">0x12</span>
   <span class="hljs-number">0x0000000000401019</span> &lt;+<span class="hljs-number">25</span>&gt;:    <span class="hljs-keyword">syscall</span>
   <span class="hljs-number">0x000000000040101b</span> &lt;+<span class="hljs-number">27</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x3c</span>
   <span class="hljs-number">0x0000000000401020</span> &lt;+<span class="hljs-number">32</span>&gt;:    <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>,<span class="hljs-number">0x0</span>
   <span class="hljs-number">0x0000000000401025</span> &lt;+<span class="hljs-number">37</span>&gt;:    <span class="hljs-keyword">syscall</span>
End of assembler dump.
</code></pre>
<p>As we can see, the output we got closely resembles our assembly code and the disassembly output we got from <code>objdump</code> in the previous section. We need to focus on the main thing from this disassembly: the memory addresses for each instruction and operands (i.e., arguments).</p>
<p><code>Having the memory address is critical for examining the variables/operands and setting breakpoints for a certain instruction.</code></p>
<p>You may notice through debugging that some memory addresses are in the form of <code>0x00000000004xxxxx</code>, rather than their raw address in memory <code>0xffffffffaa8a25ff</code>. This is due to <code>$rip-relative addressing</code> in Position-Independent Executables <code>PIE</code>, in which the memory addresses are used relative to their distance from the instruction pointer <code>$rip</code> within the program&#39;s own Virtual RAM, rather than using raw memory addresses. This feature may be disabled to reduce the risk of binary exploitation.</p>
<p>Next, let us go through the basics of debugging with GDB by using breakpoints, examining data, and stepping through the program.</p>
<hr>
<h2 id="debugging-with-gdb">Debugging with GDB</h2>
<hr>
<p>Now that we have the general information about our program, we will start running it and debugging it. Debugging consists mainly of four steps:</p>
<table>
<thead>
<tr>
<th>Step</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Break</code></td>
<td>Setting breakpoints at various points of interest</td>
</tr>
<tr>
<td><code>Examine</code></td>
<td>Running the program and examining the state of the program at these points</td>
</tr>
<tr>
<td><code>Step</code></td>
<td>Moving through the program to examine how it acts with each instruction and with user input</td>
</tr>
<tr>
<td><code>Modify</code></td>
<td>Modify values in specific registers or addresses at specific breakpoints, to study how it would affect the execution</td>
</tr>
</tbody>
</table>
<p>We will go through these points in this section to learn the basics of debugging a program with GDB.</p>
<hr>
<h3 id="break">Break</h3>
<p>The first step of debugging is setting <code>breakpoints</code> to stop the execution at a specific location or when a particular condition is met. This helps us in examining the state of the program and the value of registers at that point. <code>Breakpoints</code> also allow us to stop the program&#39;s execution at that point so that we can step into each instruction and examine how it changes the program and values.</p>
<p>We can set a breakpoint at a specific address or for a particular function. To set a breakpoint, we can use the <code>break</code> or <code>b</code> command along with the address or function name we want to break at. For example, to follow all instructions run by our program, let&#39;s break at the <code>_start</code> function, as follows:</p>
<p>&#x20; Debugging with GDB</p>
<pre><code class="lang-shell-session">gef➤  <span class="hljs-keyword">b </span>_start

<span class="hljs-keyword">Breakpoint </span><span class="hljs-number">1</span> <span class="hljs-built_in">at</span> <span class="hljs-number">0x401000</span>
</code></pre>
<p>Now, in order to start our program, we can use the <code>run</code> or <code>r</code> command:</p>
<p>&#x20;&#x20;</p>
<pre><code>gef➤  b _start
Breakpoint <span class="hljs-number">1</span> <span class="hljs-meta">at</span> <span class="hljs-number">0x401000</span>
gef➤  r
Starting program: ./helloWorld 

Breakpoint <span class="hljs-number">1</span>, <span class="hljs-number">0x0000000000401000</span> <span class="hljs-keyword">in</span> _start ()
[ Legend: Modified register | Code | Heap | Stack | String ]
───────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rbx</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rcx</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rdx</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rsp</span>   : <span class="hljs-number">0x00007fffffffe310</span>  →  <span class="hljs-number">0x0000000000000001</span>
$<span class="hljs-built_in">rbp</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rsi</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rdi</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rip</span>   : <span class="hljs-number">0x0000000000401000</span>  →  &lt;_start+<span class="hljs-number">0</span>&gt; <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x1</span>
...SNIP...
───────────────────────────────────────────────────────────────────────────────────────── stack ────
<span class="hljs-number">0x00007fffffffe310</span>│+<span class="hljs-number">0x0000</span>: <span class="hljs-number">0x0000000000000001</span>     ← $<span class="hljs-built_in">rsp</span>
<span class="hljs-number">0x00007fffffffe318</span>│+<span class="hljs-number">0x0008</span>: <span class="hljs-number">0x00007fffffffe5a0</span>  →  <span class="hljs-string">"./helloWorld"</span>
...SNIP...
─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0x400ffa</span>                  <span class="hljs-keyword">add</span>    <span class="hljs-built_in">BYTE</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">al</span>
     <span class="hljs-number">0x400ffc</span>                  <span class="hljs-keyword">add</span>    <span class="hljs-built_in">BYTE</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">al</span>
     <span class="hljs-number">0x400ffe</span>                  <span class="hljs-keyword">add</span>    <span class="hljs-built_in">BYTE</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">al</span>
 →   <span class="hljs-number">0x401000</span> &lt;_start+<span class="hljs-number">0</span>&gt;       <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x1</span>
     <span class="hljs-number">0x401005</span> &lt;_start+<span class="hljs-number">5</span>&gt;       <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>, <span class="hljs-number">0x1</span>
     <span class="hljs-number">0x40100a</span> &lt;_start+<span class="hljs-number">10</span>&gt;      movabs <span class="hljs-built_in">rsi</span>, <span class="hljs-number">0x402000</span>
     <span class="hljs-number">0x401014</span> &lt;_start+<span class="hljs-number">20</span>&gt;      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>, <span class="hljs-number">0x12</span>
     <span class="hljs-number">0x401019</span> &lt;_start+<span class="hljs-number">25</span>&gt;      <span class="hljs-keyword">syscall</span> 
     <span class="hljs-number">0x40101b</span> &lt;_start+<span class="hljs-number">27</span>&gt;      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x3c</span>
─────────────────────────────────────────────────────────────────────────────────────── threads ────
[#<span class="hljs-number">0</span>] Id <span class="hljs-number">1</span>, Name: <span class="hljs-string">"helloWorld"</span>, stopped <span class="hljs-number">0x401000</span> <span class="hljs-keyword">in</span> _start (), reason: BREAKPOINT
───────────────────────────────────────────────────────────────────────────────────────── trace ────
[#<span class="hljs-number">0</span>] <span class="hljs-number">0x401000</span> → _start()
────────────────────────────────────────────────────────────────────────────────────────────────────
</code></pre><p>If we want to set a breakpoint at a certain address, like <code>_start+10</code>, we can either <code>b *_start+10</code> or <code>b *0x40100a</code>:</p>
<p>&#x20; Debugging with GDB</p>
<pre><code class="lang-shell-session">gef➤  b *<span class="hljs-number">0x40100a</span>
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x40100a</span>
</code></pre>
<p>The <code>*</code> tells <code>GDB</code> to break at the instruction stored in <code>0x40100a</code>.</p>
<p>Note: Once the program is running, if we set another breakpoint, like <code>b *0x401005</code>, in order to continue to that breakpoint, we should use the <code>continue</code> or <code>c</code> command. If we use <code>run</code> or <code>r</code> again, it will run the program from the start. This can be useful to skip loops, as we will see later in the module.</p>
<p>If we want to see what breakpoints we have at any point of the execution, we can use the <code>info breakpoint</code> command. We can also <code>disable</code>, <code>enable</code>, or <code>delete</code> any breakpoint. Furthermore, GDB also supports setting conditional breaks that stop the execution when a specific condition is met.</p>
<hr>
<h3 id="examine">Examine</h3>
<p>The next step of debugging is <code>examining</code> the values in registers and addresses. As we can see in the previous terminal output, <code>GEF</code> automatically gave us a lot of helpful information when we hit our breakpoint. This is one of the benefits of having the <code>GEF</code> plugin, as it automates many steps that we usually take at every breakpoint, like examining the registers, the stack, and the current assembly instructions.</p>
<p>To manually examine any of the addresses or registers or examine any other, we can use the <code>x</code> command in the format of <code>x/FMT ADDRESS</code>, as <code>help x</code> would tell us. The <code>ADDRESS</code> is the address or register we want to examine, while <code>FMT</code> is the examine format. The examine format <code>FMT</code> can have three parts:</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Count</code></td>
<td>The number of times we want to repeat the examine</td>
<td><code>2</code>, <code>3</code>, <code>10</code></td>
</tr>
<tr>
<td><code>Format</code></td>
<td>The format we want the result to be represented in</td>
<td><code>x(hex)</code>, <code>s(string)</code>, <code>i(instruction)</code></td>
</tr>
<tr>
<td><code>Size</code></td>
<td>The size of memory we want to examine</td>
<td><code>b(byte)</code>, <code>h(halfword)</code>, <code>w(word)</code>, <code>g(giant, 8 bytes)</code></td>
</tr>
</tbody>
</table>
<p><strong>Instructions</strong></p>
<p>For example, if we wanted to examine the next four instructions in line, we will have to examine the <code>$rip</code> register (which holds the address of the next instruction), and use <code>4</code> for the <code>count</code>, <code>i</code> for the <code>format</code>, and <code>g</code> for the <code>size</code> (for 8-bytes or 64-bits). So, the final examine command would be <code>x/4ig $rip</code>, as follows:</p>
<p>&#x20; Debugging with GDB</p>
<pre><code class="lang-shell-session">gef➤  x/<span class="hljs-number">4</span>ig $rip

=&gt; <span class="hljs-number">0</span>x401000 &lt;_start&gt;<span class="hljs-symbol">:</span>    mov    eax,<span class="hljs-number">0</span>x1
   <span class="hljs-number">0</span>x401005 &lt;_start+<span class="hljs-number">5</span>&gt;<span class="hljs-symbol">:</span>    mov    edi,<span class="hljs-number">0</span>x1
   <span class="hljs-number">0</span>x40100a &lt;_start+<span class="hljs-number">10</span>&gt;<span class="hljs-symbol">:</span>    movabs rsi,<span class="hljs-number">0</span>x402000
   <span class="hljs-number">0</span>x401014 &lt;_start+<span class="hljs-number">20</span>&gt;<span class="hljs-symbol">:</span>    mov    edx,<span class="hljs-number">0</span>x12
</code></pre>
<p>We see that we get the following four instructions as expected. This can help us as we go through a program in examining certain areas and what instructions they may contain.</p>
<p><strong>Strings</strong></p>
<p>We can also examine a variable stored at a specific memory address. We know that our <code>message</code> variable is stored at the <code>.data</code> section on address <code>0x402000</code> from our previous disassembly. We also see the upcoming command <code>movabs rsi, 0x402000</code>, so we may want to examine what is being moved from <code>0x402000</code>.</p>
<p>In this case, we will not put anything for the <code>Count</code>, as we only want one address (1 is the default), and will use <code>s</code> as the format to get it in a string format rather than in hex:</p>
<p>&#x20; Debugging with GDB</p>
<pre><code class="lang-shell-session">gef➤  x/s <span class="hljs-number">0x402000</span>

<span class="hljs-number">0x402000</span>:    "Hello HTB Academy!"
</code></pre>
<p>As we can see, we can see the string at this address represented as text rather than hex characters.</p>
<p>Note: if we don&#39;t specify the <code>Size</code> or <code>Format</code>, it will default to the last one we used.</p>
<p><strong>Addresses</strong></p>
<p>The most common format of examining is hex <code>x</code>. We often need to examine addresses and registers containing hex data, such as memory addresses, instructions, or binary data. Let us examine the same previous instruction, but in <code>hex</code> format, to see how it looks:</p>
<p>&#x20; Debugging with GDB</p>
<pre><code class="lang-shell-session">gef➤  x/wx <span class="hljs-number">0x401000</span>

<span class="hljs-number">0x401000</span> &lt;_start&gt;:    <span class="hljs-number">0</span>x<span class="hljs-number">000001b8</span>
</code></pre>
<p>We see instead of <code>mov eax,0x1</code>, we get <code>0x000001b8</code>, which is the hex representation of the <code>mov eax,0x1</code> machine code in little-endian formatting.</p>
<ul>
<li>This is read as: <code>b8 01 00 00</code>.</li>
</ul>
<p>Try repeating the commands we used for examining strings using <code>x</code> to examine them in hex. We should see the same text but in hex format. We can also use <code>GEF</code> features to examine certain addresses. For example, at any point we can use the <code>registers</code> command to print out the current value of all registers:</p>
<p>&#x20; gdb</p>
<pre><code>gef➤  registers
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rdx</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rsp</span>   : 0x00007fffffffe310  →  0x0000000000000001</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbp</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rsi</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rdi</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rip</span>   : 0x0000000000401000  →  &lt;_start+0&gt; mov eax, 0x1</span>
...SNIP...
</code></pre><hr>
<h3 id="step">Step</h3>
<p>The third step of debugging is <code>stepping</code> through the program one instruction or line of code at a time. As we can see, we are currently at the very first instruction in our <code>helloWorld</code> program:</p>
<p>&#x20; gdb</p>
<pre><code>─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0x400ffe</span>                  <span class="hljs-keyword">add</span>    <span class="hljs-built_in">BYTE</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">al</span>
 →   <span class="hljs-number">0x401000</span> &lt;_start+<span class="hljs-number">0</span>&gt;       <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x1</span>
     <span class="hljs-number">0x401005</span> &lt;_start+<span class="hljs-number">5</span>&gt;       <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>, <span class="hljs-number">0x1</span>
</code></pre><p>Note: the instruction shown with the <code>-&gt;</code> symbol is where we are at, and it has not yet been processed.</p>
<p>To move through the program, there are three different commands we can use: <code>stepi</code> and <code>step</code>.</p>
<p><strong>Step Instruction</strong></p>
<p>The <code>stepi</code> or <code>si</code> command will step through the assembly instructions one by one, which is the smallest level of steps possible while debugging. Let us use the <code>si</code> command to see how we get to the next instruction:</p>
<p>&#x20; gdb</p>
<pre><code>─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
gef➤  <span class="hljs-built_in">si</span>
<span class="hljs-number">0x0000000000401005</span> <span class="hljs-keyword">in</span> _start ()
   <span class="hljs-number">0x400fff</span>                  <span class="hljs-keyword">add</span>    <span class="hljs-built_in">BYTE</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0x1</span>], <span class="hljs-number">bh</span>
 →   <span class="hljs-number">0x401005</span> &lt;_start+<span class="hljs-number">5</span>&gt;       <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>, <span class="hljs-number">0x1</span>
     <span class="hljs-number">0x40100a</span> &lt;_start+<span class="hljs-number">10</span>&gt;      movabs <span class="hljs-built_in">rsi</span>, <span class="hljs-number">0x402000</span>
     <span class="hljs-number">0x401014</span> &lt;_start+<span class="hljs-number">20</span>&gt;      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>, <span class="hljs-number">0x12</span>
     <span class="hljs-number">0x401019</span> &lt;_start+<span class="hljs-number">25</span>&gt;      <span class="hljs-keyword">syscall</span> 
─────────────────────────────────────────────────────────────────────────────────────── threads ────
     [#<span class="hljs-number">0</span>] Id <span class="hljs-number">1</span>, Name: <span class="hljs-string">"helloWorld"</span>, stopped <span class="hljs-number">0x401005</span> <span class="hljs-keyword">in</span> _start (), reason: SINGLE STEP
</code></pre><p>As we can see, we took exactly one step and stopped again at the <code>mov edi, 0x1</code> instruction.</p>
<p><strong>Step Count</strong></p>
<p>Similarly to examine, we can repeat the <code>si</code> command by adding a number after it. For example, if we wanted to move 3 steps to reach the <code>syscall</code> instruction, we can do so as follows:</p>
<p>&#x20; gdb</p>
<pre><code>gef➤  <span class="hljs-built_in">si</span> <span class="hljs-number">3</span>
<span class="hljs-number">0x0000000000401019</span> <span class="hljs-keyword">in</span> _start ()
─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0x401004</span> &lt;_start+<span class="hljs-number">4</span>&gt;       <span class="hljs-keyword">add</span>    <span class="hljs-built_in">BYTE</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdi</span>+<span class="hljs-number">0x1</span>], <span class="hljs-number">bh</span>
     <span class="hljs-number">0x40100a</span> &lt;_start+<span class="hljs-number">10</span>&gt;      movabs <span class="hljs-built_in">rsi</span>, <span class="hljs-number">0x402000</span>
     <span class="hljs-number">0x401014</span> &lt;_start+<span class="hljs-number">20</span>&gt;      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edx</span>, <span class="hljs-number">0x12</span>
 →   <span class="hljs-number">0x401019</span> &lt;_start+<span class="hljs-number">25</span>&gt;      <span class="hljs-keyword">syscall</span> 
     <span class="hljs-number">0x40101b</span> &lt;_start+<span class="hljs-number">27</span>&gt;      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">eax</span>, <span class="hljs-number">0x3c</span>
     <span class="hljs-number">0x401020</span> &lt;_start+<span class="hljs-number">32</span>&gt;      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">edi</span>, <span class="hljs-number">0x0</span>
     <span class="hljs-number">0x401025</span> &lt;_start+<span class="hljs-number">37</span>&gt;      <span class="hljs-keyword">syscall</span> 
─────────────────────────────────────────────────────────────────────────────────────── threads ────
[#<span class="hljs-number">0</span>] Id <span class="hljs-number">1</span>, Name: <span class="hljs-string">"helloWorld"</span>, stopped <span class="hljs-number">0x401019</span> <span class="hljs-keyword">in</span> _start (), reason: SINGLE STEP
</code></pre><p>As we can see, we stopped at the <code>syscall</code> instruction as expected.</p>
<p>Tip: You can hit the <code>return</code>/<code>enter</code> empty in order to repeat the last command. Try hitting it at this stage, and you should make another 3 steps, and break at the other <code>syscall</code> instruction.</p>
<p><strong>Step</strong></p>
<p>The <code>step</code> or <code>s</code> command, on the other hand, will continue until the following line of code is reached or until it exits from the current function. If we run an assembly code, it will break when we exit the current function <code>_start</code>.</p>
<p>If there&#39;s a call to another function within this function, it&#39;ll break at the beginning of that function. Otherwise, it&#39;ll break after we exit this function after the program&#39;s end. Let us try using <code>s</code>, and see what happens:</p>
<p>&#x20; Debugging with GDB</p>
<pre><code class="lang-shell-session">gef➤  step

Single stepping until <span class="hljs-keyword">exit</span> from <span class="hljs-keyword">function</span> _start,
which has no line number information.
Hello HTB Academy!
[Inferior <span class="hljs-number">1</span> (process <span class="hljs-number">14732</span>) exited normally]
</code></pre>
<p>We see that the execution continued until we reached the exit from the <code>_start</code> function, so we reached the end of the program and <code>exited normally</code> without any errors. We also see that <code>GDB</code> printed the program&#39;s output <code>Hello HTB Academy!</code> as well.</p>
<p>Note: There&#39;s also the <code>next</code> or <code>n</code> command, which will also continue until the next line, but will skip any functions called in the same line of code, instead of breaking at them like <code>step</code>. There&#39;s also the <code>nexti</code> or <code>ni</code>, which is similar to <code>si</code>, but skips functions calls, as we will see later on in the module.</p>
<hr>
<h3 id="modify">Modify</h3>
<p>The final step of debugging is <code>modifying</code> values in registers and addresses at a certain point of execution. This helps us in seeing how this would affect the execution of the program.</p>
<p><strong>Addresses</strong></p>
<p>To modify values in GDB, we can use the <code>set</code> command. However, we will utilize the <code>patch</code> command in <code>GEF</code> to make this step much easier. Let&#39;s enter <code>help patch</code> in GDB to get its help menu:</p>
<p>&#x20; Debugging with GDB</p>
<pre><code class="lang-shell-session">gef➤  <span class="hljs-keyword">help</span> <span class="hljs-keyword">patch</span>

Write specified <span class="hljs-keyword">values</span> <span class="hljs-keyword">to</span> the specified address.
Syntax: <span class="hljs-keyword">patch</span> (qword|dword|word|<span class="hljs-keyword">byte</span>) LOCATION <span class="hljs-keyword">VALUES</span>
<span class="hljs-keyword">patch</span> <span class="hljs-keyword">string</span> LOCATION <span class="hljs-string">"double-escaped string"</span>
...SNIP...
</code></pre>
<p>As we can see, we have to provide the <code>type/size</code> of the new value, the <code>location</code> to be stored, and the <code>value</code> we want to use. So, let&#39;s try changing the string stored in the <code>.data</code> section (at address <code>0x402000</code> as we saw earlier) to the string <code>Patched!</code>.</p>
<p>We will break at the first <code>syscall</code> at <code>0x401019</code>, and then do the patch, as follows:</p>
<p>&#x20; Debugging with GDB</p>
<pre><code class="lang-shell-session">gef➤  break *<span class="hljs-number">0x401019</span>

Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x401019</span>
gef➤  r
gef➤  patch <span class="hljs-type">string</span> <span class="hljs-number">0x402000</span> <span class="hljs-string">"Patched!<span class="hljs-subst">\\</span>x0a"</span>
gef➤  c

Continuing.
Patched!
 Academy!
</code></pre>
<p>We see that we successfully modified the string and got <code>Patched!\n Academy!</code> instead of the old string. Notice how we used <code>\x0a</code> for adding a new line after our string.</p>
<p><strong>Registers</strong></p>
<p>We also note that we did not replace the entire string. This is because we only modified the characters up to the length of our string and left the remainder of the old string. Finally, the <code>write</code> system call specified a length of <code>0x12</code> of bytes to be printed.</p>
<p>To fix this, let&#39;s modify the value stored in <code>$rdx</code> to the length of our string, which is <code>0x9</code>. We will only patch a size of one byte. We will go into details of how <code>syscall</code> works later in the module. Let us demonstrate using <code>set</code> to modify <code>$rdx</code>, as follows:</p>
<p>&#x20; Debugging with GDB</p>
<pre><code class="lang-shell-session">gef➤  break *<span class="hljs-number">0x401019</span>

Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x401019</span>
gef➤  r
gef➤  patch <span class="hljs-type">string</span> <span class="hljs-number">0x402000</span> <span class="hljs-string">"Patched!<span class="hljs-subst">\\</span>x0a"</span>
gef➤  set $rdx=<span class="hljs-number">0x9</span>
gef➤  c

Continuing.
Patched!
</code></pre>
<p>We see that we successfully modified the final printed string and have the program output something of our choosing. The ability to modify values of registers and addresses will help us a lot through debugging and binary exploitation, as it allows us to test various values and conditions without having to change the code and recompile the binary every time.</p>
<hr>
<h3 id="conclusion">Conclusion</h3>
<p><code>The ability to set breakpoints to stop the execution, step through a program and each of its instructions, examine various data and addresses at each point, and modify values when needed, enables us to do proper debugging and reverse engineering</code>.</p>
<p>Whether we want to see exactly why our program is failing or understand how a program is running and what it&#39;s doing at each point, GDB becomes very handy.</p>
<p>For penetration testing, this process enables us to understand how a program handles input at a certain point and exactly why it&#39;s failing. This allows us to develop exploits that take advantage of such failures, as we will learn in the Binary Exploitation modules.</p>
<hr>
<h2 id="module-project">Module Project</h2>
<hr>
<p>So far, we have learned the basics of computer and CPU architecture and the basics of Assembly language and debugging. We will now start learning various x86 assembly instructions. We are likely to run into these types of instructions during penetration testing and reverse engineering exercises, so understanding how they work gives us the ability to interpret what they are doing and understand what the program is doing.</p>
<p>We will start by learning how to move data and values between registers and memory addresses. Then, we will learn instructions that take one operand (<code>Unary Operations</code>) and instructions with two operands ( <code>Binary Instructions</code>). Later on, we will go through assembly control instructions and shellcoding.</p>
<hr>
<h3 id="fibonacci-sequence">Fibonacci Sequence</h3>
<p>Before we start, however, let&#39;s discuss the program we will be developing throughout this module, using the various instructions we will learn.\
<code>We will be developing a basic Fibonacci sequence calculator using x86 assembly language.</code></p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/fibonacci_sequence.png" alt="Image of a Fibonacci spiral, illustrating a series of connected quarter-circles within squares of increasing size."></p>
<p>At the simplest term, a Fibonacci number is the sum of the two numbers preceding it in the sequence (i.e. <code>F</code><sub><code>n</code></sub><code>``= F</code><sub><code>n-1</code></sub><code>``+ F</code><sub><code>n-2</code></sub>). For example, if we start with <code>F</code><sub><code>0</code></sub><code>=0</code> and <code>F</code><sub><code>1</code></sub><code>=1</code>, then F<sub>2</sub> is <code>F</code><sub><code>1</code></sub><code>``+ F</code><sub><code>0</code></sub>, which is <code>F</code><sub><code>2</code></sub><code>``= 1 + 0 -&gt; 1</code>.\
Following the same formula, F<sub>3</sub> is <code>F</code><sub><code>3</code></sub><code>=1+1=2</code>, F<sub>4</sub> is <code>F</code><sub><code>4</code></sub><code>``= 2 + 1 -&gt; 3</code>, and so on.</p>
<p>If we continue until F<sub>10</sub>, this is the sequence we would have: <code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</code>. As we can see, each number equals the sum of the two before it.</p>
<hr>
<h3 id="golden-ratio">Golden Ratio</h3>
<p>Fibonacci sequence is handy in many fields, like art, mathematics, physics, computer science, and even economics and finance. For example, the Fibonacci sequence is an excellent representation of the golden ratio (<code>or phi Φ</code>), which was used by many artists and architects throughout history and seen everywhere around us in nature:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/golden_ratio_examples_1.jpg" alt="Collage of images showing the Fibonacci spiral overlaid on the Great Pyramid, Mona Lisa, an egg, a rose, a nautilus shell, and a galaxy, illustrating the golden ratio."></p>
<p>Furthermore, many modern designers are using the golden ratio in their designs, most famously in the logos of some known brands:</p>
<p><img src="https://academy.hackthebox.com/storage/modules/85/golden_ratio_logos.jpg" alt="Image showing geometric constructions: overlapping circles on blue, abstract shapes on gray, Pepsi logo with proportions, and a golden rectangle on yellow."></p>
<p>If you are interested in learning more about the Golden Ratio, you can watch <a href="https://youtu.be/4TF6mMUe3FY">this video</a>.</p>
<hr>
<h3 id="final-program">Final Program</h3>
<p>We will be developing a Fibonacci sequence calculator for this module, which allows us to practice various assembly instructions as we learn them and build the program as we go until we have the complete calculator program by the end.</p>
<p>The program will first ask you for the maximum Fibonacci you want to calculate and then print all Fibonacci numbers up to this number. The following example shows us how it would look:</p>
<p>&#x20; Module Project</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ./fib 

Please input max Fn
<span class="hljs-number">100</span>
<span class="hljs-number">1</span>
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">5</span>
<span class="hljs-number">8</span>
<span class="hljs-number">13</span>
<span class="hljs-number">21</span>
<span class="hljs-number">34</span>
<span class="hljs-number">55</span>
<span class="hljs-number">89</span>
</code></pre>
<p>By the end of the module, you will have developed the above program using nothing but Assembly instructions. We can download the final program from <a href="https://academy.hackthebox.com/storage/modules/85/fib.zip">this link</a> and run it to see the final project result.</p>
<hr>
<ol>
<li>\
Page 11</li>
<li>Data Movement</li>
</ol>
<h2 id="data-movement">Data Movement</h2>
<hr>
<p>Let&#39;s start with data movement instructions, which are among the most fundamental instructions in any assembly program. We will frequently use data movement instructions for moving data between addresses, moving data between registers and memory addresses, and loading immediate data into registers or memory addresses. The main <code>Data Movement</code> instructions are:</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mov</code></td>
<td>Move data or load immediate data</td>
<td><code>mov rax, 1</code> -&gt; <code>rax = 1</code></td>
</tr>
<tr>
<td><code>lea</code></td>
<td>Load an address pointing to the value</td>
<td><code>lea rax, [rsp+5]</code> -&gt; <code>rax = rsp+5</code></td>
</tr>
<tr>
<td><code>xchg</code></td>
<td>Swap data between two registers or addresses</td>
<td><code>xchg rax, rbx</code> -&gt; <code>rax = rbx, rbx = rax</code></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="moving-data">Moving Data</h3>
<p>Let&#39;s use the <code>mov</code> instruction as the very first instructions in our module project <code>fibonacci</code>. We will need to load the initial values (<code>F</code><sub><code>0</code></sub><code>=0</code> and <code>F</code><sub><code>1</code></sub><code>=1</code>) to <code>rax</code> and <code>rbx</code>, such that <code>rax = 0</code> and <code>rbx = 1</code>. Let us copy the following code to a <code>fib.s</code> file:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">1</span>
</code></pre>
<p>Now, let&#39;s assemble this code and run it with <code>gdb</code> to see how the <code>mov</code> instruction works in action:</p>
<p>&#x20;&#x20;</p>
<pre><code>$ ./assembler<span class="hljs-selector-class">.sh</span> fib<span class="hljs-selector-class">.s</span> -g
gef➤  <span class="hljs-selector-tag">b</span> _start
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0</span>x401000
gef➤  r
─────────────────────────────────────────────────────────────────────────────────── <span class="hljs-selector-tag">code</span>:x86:<span class="hljs-number">64</span> ────
 →   <span class="hljs-number">0</span>x401000 &lt;_start+<span class="hljs-number">0</span>&gt;       mov    eax, <span class="hljs-number">0</span>x0
     <span class="hljs-number">0</span>x401005 &lt;_start+<span class="hljs-number">5</span>&gt;       mov    ebx, <span class="hljs-number">0</span>x1
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rax</span>   : <span class="hljs-number">0</span>x0
<span class="hljs-variable">$rbx</span>   : <span class="hljs-number">0</span>x0

..<span class="hljs-selector-class">.SNIP</span>...

─────────────────────────────────────────────────────────────────────────────────── <span class="hljs-selector-tag">code</span>:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0</span>x401000 &lt;_start+<span class="hljs-number">0</span>&gt;       mov    eax, <span class="hljs-number">0</span>x0
 →   <span class="hljs-number">0</span>x401005 &lt;_start+<span class="hljs-number">5</span>&gt;       mov    ebx, <span class="hljs-number">0</span>x1
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rax</span>   : <span class="hljs-number">0</span>x0
<span class="hljs-variable">$rbx</span>   : <span class="hljs-number">0</span>x1
</code></pre><p>Like this, we have loaded the initial values into our registers to later perform other operations and instructions on them.</p>
<p>Note: In assembly, moving data does not affect the source operand. So, we can consider <code>mov</code> as a <code>copy</code> function, rather than an actual move.</p>
<hr>
<h3 id="loading-data">Loading Data</h3>
<p>We can load immediate data using the <code>mov</code> instruction. For example, we can load the value of <code>1</code> into the <code>rax</code> register using the <code>mov rax, 1</code> instruction. We have to remember here that <code>the size of the loaded data depends on the size of the destination register</code>. For example, in the above <code>mov rax, 1</code> instruction, since we used the 64-bit register <code>rax</code>, it will be moving a 64-bit representation of the number <code>1</code> (i.e. <code>0x00000001</code>), which is not very efficient.</p>
<p><code>This is why it is more efficient to use a register size that matches our data size</code>. For example, we will get the same result as the above example if we use <code>mov al, 1</code>, since we are moving 1-byte (<code>0x01</code>) into a 1-byte register (<code>al</code>), which is much more efficient. This is evident when we look at the disassembly of both instructions in <code>objdump</code>.</p>
<p>Let us take the following basic assembly code to compare the disassembly of both instructions:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, <span class="hljs-number">1</span>
</code></pre>
<p>Now let&#39;s assemble it and view its shellcode with <code>objdump</code>:</p>
<p>&#x20; Data Movement</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ nasm -f elf64 fib<span class="hljs-selector-class">.s</span> &amp;&amp; objdump -M intel -d fib<span class="hljs-selector-class">.o</span>
..<span class="hljs-selector-class">.SNIP</span>...
<span class="hljs-number">0000000000000000</span> &lt;_start&gt;:
   <span class="hljs-number">0</span>:    b8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>           mov    eax,<span class="hljs-number">0</span>x0
   <span class="hljs-number">5</span>:    bb <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>           mov    ebx,<span class="hljs-number">0</span>x1
   <span class="hljs-selector-tag">a</span>:    b3 <span class="hljs-number">01</span>                    mov    bl,<span class="hljs-number">0</span>x1
</code></pre>
<p>We can see that the shellcode of the first instruction is more than double the size of the last instruction.</p>
<p><code>This understanding will become very handy when writing shellcodes.</code></p>
<p>Let us modify our code to use sub-registers to make it more efficient:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, <span class="hljs-number">1</span>
</code></pre>
<p>The <code>xchg</code> instruction will swap the data between the two registers. Try adding <code>xchg rax, rbx</code> to the end of the code, assemble it, and then run it through <code>gdb</code> to see how it works.</p>
<hr>
<h3 id="address-pointers">Address Pointers</h3>
<p>Another critical concept to understand is using pointers. In many cases, we would see that the register or address we are using does not immediately contain the final value but contains another address that points to the final value. This is always the case with <em>pointer</em> registers, like <code>rsp</code>, <code>rbp</code>, and <code>rip</code>, but is also used with any other register or memory address.</p>
<p>For example, let&#39;s assemble and run <code>gdb</code> on our assembled <code>fib</code> binary, and check the <code>rsp</code> and <code>rip</code> registers:</p>
<p>&#x20; gdb</p>
<pre><code>gdb -<span class="hljs-selector-tag">q</span> ./fib
gef➤  <span class="hljs-selector-tag">b</span> _start
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0</span>x401000
gef➤  r
..<span class="hljs-selector-class">.SNIP</span>...
<span class="hljs-variable">$rsp</span>   : <span class="hljs-number">0</span>x00007fffffffe490  →  <span class="hljs-number">0</span>x0000000000000001
<span class="hljs-variable">$rip</span>   : <span class="hljs-number">0</span>x0000000000401000  →  &lt;_start+<span class="hljs-number">0</span>&gt; mov eax, <span class="hljs-number">0</span>x0
</code></pre><p>We see that both registers contain pointer addresses to other locations. <code>GEF</code> does an excellent job of showing us the final destination value.</p>
<p><strong>Moving Pointer Values</strong></p>
<p>We can see that the <code>rsp</code> register holds the final value of <code>0x1</code>, and its immediate value is a pointer address to <code>0x1</code>. So, if we were to use <code>mov rax, rsp</code>, we won&#39;t be moving the value <code>0x1</code> to <code>rax</code>, but we will be moving the pointer address <code>0x00007fffffffe490</code> to <code>rax</code>.</p>
<p>To move the actual value, we will have to use square brackets <code>[]</code>, which in <code>x86_64</code> assembly and <code>Intel</code> syntax means <code>load value at address</code>. So, in the same above example, if we wanted to move the final value <code>rsp</code> is pointing to, we can wrap <code>rsp</code> in square brackets, like <code>mov rax, [rsp]</code>, and this <code>mov</code> instruction will move the final value rather than the immediate value (which is an address to the final value).</p>
<p>We can use square brackets to compute an address offset relative to a register or another address. For example, we can do <code>mov rax, [rsp+10]</code> to move the value stored 10 address away from <code>rsp</code>.</p>
<p>To properly demonstrate this, let us take the following example code:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rsp</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rsp</span>]
</code></pre>
<p>This is just a simple program to demonstrate this point and see the difference between the two instructions.</p>
<p>Now, let&#39;s assemble the code and run the program with gdb:</p>
<p>&#x20; gdb</p>
<pre><code>$ ./assembler<span class="hljs-selector-class">.sh</span> rsp<span class="hljs-selector-class">.s</span> -g
gef➤  <span class="hljs-selector-tag">b</span> _start
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0</span>x401000
gef➤  r
..<span class="hljs-selector-class">.SNIP</span>...
─────────────────────────────────────────────────────────────────────────────────── <span class="hljs-selector-tag">code</span>:x86:<span class="hljs-number">64</span> ────
 →   <span class="hljs-number">0</span>x401000 &lt;_start+<span class="hljs-number">0</span>&gt;       mov    rax, rsp
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rax</span>   : <span class="hljs-number">0</span>x00007fffffffe490  →  <span class="hljs-number">0</span>x0000000000000001
<span class="hljs-variable">$rsp</span>   : <span class="hljs-number">0</span>x00007fffffffe490  →  <span class="hljs-number">0</span>x0000000000000001
</code></pre><p>As we can see, the <code>mov rax, rsp</code> moved the immediate value stored at <code>rsp</code> (which is a pointer address to <code>rsp</code>) to the <code>rax</code> register.Now let&#39;s press <code>si</code> and check how <code>rax</code> will look after the second instruction:</p>
<p>&#x20; gdb</p>
<pre><code>$ ./assembler<span class="hljs-selector-class">.sh</span> rsp<span class="hljs-selector-class">.s</span> -g
gef➤  <span class="hljs-selector-tag">b</span> _start
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0</span>x401000
gef➤  r
..<span class="hljs-selector-class">.SNIP</span>...
─────────────────────────────────────────────────────────────────────────────────── <span class="hljs-selector-tag">code</span>:x86:<span class="hljs-number">64</span> ────
 →   <span class="hljs-number">0</span>x401003 &lt;_start+<span class="hljs-number">3</span>&gt;       mov    rax, QWORD PTR [rsp]
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rax</span>   : <span class="hljs-number">0</span>x1               
<span class="hljs-variable">$rsp</span>   : <span class="hljs-number">0</span>x00007fffffffe490  →  <span class="hljs-number">0</span>x0000000000000001
</code></pre><p>We can see that this time, the final value of <code>0x1</code> was moved into the <code>rax</code> register.</p>
<p>Note: When using <code>[]</code>, we may need to set the data size before the square brackets, like <code>byte</code> or <code>qword</code>. However, in most cases, <code>nasm</code> will automatically do that for us. We can see above that the final instruction is actually <code>mov rax, QWORD PTR [rsp]</code>. We also see that <code>nasm</code> also added <code>PTR</code> to specify moving a value from a pointer.</p>
<p><strong>Loading Value Pointers</strong></p>
<p>Finally, we need to understand how to load a pointer address to a value, using the <code>lea</code> (or <code>Load Effective Address</code>) instruction, which loads a pointer to the specified value, as in <code>lea rax, [rsp]</code>. This is the opposite of what we just learned above (i.e., load pointer to a value vs. move value from pointer).</p>
<p>In some instances, we need to load the address of a value to a certain register rather than directly load the value in that register. This is usually done when the data is large and would not fit in one register, so the data is placed on the stack or in the heap, and a pointer to its location is stored in the register.</p>
<p>For example, the <code>write</code> syscall we used in our <code>HelloWorld</code> program requires a pointer to the text to be printed, instead of directly providing the text, which may not fit in its entirety in the register, as the register is only 64-bits or 8 bytes.</p>
<p>First, if we wanted to load a direct pointer to a variable or a label, we can still use <code>mov</code> instructions. Since the variable name is a pointer to where it is located in memory, <code>mov</code> will store this pointer to the destination address. For example, both <code>mov rax, rsp</code> and <code>lea rax, [rsp]</code> will do the same thing of storing the pointer to <code>message</code> at <code>rax</code>.</p>
<p>However, if we wanted to load a pointer with an offset (i.e., a few addresses away from a variable or an address), we should use <code>lea</code>. This is why with <code>lea</code> the source operand is usually a variable, a label, or an address wrapped in square brackets, as in <code>lea rax, [rsp+10]</code>. This enables using offsets (i.e., <code>[rsp+10]</code>).</p>
<p>Note that if we use <code>mov rax, [rsp+10]</code>, it will actually move the value at <code>[rsp+10]</code> to <code>rax</code>, as discussed earlier. We cannot move a pointer with an offset using <code>mov</code>.</p>
<p>Let&#39;s take the following example to demonstrate how <code>lea</code> works and how it can differ from <code>mov</code>:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">lea</span> <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rsp</span>+<span class="hljs-number">10</span>]
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rsp</span>+<span class="hljs-number">10</span>]
</code></pre>
<p>Now let&#39;s assemble it and run it with <code>gdb</code>:</p>
<p>&#x20; gdb</p>
<pre><code>$ ./assembler<span class="hljs-selector-class">.sh</span> lea<span class="hljs-selector-class">.s</span> -g
gef➤  <span class="hljs-selector-tag">b</span> _start
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0</span>x401000
gef➤  r
..<span class="hljs-selector-class">.SNIP</span>...
─────────────────────────────────────────────────────────────────────────────────── <span class="hljs-selector-tag">code</span>:x86:<span class="hljs-number">64</span> ────
 →   <span class="hljs-number">0</span>x401003 &lt;_start+<span class="hljs-number">0</span>&gt;       lea    rax, [rsp+<span class="hljs-number">0</span>xa]
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rax</span>   : <span class="hljs-number">0</span>x00007fffffffe49a  →  <span class="hljs-number">0</span>x000000007fffffff
<span class="hljs-variable">$rsp</span>   : <span class="hljs-number">0</span>x00007fffffffe490  →  <span class="hljs-number">0</span>x0000000000000001
</code></pre><p>We see that <code>lea rax, [rsp+10]</code> loaded the address that is 10 addresses away from <code>rsp</code> (in other words, 10 addresses away from top of stack). Now let&#39;s <code>si</code> to see what <code>mov rax, [rsp+10]</code> would do:</p>
<p>&#x20; gdb</p>
<pre><code>─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
 →   <span class="hljs-number">0x401008</span> &lt;_start+<span class="hljs-number">8</span>&gt;       <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rsp</span>+<span class="hljs-number">0xa</span>]
───────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x7fffffff</span>        
$<span class="hljs-built_in">rsp</span>   : <span class="hljs-number">0x00007fffffffe490</span>  →  <span class="hljs-number">0x0000000000000001</span>
</code></pre><p>As expected, we see that <code>mov rax, [rsp+10]</code> moved the value stored there to <code>rax</code>.</p>
<hr>
<h2 id="arithmetic-instructions">Arithmetic Instructions</h2>
<hr>
<p>The second type of basic instructions is Arithmetic Instructions. With Arithmetic Instructions, we can perform various mathematical computations on data stored in registers and memory addresses. These instructions are usually processed by the ALU in the CPU, among other instructions. We will split arithmetic instructions into two types: instructions that take only one operand (<code>Unary</code>), instructions that take two operands (<code>Binary</code>).</p>
<hr>
<h3 id="unary-instructions">Unary Instructions</h3>
<p>The following are the main Unary Arithmetic Instructions (we will assume that <code>rax</code> starts as <code>1</code> for each instruction):</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>inc</code></td>
<td>Increment by 1</td>
<td><code>inc rax</code> -&gt; <code>rax++</code> or <code>rax += 1</code> -&gt; <code>rax = 2</code></td>
</tr>
<tr>
<td><code>dec</code></td>
<td>Decrement by 1</td>
<td><code>dec rax</code> -&gt; <code>rax--</code> or <code>rax -= 1</code> -&gt; <code>rax = 0</code></td>
</tr>
</tbody>
</table>
<p>Let&#39;s practice these instructions by going back to our <code>fib.s</code> code. So far, we have initialized <code>rax</code> and <code>rbx</code> with our initial values <code>0</code> and <code>1</code> with the <code>mov</code> instruction. Instead of moving the immediate value of <code>1</code> to <code>bl</code>, let&#39;s move <code>0</code> to it, and then use <code>inc</code> to make it <code>1</code>:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start
<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bl</span>
</code></pre>
<p>Remember, we used <code>al</code> instead of <code>rax</code> for efficiency. Now, let us assemble our code, and run it with <code>gdb</code>:</p>
<p>&#x20;&#x20;</p>
<pre><code>$ ./assembler<span class="hljs-selector-class">.sh</span> fib<span class="hljs-selector-class">.s</span> -g
..<span class="hljs-selector-class">.SNIP</span>...

─────────────────────────────────────────────────────────────────────────────────── <span class="hljs-selector-tag">code</span>:x86:<span class="hljs-number">64</span> ────
 →   <span class="hljs-number">0</span>x401005 &lt;_start+<span class="hljs-number">5</span>&gt;      mov    al, <span class="hljs-number">0</span>x0
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rbx</span>   : <span class="hljs-number">0</span>x0

..<span class="hljs-selector-class">.SNIP</span>...

─────────────────────────────────────────────────────────────────────────────────── <span class="hljs-selector-tag">code</span>:x86:<span class="hljs-number">64</span> ────
 →   <span class="hljs-number">0</span>x40100a &lt;_start+<span class="hljs-number">10</span>&gt;      inc    bl
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rbx</span>   : <span class="hljs-number">0</span>x1
</code></pre><p>As we can see, <code>rbx</code> started with the value <code>0</code>, and with <code>inc rbx</code>, it was incremented to <code>1</code>. The <code>dec</code> instruction is similar to <code>inc</code>, but decrements by <code>1</code> instead of incrementing.</p>
<p><code>This knowledge will become very handy later on.</code></p>
<hr>
<h3 id="binary-instructions">Binary Instructions</h3>
<p>Next, we have Binary Arithmetic Instructions, and the main ones are: We&#39;ll assume that both <code>rax</code> and <code>rbx</code> start as <code>1</code> for each instruction.</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add</code></td>
<td>Add both operands</td>
<td><code>add rax, rbx</code> -&gt; <code>rax = 1 + 1</code> -&gt; <code>2</code></td>
</tr>
<tr>
<td><code>sub</code></td>
<td>Subtract Source from Destination (<em>i.e <code>rax = rax - rbx</code></em>)</td>
<td><code>sub rax, rbx</code> -&gt; <code>rax = 1 - 1</code> -&gt; <code>0</code></td>
</tr>
<tr>
<td><code>imul</code></td>
<td>Multiply both operands</td>
<td><code>imul rax, rbx</code> -&gt; <code>rax = 1 * 1</code> -&gt; <code>1</code></td>
</tr>
</tbody>
</table>
<p><code>Note that in all of the above instructions, the result is always stored in the destination operand, while the source operand is not affected.</code></p>
<p>Let&#39;s start by discussing the <code>add</code> instruction. Adding two numbers is the core step of calculating a Fibonacci Sequence, since the current Fibonacci number (<code>F</code><sub><code>n</code></sub>) is the sum of the two preceding it (<code>F</code><sub><code>n</code></sub><code>``= F</code><sub><code>n-1</code></sub><code>``+ F</code><sub><code>n-2</code></sub>).</p>
<p>So, let&#39;s add <code>add rax, rbx</code> to the end of our <code>fib.s</code> code:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">0</span>
   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>, <span class="hljs-number">0</span>
   <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bl</span>
   <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>
</code></pre>
<p>Now, let&#39;s assemble our code, and run it with <code>gdb</code>:</p>
<p>&#x20; gdb</p>
<pre><code>$ ./assembler<span class="hljs-selector-class">.sh</span> fib<span class="hljs-selector-class">.s</span> -g
gef➤  <span class="hljs-selector-tag">b</span> _start
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0</span>x401000
gef➤  r
..<span class="hljs-selector-class">.SNIP</span>...

─────────────────────────────────────────────────────────────────────────────────── <span class="hljs-selector-tag">code</span>:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0</span>x401004 &lt;_start+<span class="hljs-number">4</span>&gt;       inc    bl
 →   <span class="hljs-number">0</span>x401006 &lt;_start+<span class="hljs-number">6</span>&gt;       add    rax, rbx
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rax</span>   : <span class="hljs-number">0</span>x1
<span class="hljs-variable">$rbx</span>   : <span class="hljs-number">0</span>x1
</code></pre><p>As we can see, after the instruction is processed, <code>rax</code> is equal to <code>0x1 + 0x0</code>, which is <code>0x1</code>. Using the same principle, if we had other Fibonacci numbers in <code>rax</code> and <code>rbx</code>, we&#39;d get the new Fibonacci using add.</p>
<p>Both <code>sub</code> and <code>imul</code> are similar to <code>add</code>, as shown in the examples in the previous table. Try adding <code>sub</code> and <code>imul</code> to the above code, assemble it, and then run it <code>gdb</code> to see how they work.</p>
<hr>
<h3 id="bitwise-instructions">Bitwise Instructions</h3>
<p>Now, let&#39;s move to Bitwise Instructions, which are instructions that work on the bit level (we&#39;ll assume that <code>rax = 1</code> and <code>rbx = 2</code> for each instruction):</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>not</code></td>
<td>Bitwise NOT (invert all bits, 0-&gt;1 and 1-&gt;0)</td>
<td><code>not rax</code> -&gt; <code>NOT 00000001</code> -&gt; <code>11111110</code></td>
</tr>
<tr>
<td><code>and</code></td>
<td>Bitwise AND (if both bits are 1 -&gt; 1, if bits are different -&gt; 0)</td>
<td><code>and rax, rbx</code> -&gt; <code>00000001 AND 00000010</code> -&gt; <code>00000000</code></td>
</tr>
<tr>
<td><code>or</code></td>
<td>Bitwise OR (if either bit is 1 -&gt; 1, if both are 0 -&gt; 0)</td>
<td><code>or rax, rbx</code> -&gt; <code>00000001 OR 00000010</code> -&gt; <code>00000011</code></td>
</tr>
<tr>
<td><code>xor</code></td>
<td>Bitwise XOR (if bits are the same -&gt; 0, if bits are different -&gt; 1)</td>
<td><code>xor rax, rbx</code> -&gt; <code>00000001 XOR 00000010</code> -&gt; <code>00000011</code></td>
</tr>
</tbody>
</table>
<p>These instructions may look confusing at first, but they are straightforward once we understand them. Each of these instructions makes the specified instruction on each bit of the value. For example, <code>not</code> will go to each bit and invert it, turning <code>0</code>&#39;s to <code>1</code>&#39;s and turning <code>1</code>&#39;s to <code>0</code>&#39;s. Try adding <code>not rax</code> to the end of our previous code, assemble it, and then run it with <code>gdb</code> to see how it works.</p>
<p>Likewise, both the <code>and</code>/<code>or</code> instructions work on each bit, and perform the <code>AND</code>/<code>OR</code> gate on each one, as shown in the examples above. Each of these instructions has its use cases in Assembly.</p>
<p>However, the instruction we will be using the most is <code>xor</code>. The <code>xor</code> instruction has various use cases, but since it zeros similar bits, we can use it to turn any value to 0 by <code>xor</code>ing a value with itself. We need to put, <code>using xor on any register with itself will turn it into 0</code>.</p>
<p>For example, if we want to turn the <code>rax</code> register to <code>0</code>, the most efficient way to do it is <code>xor rax, rax</code>, which will make <code>rax = 0</code>. This is simply because all bits of <code>rax</code> are similar, and so <code>xor</code> will turn all of them to <code>0</code>. Going back to our previous <code>fib.s</code> code, instead of moving <code>0</code> to both <code>rax</code> and <code>rbx</code>, we can use <code>xor</code> on each of them, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>
</code></pre>
<p>This code should perform the exact same operations, but now in a more efficient way. Let&#39;s assemble our code, and run it with <code>gdb</code>:</p>
<p>&#x20; gdb</p>
<pre><code>$ ./assembler<span class="hljs-selector-class">.sh</span> fib<span class="hljs-selector-class">.s</span> -g
gef➤  <span class="hljs-selector-tag">b</span> _start
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0</span>x401000
gef➤  r
..<span class="hljs-selector-class">.SNIP</span>...

─────────────────────────────────────────────────────────────────────────────────── <span class="hljs-selector-tag">code</span>:x86:<span class="hljs-number">64</span> ────
 →   <span class="hljs-number">0</span>x401001 &lt;_start+<span class="hljs-number">1</span>&gt;       xor    eax, eax
     <span class="hljs-number">0</span>x401003 &lt;_start+<span class="hljs-number">3</span>&gt;       xor    ebx, ebx
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rax</span>   : <span class="hljs-number">0</span>x0
<span class="hljs-variable">$rbx</span>   : <span class="hljs-number">0</span>x0

..<span class="hljs-selector-class">.SNIP</span>...

─────────────────────────────────────────────────────────────────────────────────── <span class="hljs-selector-tag">code</span>:x86:<span class="hljs-number">64</span> ────
 →   <span class="hljs-number">0</span>x40100c                  add    BYTE PTR [rax], al
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rax</span>   : <span class="hljs-number">0</span>x1
<span class="hljs-variable">$rbx</span>   : <span class="hljs-number">0</span>x1
</code></pre><p>As we can see, <code>xor</code>ing our registers with themselves turned each of them to <code>0</code>&#39;s, and the rest of the code performed the same operations as earlier, so we ended up with the same final values for both <code>rax</code> and <code>rbx</code>.</p>
<hr>
<h2 id="loops">Loops</h2>
<hr>
<p>Now that we have covered the basic instructions, we can start learning <code>Program Control Instructions</code>. As we already know, Assembly code is line-based, so it will always look to the following line for instructions to process. However, as we can expect, most programs do not follow a simple set of sequential steps but usually have a more complex structure.</p>
<p>This is where <code>Control</code> instructions come in. Such instructions allow us to change the flow of the program and direct it to another line. There are many examples of how this can be done. We have already discussed <code>Directives</code> that tell the program to direct the execution to a specific label.</p>
<p>Other types of <code>Control Instructions</code> include:</p>
<table>
<thead>
<tr>
<th><code>Loops</code></th>
<th><code>Branching</code></th>
<th><code>Function Calls</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="loop-structure">Loop Structure</h3>
<p>Let&#39;s start by discussing <code>Loops</code>. A loop in assembly is a set of instructions that repeat for <code>rcx</code> times. Let&#39;s take the following example:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-symbol">exampleLoop:</span>
    <span class="hljs-keyword">instruction </span><span class="hljs-number">1</span>
    <span class="hljs-keyword">instruction </span><span class="hljs-number">2</span>
    <span class="hljs-keyword">instruction </span><span class="hljs-number">3</span>
    <span class="hljs-keyword">instruction </span><span class="hljs-number">4</span>
    <span class="hljs-keyword">instruction </span><span class="hljs-number">5</span>
    loop exampleLoop
</code></pre>
<p>Once the assembly code reaches <code>exampleLoop</code>, it will start executing the instructions under it. We should set the number of iterations we want the loop to go through in the <code>rcx</code> register. Every time the loop reaches the <code>loop</code> instruction, it will decrease <code>rcx</code> by <code>1</code> (i.e., <code>dec rcx</code>) and jump back to the specified label, <code>exampleLoop</code> in this case. So, before we enter any loop, we should <code>mov</code> the number of loop iterations we want to the <code>rcx</code> register.</p>
<table>
<thead>
<tr>
<th><strong>Instruction</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>mov rcx, x</code></td>
<td>Sets loop (<code>rcx</code>) counter to <code>x</code></td>
<td><code>mov rcx, 3</code></td>
</tr>
<tr>
<td><code>loop</code></td>
<td>Jumps back to the start of <code>loop</code> until counter reaches <code>0</code></td>
<td><code>loop exampleLoop</code></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="loopfib">loopFib</h3>
<p>To demonstrate this, let&#39;s go back to our <code>fib.s</code> code:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>
</code></pre>
<p>Since any current Fibonacci number is the sum of the two numbers preceding it, we can automate this with a loop. Let&#39;s assume that the current number is stored in <code>rax</code>, so it is <code>F</code><sub><code>n</code></sub>, and the next number is stored in <code>rbx</code>, so it is <code>F</code><sub><code>n+1</code></sub>.</p>
<p>Starting with the last number as <code>0</code> and the current number as <code>1</code>, we can have our loop as follows:</p>
<ol>
<li>Get next number with <code>0 + 1 = 1</code></li>
<li>Move the current number to the last number (<code>1 in place of 0</code>)</li>
<li>Move the next number to the current number (<code>1 in place of 1</code>)</li>
<li>Loop</li>
</ol>
<p>If we do this, we&#39;ll end up with <code>1</code> as the last number and <code>1</code> as the current number. If we loop again, we&#39;ll get <code>1</code> as the last number and <code>2</code> as the current number. So, let&#39;s implement this as assembly instructions. Since we can discard the last number <code>0</code> after we use it in the add, let&#39;s store the result in its place:</p>
<ul>
<li><code>add rax, rbx</code></li>
</ul>
<p>We need to move the current number to the last number&#39;s place and move the following number to the current number. However, we have the following number in <code>rax</code> and the now old number in <code>rbx</code>, so they are swapped. Can you think of any instruction to swap them?</p>
<p>Let&#39;s use the <code>xchg</code> instruction to swap both numbers:</p>
<ul>
<li><code>xchg rax, rbx</code></li>
</ul>
<p>Now we can simply <code>loop</code>. However, before we enter a loop, we should set <code>rcx</code> to the count of iterations we want. Let&#39;s start with <code>10</code> iterations and add it after initializing the <code>rax</code> and <code>rbx</code> to <code>0</code> and <code>1</code>:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rcx</span>, <span class="hljs-number">10</span>
</code></pre>
<p>Now we can define our loop as discussed above:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-symbol">loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">loop</span> loopFib
</code></pre>
<p>So, our final code is:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rcx</span>, <span class="hljs-number">10</span>
<span class="hljs-symbol">loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">loop</span> loopFib
</code></pre>
<hr>
<h3 id="loop-loopfib">Loop loopFib</h3>
<p>Let&#39;s assemble our code, and run it with <code>gdb</code>. We&#39;ll break at <code>b loopFib</code>, so that we can examine the code at each iteration of the loop. We see the following register values before the first iteration:</p>
<p>&#x20; gdb</p>
<pre><code>$ ./assembler<span class="hljs-selector-class">.sh</span> fib<span class="hljs-selector-class">.s</span> -g
gef➤  <span class="hljs-selector-tag">b</span> loopFib
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0</span>x40100e
gef➤  r
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-variable">$rax</span>   : <span class="hljs-number">0</span>x0
<span class="hljs-variable">$rbx</span>   : <span class="hljs-number">0</span>x1
<span class="hljs-variable">$rcx</span>   : <span class="hljs-number">0</span>xa
</code></pre><p>We see that we start with <code>rax = 0</code> and <code>rbx = 1</code>. Let&#39;s press <code>c</code> to continue to the next iteration:</p>
<p>&#x20; gdb</p>
<pre><code>───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x1</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x1</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x9</span>
</code></pre><p>Now we have <code>1</code> and <code>1</code>, as expected, with <code>9</code> iterations left. Let&#39;s <code>c</code>ontinue again:</p>
<p>&#x20; gdb</p>
<pre><code>───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x1</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x2</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x8</span>
</code></pre><p>Now we are at <code>1</code> and <code>2</code>. Let&#39;s check the next three iterations:</p>
<p>&#x20; gdb</p>
<pre><code>───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x2</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x3</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x7</span>
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x3</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x5</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x6</span>
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x5</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x8</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x5</span>
</code></pre><p>As we can see, the script is successfully calculating the Fibonacci Sequence as <code>0, 1, 1, 2, 3, 5, 8</code>. Let&#39;s continue to the last iteration, where <code>rbx</code> should be <code>55</code>:</p>
<p>&#x20; gdb</p>
<pre><code>───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x22</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x37</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x1</span>
</code></pre><p>We see that <code>rbx</code> is <code>0x37</code>, equal to <code>55</code> in decimal. We can confirm that with the <code>p/d $rbx</code> command:</p>
<p>&#x20; Loops</p>
<pre><code class="lang-shell-session">gef➤  p/d <span class="hljs-symbol">$</span>rbx

<span class="hljs-meta"><span class="hljs-meta-keyword">$3</span> = 55</span>
</code></pre>
<p>As we can see, we have successfully used loops to automate the calculation of the Fibonacci Sequence. Try increasing <code>rcx</code> to see what are the next numbers in the Fibonacci Sequence.</p>
<hr>
<h2 id="unconditional-branching">Unconditional Branching</h2>
<hr>
<p>The second type of <code>Control Instructions</code> is <code>Branching Instructions</code>, which are general instructions that allow us to <code>jump</code> to any point in the program if a specific condition is met. Let&#39;s first discuss the most basic branching instruction: <code>jmp</code>, which will always jump to a location unconditionally.</p>
<hr>
<h3 id="jmp-loopfib">JMP loopFib</h3>
<p>The <code>jmp</code> instruction jumps the program to the label or specified location in its operand so that the program&#39;s execution is continued there. Once a program&#39;s execution is directed to another location, it will continue processing instructions from that point. If we wanted to temporarily jump to a point and then return to the original calling point, we would use functions, which we will discuss in the next section.</p>
<p>The basic <code>jmp</code> instruction is unconditional, which means that it will always jump to the specified location, regardless of the conditions. This contrasts with <code>Conditional Branching</code> instructions that only jump if a specific condition is met, which we&#39;ll discuss next.</p>
<table>
<thead>
<tr>
<th><strong>Instruction</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jmp</code></td>
<td>Jumps to specified label, address, or location</td>
<td><code>jmp loop</code></td>
</tr>
</tbody>
</table>
<p>Let&#39;s try using <code>jmp</code> in our <code>fib.s</code> program, and see how it would change the execution flow. Instead of looping back to <code>loopFib</code>, let&#39;s <code>jmp</code> there instead: So, our final code is:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rcx</span>, <span class="hljs-number">10</span>
<span class="hljs-symbol">loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">jmp</span> loopFib
</code></pre>
<p>Now, let&#39;s assemble our code, and run it with <code>gdb</code>. We&#39;ll once again <code>b loopFib</code>, and see how it changes:</p>
<p>&#x20;&#x20;</p>
<pre><code><span class="hljs-symbol">$</span> ./assembler.sh fib.s -g
gef➤  b loopFib
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x40100e</span>
gef➤  r
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x1               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0xa               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0xa               </span>
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x1               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x1               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0xa               </span>
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x1               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x2               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0xa               </span>
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x2               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x3               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0xa               </span>
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x3               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x5               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0xa               </span>
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x5               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x8               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0xa</span>
</code></pre><p>We press <code>c</code> a few times to let the program jump multiple times back to <code>loopFib</code>. As we can see, the program is still performing the same function and still correctly calculating the Fibonacci Sequence. However, <code>the main difference from the loop is that &#39;rcx&#39; is not decrementing.</code> This is because a <code>jmp</code> instruction does not consider <code>rcx</code> as a counter (like <code>loop</code> does), and so it will not automatically decrement it.</p>
<p>Let&#39;s delete our break point with <code>del 1</code>, and press <code>c</code> to see to what end the program will run:</p>
<p>&#x20; gdb</p>
<pre><code>gef➤  info break
Num     Type           Disp Enb Address            What
<span class="hljs-number">1</span>       breakpoint     keep y   <span class="hljs-number">0x000000000040100e</span> &lt;loopFib&gt;
    breakpoint already hit <span class="hljs-number">6</span> <span class="hljs-built_in">times</span>
gef➤  del <span class="hljs-number">1</span>
gef➤  c
Continuing.

Program received signal SIGINT, Interrupt.
<span class="hljs-number">0x000000000040100e</span> <span class="hljs-keyword">in</span> loopFib ()
───────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x2e02a93188557fa9</span>
$<span class="hljs-built_in">rbx</span>   : <span class="hljs-number">0x903b4b15ce8cedf0</span>
$<span class="hljs-built_in">rcx</span>   : <span class="hljs-number">0xa</span>
</code></pre><p>We noticed that the program kept running until we pressed <code>ctrl+c</code> after a few seconds to kill it, by which point the Fibonacci number has reached <code>0x903b4b15ce8cedf0</code> (which is a huge number). This is because of the unconditional <code>jmp</code> instruction, which keeps jumping back to <code>loopFib</code> forever since a specific condition does not restrict it. This is similar to a <code>(while true)</code> loop.</p>
<p>This is why unconditional Branching is usually used in cases where need always to jump, and it is not suitable for loops, as it will loop forever. To stop jumping when a specific condition is met, we will use <code>Conditional Branching</code> for our next steps.</p>
<hr>
<h2 id="conditional-branching">Conditional Branching</h2>
<hr>
<p>Unlike Unconditional Branching Instructions, <code>Conditional Branching</code> instructions are only processed when a specific condition is met, based on the Destination and Source operands. A conditional jump instruction has multiple varieties as <code>Jcc</code>, where <code>cc</code> represents the Condition Code. The following are some of the main condition codes:</p>
<table>
<thead>
<tr>
<th><strong>Instruction</strong></th>
<th><strong>Condition</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>jz</code></td>
<td><code>D = 0</code></td>
<td>Destination <code>equal to Zero</code></td>
</tr>
<tr>
<td><code>jnz</code></td>
<td><code>D != 0</code></td>
<td>Destination <code>Not equal to Zero</code></td>
</tr>
<tr>
<td><code>js</code></td>
<td><code>D &lt; 0</code></td>
<td>Destination <code>is Negative</code></td>
</tr>
<tr>
<td><code>jns</code></td>
<td><code>D &gt;= 0</code></td>
<td>Destination <code>is Not Negative</code> (i.e. 0 or positive)</td>
</tr>
<tr>
<td><code>jg</code></td>
<td><code>D &gt; S</code></td>
<td>Destination <code>Greater than</code> Source</td>
</tr>
<tr>
<td><code>jge</code></td>
<td><code>D &gt;= S</code></td>
<td>Destination <code>Greater than or Equal</code> Source</td>
</tr>
<tr>
<td><code>jl</code></td>
<td><code>D &lt; S</code></td>
<td>Destination <code>Less than</code> Source</td>
</tr>
<tr>
<td><code>jle</code></td>
<td><code>D &lt;= S</code></td>
<td>Destination <code>Less than or Equal</code> Source</td>
</tr>
</tbody>
</table>
<p>There are many other similar conditions that we can utilize as well. For a complete list of conditions, we can refer to the latest Intel <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf#page=585">x86_64 manual</a>, in the <code>Jcc-Jump if Condition Is Met</code> section. Conditional instructions are not restricted to <code>jmp</code> instructions only but are also used with other assembly instructions for conditional use as well, like the <code>CMOVcc</code> and <code>SETcc</code> instructions.</p>
<p>For example, if we wanted to perform a <code>mov rax, rbx</code> instruction, but only if the condition is <code>= 0</code>, then we can use the <code>CMOVcc</code> or <code>conditional mov</code> instruction, such as <code>cmovz rax, rbx</code> instruction. Similarly, if we wanted to move if the condition is <code>&lt;</code>, then we can use the <code>cmovl rax, rbx</code> instruction, and so on for other conditions. The same applies to the <code>set</code> instruction, which sets the operand&#39;s byte to <code>1</code> if the condition is met or <code>0</code> otherwise. An example of this is <code>setz rax</code>.</p>
<hr>
<h3 id="rflags-register">RFLAGS Register</h3>
<p>We have been talking about meeting certain conditions, but we have not yet discussed how these conditions are met or where they are stored. This is where we use the <code>RFLAGS</code> register, which we briefly mentioned in the Registers section.</p>
<p>The <code>RFLAGS</code> register consists of 64-bits like any other register. However, this register does not hold values but holds flag bits instead. Each bit &#39;or set of bits&#39; turns to <code>1</code> or <code>0</code> depending on the value of the last instruction.</p>
<p><code>Arithmetic instructions set the necessary &#39;RFLAG&#39; bits depending on their outcome.</code> For example, if a <code>dec</code> instruction resulted in a <code>0</code>, then bit <code>#6</code>, the Zero Flag <code>ZF</code>, turns to <code>1</code>. Likewise, whenever the bit <code>#6</code> is <code>0</code>, it means that the Zero Flag is off. Similarly, if a division instruction results in a float number, then the Carry Flag <code>CF</code> bit is turned on, or if a <code>sub</code> instruction resulted in a negative value, then the Sign Flag <code>SF</code> is turned on, and so on.</p>
<p>Note: When <code>ZF</code> is on (i.e. is <code>1</code>), it&#39;s referred to as Zero <code>ZR</code>, and when it&#39;s off (i.e. is <code>0</code>), it&#39;s referred to as Not Zero <code>NZ</code>. This naming may match the condition code used in the instructions, like <code>jnz</code> which jumps with <code>NZ</code>. But to avoid any confusion, let&#39;s simply focus on the flag name.</p>
<p>There are many flags within an assembly program, and each of them has its own bit(s) in the <code>RFLAGS</code> register. The following table shows the different flags in the <code>RFLAGS</code> register:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Bit(s)</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12-13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
<th style="text-align:center">16</th>
<th style="text-align:center">17</th>
<th style="text-align:center">18</th>
<th style="text-align:center">19</th>
<th style="text-align:center">20</th>
<th style="text-align:center">21</th>
<th style="text-align:center">22-63</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>Label</strong> (<code>1</code>/<code>0</code>)</td>
<td style="text-align:center"><code>CF</code> (<code>CY</code>/<code>NC</code>)</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>PF</code> (<code>PE</code>/<code>PO</code>)</td>
<td style="text-align:center"><code>0</code></td>
<td style="text-align:center"><code>AF</code> (<code>AC</code>/<code>NA</code>)</td>
<td style="text-align:center"><code>0</code></td>
<td style="text-align:center"><code>ZF</code> (<code>ZR</code>/<code>NZ</code>)</td>
<td style="text-align:center"><code>SF</code> (<code>NC</code>/<code>PL</code>)</td>
<td style="text-align:center"><code>TF</code></td>
<td style="text-align:center"><code>IF</code> (<code>EL</code>/<code>DI</code>)</td>
<td style="text-align:center"><code>DF</code> (<code>DN</code>/<code>UP</code>)</td>
<td style="text-align:center"><code>OF</code> (<code>OV</code>/<code>NV</code>)</td>
<td style="text-align:center"><code>IOPL</code></td>
<td style="text-align:center"><code>NT</code></td>
<td style="text-align:center"><code>0</code></td>
<td style="text-align:center"><code>RF</code></td>
<td style="text-align:center"><code>VM</code></td>
<td style="text-align:center"><code>AC</code></td>
<td style="text-align:center"><code>VIF</code></td>
<td style="text-align:center"><code>VIP</code></td>
<td style="text-align:center"><code>ID</code></td>
<td style="text-align:center"><code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><strong>Description</strong></td>
<td style="text-align:center">Carry Flag</td>
<td style="text-align:center"><em>Reserved</em></td>
<td style="text-align:center">Parity Flag</td>
<td style="text-align:center"><em>Reserved</em></td>
<td style="text-align:center">Auxiliary Carry Flag</td>
<td style="text-align:center"><em>Reserved</em></td>
<td style="text-align:center">Zero Flag</td>
<td style="text-align:center">Sign Flag</td>
<td style="text-align:center">Trap Flag</td>
<td style="text-align:center">Interrupt Flag</td>
<td style="text-align:center">Direction Flag</td>
<td style="text-align:center">Overflow Flag</td>
<td style="text-align:center">I/O Privilege Level</td>
<td style="text-align:center">Nested Task</td>
<td style="text-align:center"><em>Reserved</em></td>
<td style="text-align:center">Resume Flag</td>
<td style="text-align:center">Virtual-x86 Mode</td>
<td style="text-align:center">Alignment Check / Access Control</td>
<td style="text-align:center">Virtual Interrupt Flag</td>
<td style="text-align:center">Virtual Interrupt Pending</td>
<td style="text-align:center">Identification Flag</td>
<td style="text-align:center"><em>Reserved</em></td>
</tr>
</tbody>
</table>
<p>Just like other registers, the 64-bit <code>RFLAGS</code> register has a 32-bit sub-register called <code>EFLAGS</code>, and a 16-bit sub-register called <code>FLAGS</code>, which holds the most significant flags we may encounter.\
The flags we would mostly be interested in are:</p>
<ul>
<li>The Carry Flag <code>CF</code>: Indicates whether we have a float.</li>
<li>The Parity Flag <code>PF</code>: Indicates whether a number is odd or even.</li>
<li>The Zero Flag <code>ZF</code>: Indicates whether a number is zero.</li>
<li>The Sign Flag <code>SF</code>: Indicates whether a register is negative.</li>
</ul>
<p>All of the above flags are among the first few bits in the <code>FLAGS</code> sub-register. We will only be using the <code>jnz</code> instruction for our module project, which is applied whenever the <code>ZF</code> flag is equal to <code>0</code> (i.e., Not Zero <code>NZ</code>). So, let&#39;s see how to do so.</p>
<hr>
<h3 id="jnz-loopfib">JNZ loopFib</h3>
<p>The <code>loop loopFib</code> instruction we used in the last section is, in fact, a combination of two instructions: <code>dec rcx</code> and <code>jnz loopFib</code>, but since looping is a very common function, the <code>loop</code> instruction was created to reduce code size and be more efficient, instead of using both every time. However, the conditional jump instructions are much more versatile than <code>loop</code>, since they allow us to jump anywhere in the program on any condition we require.</p>
<p>Though it is more efficient to use <code>loop</code>, to demonstrate the use of <code>jnz</code>, let&#39;s go back to our code and try to use the <code>jnz</code> instruction instead of <code>loop</code>:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rcx</span>, <span class="hljs-number">10</span>
<span class="hljs-symbol">loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">dec</span> <span class="hljs-built_in">rcx</span>            <span class="hljs-comment">; decrement rcx counter</span>
    <span class="hljs-keyword">jnz</span> loopFib        <span class="hljs-comment">; jump to loopFib until rcx is 0</span>
</code></pre>
<p>We see that we replaced <code>loop loopFib</code> with <code>dec rcx</code> and <code>jnz loopFib</code>, so that every time the loop reaches its end, the rcx counter would decrement by 1, and the program would jump back to <code>loopFib</code> if <code>ZF</code> is not set. Once <code>rcx</code> reaches <code>0</code>, the Zero Flag <code>ZF</code> would be turned on to <code>1</code>, and so <code>jnz</code> would no longer jump (since it&#39;s <code>NZ</code>), and we would exit the loop. Let&#39;s assemble our code, and run it with <code>gdb</code>, to see this in effect:</p>
<p>&#x20; gdb</p>
<pre><code><span class="hljs-symbol">$</span> ./assembler.sh fib.s -g
gef➤  b loopFib
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x40100e</span>
gef➤  r
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x1               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0xa               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$eflags</span>: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span>
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x1               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x1               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x9               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$eflags</span>: [zero carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span>
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x1               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x2               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x8               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$eflags</span>: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span>
</code></pre><p>We can see that we are still correctly calculating the Fibonacci Sequence. At each iteration of the loop, we are decreasing <code>rcx</code>, and the <code>zero</code> flag is off, while the <code>parity</code> flag is on when <code>rcx</code> is an odd number. The RFLAGS values at this point are set after the <code>dec rcx</code> instruction, as this is the last arithmetic instruction before we break. So, the flag states are for <code>rcx</code>.</p>
<p>Note: <code>GEF</code> shows us the state of the flags in the <code>RFLAGS</code> register. The flags written in bold UPPERCASE letters are on.</p>
<p>Let&#39;s <code>c</code>ontinue out of the loop, to see the state of the registers and RFLAGS after <code>rcx</code> reaches <code>0</code>:</p>
<p>&#x20; gdb</p>
<pre><code>gef➤  
Continuing.
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x37              </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x59              </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$eflags</span>: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]</span>
</code></pre><p>We see that once <code>rcx</code> reaches <code>0</code>, the <code>zero</code> flag is set to on <code>1</code>, and <code>jnz</code> no longer jumps back to <code>loopFib</code>, so the program stops executing.</p>
<hr>
<h3 id="cmp">CMP</h3>
<p>There are other cases where we may want to use a conditional jump instruction within our module project. For example, we may want to stop the program execution when the Fibonacci number is more than <code>10</code>. We can do so by using the <code>js loopFib</code> instruction, which would jump back to <code>loopFib</code> as long as the last arithmetic instruction resulted in a negative number.</p>
<p>In this case, we will not use the <code>jnz</code> instruction or the <code>rcx</code> register but will use <code>js</code> instead directly after calculating the current Fibonacci number. But how would we test if the current Fibonacci number (i.e., <code>rbx</code>) is less than <code>10</code>? This is where we come to the Compare instruction <code>cmp</code>.</p>
<p>The Compare instruction <code>cmp</code> simply compares the two operands, by subtracting the second operand from first operand (i.e. <code>D</code><sub><code>1</code></sub> - <code>S</code><sub><code>2</code></sub>), and then sets the necessary flags in the <code>RFLAGS</code> register. For example, if we use <code>cmp rbx, 10</code>, then the compare instruction would do &#39;<code>rbx - 10</code>&#39;, and set the flags based on the result.</p>
<table>
<thead>
<tr>
<th><strong>Instruction</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmp</code></td>
<td>Sets <code>RFLAGS</code> by subtracting second operand from first operand (i.e. first - second)</td>
<td><code>cmp rax, rbx</code> -&gt; <code>rax - rbx</code></td>
</tr>
</tbody>
</table>
<p>So, after the first Fibonacci number is calculated, it will do &#39;<code>1 - 10</code>&#39;, and the result would be <code>-9</code>, so it will jump since it&#39;s a negative number <code>&lt;0</code>. Once we reach the first Fibonacci number greater than <code>10</code>, which is <code>13</code> or <code>0xd</code>, it will do &#39;<code>13 - 10</code>&#39;, and the result would be &#39;<code>3</code>&#39;, at which case <code>js</code> would no longer jump, as the result is a positive number <code>&gt;=0</code>.</p>
<p>We could use <code>sub</code> instructions to perform the same subtraction and set the flags if we wanted. However, this would not be efficient, as we will be changing the value of one of the registers, while the <code>cmp</code> only compares and does not store the result anywhere. <code>The main advantage of &#39;cmp&#39; is that it does not affect the operands.</code></p>
<p>Note: In a <code>cmp</code> instruction, the first operand (i.e. the Destination) must be a register, while the other can be a register, a variable, or an immediate value.</p>
<p>So, let&#39;s change our code to use <code>cmp</code> and <code>js</code>, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
<span class="hljs-symbol">loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">10</span>        <span class="hljs-comment">; do rbx - 10</span>
    <span class="hljs-keyword">js</span> loopFib        <span class="hljs-comment">; jump if result is &lt;0</span>
</code></pre>
<p>Note that we removed the <code>mov rcx, 10</code> instruction since we are no longer looping with <code>rcx</code>. We could have used it in <code>cmp</code> instead of <code>10</code>, but by directly using <code>10</code> we use one less instruction, making our code shorter and more efficient.</p>
<p>Now, let&#39;s assemble our code, and run it with <code>gdb</code>, to see how this works. We will break at <code>loopFib</code>, and then step with <code>si</code> until we reach the <code>js loopFib</code> instruction:</p>
<p>&#x20; gdb</p>
<pre><code>$ ./assembler.sh fib.s -g
gef➤  b loopFib
Breakpoint <span class="hljs-number">1</span> <span class="hljs-meta">at</span> <span class="hljs-number">0x401009</span>
gef➤  r
───────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x1</span>               
$<span class="hljs-built_in">rbx</span>   : <span class="hljs-number">0x1</span>               
$eflags: [<span class="hljs-meta">zero</span> CARRY parity ADJUST SIGN trap INTERRUPT direction overflow resume virtualx86 identification]
─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0x401009</span> &lt;loopFib+<span class="hljs-number">0</span>&gt;      <span class="hljs-keyword">add</span>    <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x40100c</span> &lt;loopFib+<span class="hljs-number">3</span>&gt;      <span class="hljs-keyword">xchg</span>   <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rax</span>
     <span class="hljs-number">0x40100e</span> &lt;loopFib+<span class="hljs-number">5</span>&gt;      <span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">rbx</span>, <span class="hljs-number">0xa</span>
 →   <span class="hljs-number">0x401012</span> &lt;loopFib+<span class="hljs-number">9</span>&gt;      <span class="hljs-keyword">js</span>     <span class="hljs-number">0x401009</span> &lt;loopFib&gt;    TAKEN [Reason: S]
</code></pre><p>We see that in the first iteration of <code>loopFib</code>, once we reach <code>js loopFib</code>, the <code>SIGN</code> flag is set to on <code>1</code> as expected, since the result of <code>1 - 10</code> is a negative number. We also notice <code>GEF</code> telling us <code>TAKEN [Reason: S]</code>, which conveniently tells us that this conditional jump will be taken and gives the reason as <code>S</code>, meaning that the <code>SIGN</code> flag is set.</p>
<p>Now, let&#39;s <code>c</code>ontinue until <code>rbx</code> is greater than <code>10</code>, at which point <code>js</code> should no longer jump. Instead of manually pressing <code>c</code> several times, let&#39;s take this opportunity to learn how to set conditional breakpoints in <code>gdb</code>.</p>
<p>Let&#39;s first delete the current breakpoint with <code>del 1</code>, and then set our conditional breakpoint. The syntax is very similar to setting regular breakpoints <code>b loopFib</code>, but we add an <code>if</code> condition after it, such as &#39;<code>b loopFib if $rbx &gt; 10</code>&#39;. Also, instead of breaking at <code>loopFib</code> and then using <code>si</code> to reach <code>js</code>, let&#39;s directly break at <code>js</code> with <code>*</code> to refer to its location &#39;<code>b *loopFib+9 if $rbx &gt; 10</code>&#39; or &#39;<code>b *0x401012 if $rbx &gt; 10</code>&#39;.\
Remember: we can find an instruction&#39;s location with <code>disas loopFib</code>.</p>
<p>We see the following:</p>
<p>&#x20;&#x20;</p>
<pre><code>gef➤  del <span class="hljs-number">1</span>
gef➤  disas loopFib
Dump of assembler code for function loopFib:
..SNIP...
<span class="hljs-number">0x0000000000401012</span> &lt;+<span class="hljs-number">9</span>&gt;:    <span class="hljs-keyword">js</span>     <span class="hljs-number">0x401009</span>  
gef➤  b *loopFib+<span class="hljs-number">9</span> if $<span class="hljs-built_in">rbx</span> &gt; <span class="hljs-number">10</span>
Breakpoint <span class="hljs-number">2</span> <span class="hljs-meta">at</span> <span class="hljs-number">0x401012</span>
gef➤  c
───────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x8</span>               
$<span class="hljs-built_in">rbx</span>   : <span class="hljs-number">0xd</span>               
$eflags: [<span class="hljs-meta">zero</span> carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]
─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0x401009</span> &lt;loopFib+<span class="hljs-number">0</span>&gt;      <span class="hljs-keyword">add</span>    <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x40100c</span> &lt;loopFib+<span class="hljs-number">3</span>&gt;      <span class="hljs-keyword">xchg</span>   <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rax</span>
     <span class="hljs-number">0x40100e</span> &lt;loopFib+<span class="hljs-number">5</span>&gt;      <span class="hljs-keyword">cmp</span>    <span class="hljs-built_in">rbx</span>, <span class="hljs-number">0xa</span>
 →   <span class="hljs-number">0x401012</span> &lt;loopFib+<span class="hljs-number">9</span>&gt;      <span class="hljs-keyword">js</span>     <span class="hljs-number">0x401009</span> &lt;loopFib&gt;    <span class="hljs-keyword">NOT</span> taken [Reason: !(S)]
</code></pre><p>We see now that the last arithmetic instruction &#39;<code>13 - 10</code>&#39; resulted in a positive number, the <code>sign</code> flag is no longer set, so <code>GEF</code> tells us that this jump is <code>NOT TAKEN</code>, with the reason <code>!(S)</code>, meaning that the <code>sign</code> flag is not set.</p>
<p>As we can see, using conditional branching is very powerful and enables us to perform more advanced instructions based on a condition we specify. We can use the <code>cmp</code> instruction to test various conditions. For example, we can use <code>jl</code> instead of <code>jns</code>, which would jump as long as the Destination is Less than the Source. So, with <code>cmp rbx, 10</code>, <code>rbx</code> will start less than <code>10</code>, and once <code>rbx</code> gets greater than <code>10</code>, then <code>rbx</code> (i.e., the Destination) would be greater than <code>10</code>, at which point <code>jl</code> will not jump.</p>
<p>Note: We may see instructions using JMP Equal <code>je</code>, or JMP Not Equal <code>jne</code>. This is just an alias of <code>jz</code> and <code>jnz</code>, since if both operands are equal, the outcome of <code>cmp rax, rax</code> would be <code>0</code> in all cases, which sets the Zero Flag. The same applies to <code>jge</code> and <code>jnl</code>, since <code>&gt;=</code> is the same as <code>!</code>, and applies to other similar conditions as well.</p>
<p>Now that we have covered all basic Control Instructions, which way do you think is more efficient?</p>
<ol>
<li>Using <code>mov rcx, 10</code> and <code>loop loopFib</code> =&gt; loop 10 times</li>
<li>Using <code>mov rcx, 10</code> and <code>dec rcx</code> and <code>jnz loopFib</code> =&gt; jump 10 times</li>
<li>Using <code>cmp rbx, 10</code> and <code>js loopFib</code> =&gt; jump while rbx &lt;10</li>
</ol>
<p>Modify your code to use the method you think is the best.</p>
<hr>
<hr>
<p>We have so far learned two types of Control Instructions: <code>Loops</code> and <code>Branching</code>. Before we discuss <code>Functions</code>, we need to understand how to use the memory <code>Stack</code>. In the <code>Computer Architecture</code> section, we discussed how the RAM is segmented into four different segments, and each application is allocated its Virtual Memory and its segments. We have also discussed the <code>text</code> segment where the application&#39;s assembly instructions are loaded into for the CPU to access and the <code>data</code> segment that holds the application&#39;s variables. So, now let&#39;s start discussing the <code>Stack</code>.</p>
<hr>
<h3 id="usage-with-functions-syscalls">Usage With Functions/Syscalls</h3>
<p>We will primarily be pushing data from registers into the stack before we call a <code>function</code> or call a <code>syscall</code>, and then restore them after the function and the syscall. This is because <code>functions</code> and <code>syscalls</code> usually use the registers for their processing, and so if the values stored in the registers will get changed after a function call or a syscall, we will lose them.</p>
<p>For example, if we wanted to call a syscall to print <code>Hello World</code> to the screen and retain the current value stored in <code>rax</code>, we would <code>push rax</code> into the stack. Then we can execute the syscall and afterward <code>pop</code> the value back to <code>rax</code>. So, this way, we would be able to both execute the syscall and retain the value of <code>rax</code>.</p>
<hr>
<h3 id="push-pop">PUSH/POP</h3>
<p>Our code currently looks like the following:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
<span class="hljs-symbol">loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">10</span>        <span class="hljs-comment">; do rbx - 10</span>
    <span class="hljs-keyword">js</span> loopFib        <span class="hljs-comment">; jump if result is &lt;0</span>
</code></pre>
<p>Let&#39;s assume that we want to call a <code>function</code> or a <code>syscall</code> before entering the loop. To preserve our registers, we will need to <code>push</code> to the stack all of the registers we are using and then pop them back after the <code>syscall</code>.</p>
<p>To <code>push</code> value into the stack, we can use its name as the operand, as in <code>push rax</code>, and the value will be <code>copied</code> to the top of the stack. When we want to retrieve that value, we first need to be sure that it is on the top of the stack, and then we can specify the storage location as the operand, as in <code>pop rax</code>, after which the value will be <code>moved</code> to <code>rax</code>, and will be <code>removed</code> from the top of the stack. The value below it will now be on top of the stack (as shown in the excise above).</p>
<p>Since the stack has a LIFO design, when we restore our registers, we have to do them in reverse order. For example, if we push rax and then push rbx, when we restore, we have to pop rbx and then pop rax.</p>
<p>So, to save our registers before entering the loop, let&#39;s push them to the stack. Luckily, we are only using <code>rax</code> and <code>rbx</code>, and so we will only need to <code>push</code> these two registers to the stack and then <code>pop</code> them after the syscall, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rax</span>        <span class="hljs-comment">; push registers to stack</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-comment">; call function</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; restore registers from stack</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rax</span>
...SNIP...
</code></pre>
<p>Note how restoring the registers with <code>pop</code> was in reverse order.</p>
<p>Now, let&#39;s assemble our code and test it with <code>gdb</code>:</p>
<p>&#x20; gdb</p>
<pre><code>$ ./assembler.sh fib.s -g
gef➤  b _start
gef➤  r
...SNIP...
gef➤  <span class="hljs-built_in">si</span>
gef➤  <span class="hljs-built_in">si</span>
gef➤  <span class="hljs-built_in">si</span>
───────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rbx</span>   : <span class="hljs-number">0x1</span>               
───────────────────────────────────────────────────────────────────────────────────────── stack ────
<span class="hljs-number">0x00007fffffffe410</span>│+<span class="hljs-number">0x0000</span>: <span class="hljs-number">0x0000000000000001</span>     ← $<span class="hljs-built_in">rsp</span>
<span class="hljs-number">0x00007fffffffe418</span>│+<span class="hljs-number">0x0008</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe420</span>│+<span class="hljs-number">0x0010</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe428</span>│+<span class="hljs-number">0x0018</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe430</span>│+<span class="hljs-number">0x0020</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe438</span>│+<span class="hljs-number">0x0028</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe440</span>│+<span class="hljs-number">0x0030</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe448</span>│+<span class="hljs-number">0x0038</span>: <span class="hljs-number">0x0000000000000000</span>
─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
 →   <span class="hljs-number">0x40100e</span> &lt;_start+<span class="hljs-number">9</span>&gt;      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rax</span>
     <span class="hljs-number">0x40100f</span> &lt;_start+<span class="hljs-number">10</span>&gt;      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x401010</span> &lt;_start+<span class="hljs-number">11</span>&gt;      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x401011</span> &lt;_start+<span class="hljs-number">12</span>&gt;      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rax</span>
────────────────────────────────────────────────────────────────────────────────────────────────────
</code></pre><p>We see that before we execute <code>push rax</code>, we have <code>rax = 0x0</code> and <code>rbx = 0x1</code>. Now let&#39;s <code>push</code> both <code>rax</code> and <code>rbx</code>, and see how the stack and the registers change:</p>
<p>&#x20; gdb</p>
<pre><code>───────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rbx</span>   : <span class="hljs-number">0x1</span>               
───────────────────────────────────────────────────────────────────────────────────────── stack ────
<span class="hljs-number">0x00007fffffffe408</span>│+<span class="hljs-number">0x0000</span>: <span class="hljs-number">0x0000000000000000</span>     ← $<span class="hljs-built_in">rsp</span>
<span class="hljs-number">0x00007fffffffe410</span>│+<span class="hljs-number">0x0008</span>: <span class="hljs-number">0x0000000000000001</span>
<span class="hljs-number">0x00007fffffffe418</span>│+<span class="hljs-number">0x0010</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe420</span>│+<span class="hljs-number">0x0018</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe428</span>│+<span class="hljs-number">0x0020</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe430</span>│+<span class="hljs-number">0x0028</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe438</span>│+<span class="hljs-number">0x0030</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe440</span>│+<span class="hljs-number">0x0038</span>: <span class="hljs-number">0x0000000000000000</span>
─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0x40100e</span> &lt;loopFib+<span class="hljs-number">9</span>&gt;      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rax</span>
 →   <span class="hljs-number">0x40100f</span> &lt;_start+<span class="hljs-number">10</span>&gt;      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x401010</span> &lt;_start+<span class="hljs-number">11</span>&gt;      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x401011</span> &lt;_start+<span class="hljs-number">12</span>&gt;      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rax</span>
────────────────────────────────────────────────────────────────────────────────────────────────────
...SNIP...
───────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rbx</span>   : <span class="hljs-number">0x1</span>               
───────────────────────────────────────────────────────────────────────────────────────── stack ────
<span class="hljs-number">0x00007fffffffe400</span>│+<span class="hljs-number">0x0000</span>: <span class="hljs-number">0x0000000000000001</span>     ← $<span class="hljs-built_in">rsp</span>
<span class="hljs-number">0x00007fffffffe408</span>│+<span class="hljs-number">0x0008</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe410</span>│+<span class="hljs-number">0x0010</span>: <span class="hljs-number">0x0000000000000001</span>
<span class="hljs-number">0x00007fffffffe418</span>│+<span class="hljs-number">0x0018</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe420</span>│+<span class="hljs-number">0x0020</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe428</span>│+<span class="hljs-number">0x0028</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe430</span>│+<span class="hljs-number">0x0030</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe438</span>│+<span class="hljs-number">0x0038</span>: <span class="hljs-number">0x0000000000000000</span>
─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0x40100e</span> &lt;_start+<span class="hljs-number">9</span>&gt;      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rax</span>
     <span class="hljs-number">0x40100f</span> &lt;_start+<span class="hljs-number">10</span>&gt;      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbx</span>
 →   <span class="hljs-number">0x401010</span> &lt;_start+<span class="hljs-number">11</span>&gt;      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x401011</span> &lt;_start+<span class="hljs-number">12</span>&gt;      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rax</span>
────────────────────────────────────────────────────────────────────────────────────────────────────
</code></pre><p>We see that after we <code>push</code>ed both <code>rax</code> and <code>rbx</code>, we have the following values on the top of our stack:</p>
<p>&#x20; Using the Stack</p>
<pre><code class="lang-shell-session"><span class="hljs-number">0x00007fffffffe408</span>│+<span class="hljs-number">0x0000</span>: <span class="hljs-number">0x0000000000000001</span>     ← $<span class="hljs-built_in">rsp</span>
<span class="hljs-number">0x00007fffffffe410</span>│+<span class="hljs-number">0x0008</span>: <span class="hljs-number">0x0000000000000000</span>
</code></pre>
<p>We see that at the top of the stack, we have the last value we pushed, which is <code>rbx = 0x1</code>, and just below it, we have the value we pushed before it <code>rax = 0x0</code>. This is as we expected and similar to the stack exercise above. We also notice that after we pushed our values, they remained in the registers, <code>meaning a push is, in fact, a copy to stack</code>.</p>
<p>Now let&#39;s assume that we finished executing a <code>print</code> function, and want to retrieve our values back, so we continue with the <code>pop</code> instructions:</p>
<p>&#x20; gdb</p>
<pre><code>───────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rbx</span>   : <span class="hljs-number">0x1</span>               
───────────────────────────────────────────────────────────────────────────────────────── stack ────
<span class="hljs-number">0x00007fffffffe408</span>│+<span class="hljs-number">0x0000</span>: <span class="hljs-number">0x0000000000000000</span>     ← $<span class="hljs-built_in">rsp</span>
<span class="hljs-number">0x00007fffffffe410</span>│+<span class="hljs-number">0x0008</span>: <span class="hljs-number">0x0000000000000001</span>
<span class="hljs-number">0x00007fffffffe418</span>│+<span class="hljs-number">0x0010</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe420</span>│+<span class="hljs-number">0x0018</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe428</span>│+<span class="hljs-number">0x0020</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe430</span>│+<span class="hljs-number">0x0028</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe438</span>│+<span class="hljs-number">0x0030</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe440</span>│+<span class="hljs-number">0x0038</span>: <span class="hljs-number">0x0000000000000000</span>
─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0x40100e</span> &lt;_start+<span class="hljs-number">9</span>&gt;      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rax</span>
     <span class="hljs-number">0x40100f</span> &lt;_start+<span class="hljs-number">10</span>&gt;      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x401010</span> &lt;_start+<span class="hljs-number">11</span>&gt;      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rbx</span>
 →   <span class="hljs-number">0x401011</span> &lt;_start+<span class="hljs-number">12</span>&gt;      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rax</span>
────────────────────────────────────────────────────────────────────────────────────────────────────
...SNIP...
───────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rbx</span>   : <span class="hljs-number">0x1</span>               
───────────────────────────────────────────────────────────────────────────────────────── stack ────
<span class="hljs-number">0x00007fffffffe410</span>│+<span class="hljs-number">0x0000</span>: <span class="hljs-number">0x0000000000000001</span>     ← $<span class="hljs-built_in">rsp</span>
<span class="hljs-number">0x00007fffffffe418</span>│+<span class="hljs-number">0x0008</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe420</span>│+<span class="hljs-number">0x0010</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe428</span>│+<span class="hljs-number">0x0018</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe430</span>│+<span class="hljs-number">0x0020</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe438</span>│+<span class="hljs-number">0x0028</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe440</span>│+<span class="hljs-number">0x0030</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe448</span>│+<span class="hljs-number">0x0038</span>: <span class="hljs-number">0x0000000000000000</span>
─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0x40100f</span> &lt;_start+<span class="hljs-number">9</span>&gt;      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rax</span>
     <span class="hljs-number">0x40100f</span> &lt;_start+<span class="hljs-number">10</span>&gt;      <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x401010</span> &lt;_start+<span class="hljs-number">11</span>&gt;      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x401011</span> &lt;_start+<span class="hljs-number">12</span>&gt;      <span class="hljs-keyword">pop</span>    <span class="hljs-built_in">rax</span>
 →   <span class="hljs-number">0x401011</span> &lt;loopFib+<span class="hljs-number">0</span>&gt;      <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>
────────────────────────────────────────────────────────────────────────────────────────────────────
</code></pre><p>We see that after <code>pop</code>ing two values from the top of the stack, they were removed from the stack, and the stack now looks exactly as when we first started. Both values were placed back in <code>rbx</code> and <code>rax</code>. We may not have seen any difference since they were not changed in the registers in this case.</p>
<p>Using the stack is very simple. The only thing we should keep in mind is the order we push our registers and the state of the stack to safely restore our data and not restore a different value by <code>pop</code> when a different value is at the top of the stack.</p>
<p>We can remove the <code>push</code> and <code>pop</code> instructions from our code for now, and we will use them when we get into function calls. With that, we should be ready to use <code>syscall</code> and <code>function</code> calls. Let us discuss <code>syscalls</code> next.</p>
<hr>
<h2 id="syscalls">Syscalls</h2>
<hr>
<p>Even though we are talking directly to the CPU through machine instructions in Assembly, we do not have to invoke every type of command using basic machine instructions only. Programs regularly use many kinds of operations. The Operating System can help us through syscalls to not have to execute these operations every time manually.</p>
<p>For example, suppose we need to write something on the screen, without syscalls. In that case, we will need to talk to the Video Memory and Video I/O, resolve any encoding required, send our input to be printed, and wait for the confirmation that it has been printed. As expected, if we had to do all of this to print a single character, it would make assembly codes much longer.</p>
<hr>
<h3 id="linux-syscall">Linux Syscall</h3>
<p>A <code>syscall</code> is like a globally available function written in <code>C</code>, provided by the Operating System Kernel. A syscall takes the required arguments in the registers and executes the function with the provided arguments. For example, if we wanted to write something to the screen, we can use the <code>write</code> syscall, provide the string to be printed and other required arguments, and then call the syscall to issue the print.</p>
<p>There are many available syscalls provided by the Linux Kernel, and we can find a list of them and the <code>syscall number</code> of each one by reading the <code>unistd_64.h</code> system file:</p>
<p>&#x20; Syscalls</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ cat <span class="hljs-meta-keyword">/usr/</span>include/x86_64-linux-gnu<span class="hljs-meta-keyword">/asm/</span>unistd_64.h
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_read 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_write 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_open 2</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_close 3</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_stat 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_fstat 5</span>
</code></pre>
<p>The above file sets the syscall number for each syscall to refer to that syscall using this number.</p>
<p>Note: With <code>32-bit</code> x86 processors, the syscall numbers are in the <code>unistd_32.h</code> file.</p>
<p>Let&#39;s practice using syscalls with the <code>write</code> syscall that prints to the screen. We will not be printing the Fibonacci numbers just yet, but will instead start by printing an intro message, <code>Fibonacci Sequence</code>, at the beginning of our program.</p>
<hr>
<h3 id="syscall-function-arguments">Syscall Function Arguments</h3>
<p>To use the <code>write</code> syscall, we must first know what arguments it accepts. To find the arguments accepted by a syscall, we can use the <code>man -s 2</code> command with the syscall name from the above list:</p>
<p>&#x20; Syscalls</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ man -s <span class="hljs-number">2</span> write
...SNIP...
       <span class="hljs-keyword">ssize_t</span> write(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count);
</code></pre>
<p>As we can see from the above output, the <code>write</code> function has the following syntax:</p>
<p>Code: c</p>
<pre><code class="lang-c"><span class="hljs-keyword">ssize_t</span> write(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> count);
</code></pre>
<p>We see that the syscall function expects <code>3</code> arguments:</p>
<ol>
<li>File Descriptor <code>fd</code> to be printed to (<em>usually <code>1</code> for <code>stdout</code></em>)</li>
<li>The address pointer to the string to be printed</li>
<li>The length we want to print</li>
</ol>
<p>Once we provide these arguments, we can use the syscall instruction to execute the function and print to screen. In addition to these manual methods of locating syscalls and function arguments, there are online resources we can use to quickly look for syscalls, their numbers, and the arguments they expect, like <a href="https://filippo.io/linux-syscall-table/">this table</a>. Furthermore, we can always refer to the <code>Linux</code> source code on <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl">Github</a>.</p>
<p>Tip: The <code>-s 2</code> flag specifies <code>syscall</code> man pages. We can check <code>man man</code> to see various sections for each man page.</p>
<hr>
<h3 id="syscall-calling-convention">Syscall Calling Convention</h3>
<p>Now that we understand how to locate various syscall and their arguments let&#39;s start learning how to call them. To call a syscall, we have to:</p>
<ol>
<li>Save registers to stack</li>
<li>Set its syscall number in <code>rax</code></li>
<li>Set its arguments in the registers</li>
<li>Use the syscall assembly instruction to call it</li>
</ol>
<p><code>We usually should save any registers we use to the stack before any function call or syscall.</code> However, as we are running this syscall at the beginning of our program before using any registers, we don&#39;t have any values in the registers, so we should not worry about saving them.\
We will discuss saving registers to the stack when we get to <code>Function Calls</code>.</p>
<p><strong>Syscall Number</strong></p>
<p>Let&#39;s start by moving the syscall number to the <code>rax</code> register. As we saw earlier, the <code>write</code> syscall has a number <code>1</code>, so we can start with the following command:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>
</code></pre>
<p>Now, if we reach the syscall instruction, the Kernel would know which syscall we are calling.</p>
<p><strong>Syscall Arguments</strong></p>
<p>Next, we should put each of the function&#39;s arguments in its corresponding register. The <code>x86_64</code> architecture&#39;s calling convention specifies in which register each argument should be placed (e.g., first arg should be in <code>rdi</code>). All functions and syscalls should follow this standard and take their arguments from the corresponding registers. We have discussed the following table in the <code>Registers</code> section:</p>
<table>
<thead>
<tr>
<th>Description</th>
<th>64-bit Register</th>
<th>8-bit Register</th>
</tr>
</thead>
<tbody>
<tr>
<td>Syscall Number/Return value</td>
<td><code>rax</code></td>
<td><code>al</code></td>
</tr>
<tr>
<td>Callee Saved</td>
<td><code>rbx</code></td>
<td><code>bl</code></td>
</tr>
<tr>
<td>1st arg</td>
<td><code>rdi</code></td>
<td><code>dil</code></td>
</tr>
<tr>
<td>2nd arg</td>
<td><code>rsi</code></td>
<td><code>sil</code></td>
</tr>
<tr>
<td>3rd arg</td>
<td><code>rdx</code></td>
<td><code>dl</code></td>
</tr>
<tr>
<td>4th arg</td>
<td><code>rcx</code></td>
<td><code>cl</code></td>
</tr>
<tr>
<td>5th arg</td>
<td><code>r8</code></td>
<td><code>r8b</code></td>
</tr>
<tr>
<td>6th arg</td>
<td><code>r9</code></td>
<td><code>r9b</code></td>
</tr>
</tbody>
</table>
<p>As we can see, we have a register for each of the first <code>6</code> arguments. Any additional arguments can be stored in the stack (though not many syscalls use more than <code>6</code> arguments.).</p>
<p>Note: <code>rax</code> is also used for storing the <code>return value</code> of a syscall or a function. So, if we were expecting to get a value back from a syscall/function, it will be in <code>rax</code>.</p>
<p>With that, we should know our arguments and in which register we should store them. Going back to the <code>write</code> syscall function, we should pass: <code>fd</code>, <code>pointer</code>, and <code>length</code>. We can do so as follows:</p>
<ol>
<li><code>rdi</code> -&gt; <code>1</code> (for stdout)</li>
<li><code>rsi</code> -&gt; <code>&#39;Fibonacci Sequence:\n&#39;</code> (pointer to our string)</li>
<li><code>rdx</code> -&gt; <code>20</code> (length of our string)</li>
</ol>
<p>We can use <code>mov rcx, &#39;string&#39;</code>. However, we can only store up to 16 characters in a register (i.e., 64 bits), so our intro string would not fit. Instead, let&#39;s create a variable with our string (as we learned in the <code>Assembly File Structure</code> section), similarly to what we did with the <code>Hello World</code> program:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">global  _start

<span class="hljs-selector-tag">section</span> <span class="hljs-selector-class">.data</span>
    message db <span class="hljs-string">"Fibonacci Sequence:"</span>, <span class="hljs-number">0</span>x0a
</code></pre>
<p>Note how we added <code>0x0a</code> after our string, to add a new line character.</p>
<p>The <code>message</code> label is a pointer to where our string will be stored in the memory. So, we can use it as our second argument. So, our final syscall code should be as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; rax: syscall number 1</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>      <span class="hljs-comment">; rdi: fd 1 for stdout</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>,message <span class="hljs-comment">; rsi: pointer to message</span>
<span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">20</span>      <span class="hljs-comment">; rdx: print length of 20 bytes</span>
</code></pre>
<p>Tip: If we ever needed to create a pointer to a value stored in a register, we can simply push it to the stack, and then use the <code>rsp</code> pointer to point to it.</p>
<p>We may also use a dynamically calculated <code>length</code> variable by using <code>equ</code>, similarly to what we did with the <code>Hello World</code> program.</p>
<hr>
<h3 id="calling-syscall">Calling Syscall</h3>
<p>Now that we have our syscall number and arguments in place, the only thing left is to do the syscall instruction. So, let&#39;s add a syscall instruction and add the instructions to the beginning of our <code>fib.s</code> code, which should look as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Fibonacci Sequence:"</span>, <span class="hljs-number">0x0a</span>

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; rax: syscall number 1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>      <span class="hljs-comment">; rdi: fd 1 for stdout</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>,message <span class="hljs-comment">; rsi: pointer to message</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">20</span>      <span class="hljs-comment">; rdx: print length of 20 bytes</span>
    <span class="hljs-keyword">syscall</span>         <span class="hljs-comment">; call write syscall to the intro message</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
<span class="hljs-symbol">loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">10</span>        <span class="hljs-comment">; do rbx - 10</span>
    <span class="hljs-keyword">js</span> loopFib        <span class="hljs-comment">; jump if result is &lt;0</span>
</code></pre>
<p>Let&#39;s now assemble our code and run it, and see if our intro message gets printed:</p>
<p>&#x20; Syscalls</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ./assembler<span class="hljs-selector-class">.sh</span> fib<span class="hljs-selector-class">.s</span>

Fibonacci Sequence:
[<span class="hljs-number">1</span>]    <span class="hljs-number">107348</span> segmentation fault  ./fib
</code></pre>
<p>We see that indeed our string is printed to the screen. Let&#39;s run it through <code>gdb</code>, and break at the syscall to see how all arguments are setup before we call syscall, as follows:</p>
<p>&#x20; gdb</p>
<pre><code><span class="hljs-symbol">$</span> gdb -q ./fib
gef➤  disas _start
Dump of assembler code <span class="hljs-keyword">for</span> function _start:
..SNIP...
<span class="hljs-number">0x0000000000401011</span> &lt;+<span class="hljs-number">17</span>&gt;:    syscall 
gef➤  b *_start+<span class="hljs-number">17</span>
Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x401011</span>
gef➤  r
───────────────────────────────────────────────────────────────────────────────────── registers ────
<span class="hljs-meta"><span class="hljs-meta-keyword">$rax</span>   : 0x1               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbx</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rcx</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rdx</span>   : 0x14              </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rsp</span>   : 0x00007fffffffe410  →  0x0000000000000001</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rbp</span>   : 0x0               </span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rsi</span>   : 0x0000000000402000  →  "Fibonacci Sequence:\n"</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">$rdi</span>   : 0x1 </span>

gef➤  si

Fibonacci Sequence:
</code></pre><p>We see a couple of things that we expected:</p>
<ol>
<li>Our arguments are properly set in the corresponding registers before each syscall.</li>
<li>A pointer to our message is loaded in <code>rsi</code>.</li>
</ol>
<p>Now, we have successfully used the <code>write</code> syscall to print our intro message.</p>
<hr>
<h3 id="exit-syscall">Exit Syscall</h3>
<p>Finally, since we have understood how syscalls work, let&#39;s go through another essential syscall used in programs: <code>Exit syscall</code>. We may have noticed that so far, whenever our program finishes executing, it exits with a <code>segmentation fault</code>, as we just saw when we ran <code>./fib</code>. This is because we are ending our program abruptly, without going through the proper procedure of exiting programs in Linux, by calling the <code>exit syscall</code> and passing an exit code.</p>
<p>So, let&#39;s add this to the end of our code. First, we need to find the <code>exit syscall</code> number, as follows:</p>
<p>&#x20; Syscalls</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ grep <span class="hljs-built_in">exit</span> /usr/include/x86_64-linux-gnu/<span class="hljs-keyword">asm</span>/unistd_64.h

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_exit 60</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NR_exit_group 231</span>
</code></pre>
<p>We need to use the first one, with a syscall number <code>60</code>. Next, let&#39;s see if the <code>exit syscall</code> needs any arguments:</p>
<p>&#x20; Syscalls</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[/htb]$ man -s <span class="hljs-number">2</span> exit

...SNIP...
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_exit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span></span>;
</code></pre>
<p>We see that it only needs one integer argument, <code>status</code>&#39;, which is explained to be the exit code. In Linux, whenever a program exits without any errors, it passes an exit code of <code>0</code>. Otherwise, the exit code is a different number, usually <code>1</code>. In our case, as everything went as expected, we&#39;ll pass the exit code of <code>0</code>. Our <code>exit syscall</code> code should be as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<p>Now, let&#39;s add it to the end of our code:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Fibonacci Sequence:"</span>, <span class="hljs-number">0x0a</span>

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; rax: syscall number 1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>      <span class="hljs-comment">; rdi: fd 1 for stdout</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>,message <span class="hljs-comment">; rsi: pointer to message</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">20</span>      <span class="hljs-comment">; rdx: print length of 20 bytes</span>
    <span class="hljs-keyword">syscall</span>         <span class="hljs-comment">; call write syscall to the intro message</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
<span class="hljs-symbol">loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">10</span>        <span class="hljs-comment">; do rbx - 10</span>
    <span class="hljs-keyword">js</span> loopFib        <span class="hljs-comment">; jump if result is &lt;0</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<p>We can now assemble our code and rerun it:</p>
<p>&#x20; Syscalls</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ./assembler<span class="hljs-selector-class">.sh</span> fib<span class="hljs-selector-class">.s</span>

Fibonacci Sequence:
</code></pre>
<p>Great! We see that this time our program exited properly without a <code>segmentation fault</code>. We can check the exit code that was passed as follows:</p>
<p>&#x20; Syscalls</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ echo $?

<span class="hljs-number">0</span>
</code></pre>
<p>As expected, the exit code was <code>0</code>, as we specified in our syscall.</p>
<p>Practice: To get a full grasp of how syscalls work, try to implement the <code>write</code> syscall to print the Fibonacci number, and place it after &#39;<code>xchg rax, rbx</code>&#39;.</p>
<p>Spoiler: It will not work. Try to find out why, and attempt to fix it to print the first few Fibonacci numbers below <code>10</code> (hint: use <code>ASCII</code>).</p>
<hr>
<h2 id="procedures">Procedures</h2>
<hr>
<p>As our code grows in complexity, we need to start refactoring our code to make more efficient use of the instructions and make it easier to read and understand. A common way to do so is through the use of <code>functions</code> and <code>procedures</code>. While functions require a calling procedure to call them and pass their arguments (as we will discuss in the next section), <code>procedures</code> are usually more straightforward and mainly used for code refactoring.</p>
<p>A <code>procedure</code> (sometimes referred to as a <code>subroutine</code>) is usually a set of instructions we want to execute at specific points in the program. So instead of reusing the same code, we define it under a procedure label and <code>call</code> it whenever we need to use it. This way, we only need to write the code once but can use it multiple times. Furthermore, we can use procedures to split a larger and more complex code into smaller, simpler segments.</p>
<p>Let&#39;s go back to our code:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Fibonacci Sequence:"</span>, <span class="hljs-number">0x0a</span>

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; rax: syscall number 1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>      <span class="hljs-comment">; rdi: fd 1 for stdout</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>,message <span class="hljs-comment">; rsi: pointer to message</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">20</span>      <span class="hljs-comment">; rdx: print length of 20 bytes</span>
    <span class="hljs-keyword">syscall</span>         <span class="hljs-comment">; call write syscall to the intro message</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
<span class="hljs-symbol">
loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">10</span>        <span class="hljs-comment">; do rbx - 10</span>
    <span class="hljs-keyword">js</span> loopFib        <span class="hljs-comment">; jump if result is &lt;0</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<p>We see that we are now doing multiple things in a big chunk of code:</p>
<ol>
<li>Printing the intro message</li>
<li>Setting initial Fibonacci values to <code>0</code> and <code>1</code></li>
<li>Using a loop to calculate the following Fibonacci number</li>
<li>Exiting the program</li>
</ol>
<p>Our loop is already defined under a label, so we can call it when we need it. However, the three other parts of the code can be refactored as procedures to call them whenever we need to, increasing code efficiency.</p>
<hr>
<h3 id="defining-procedures">Defining Procedures</h3>
<p>As a starting point, let&#39;s add a label above each of the three parts of the code we want to turn into procedures:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Fibonacci Sequence:"</span>, <span class="hljs-number">0x0a</span>

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
<span class="hljs-symbol">
printMessage:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>       <span class="hljs-comment">; rax: syscall number 1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>      <span class="hljs-comment">; rdi: fd 1 for stdout</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>,message <span class="hljs-comment">; rsi: pointer to message</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">20</span>      <span class="hljs-comment">; rdx: print length of 20 bytes</span>
    <span class="hljs-keyword">syscall</span>         <span class="hljs-comment">; call write syscall to the intro message</span>
<span class="hljs-symbol">
initFib:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
<span class="hljs-symbol">
loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">10</span>        <span class="hljs-comment">; do rbx - 10</span>
    <span class="hljs-keyword">js</span> loopFib        <span class="hljs-comment">; jump if result is &lt;0</span>
<span class="hljs-symbol">
Exit:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<p>We see that our code already looks better. However, this is not any more efficient than it was, as we could have achieved the same by using comments. So, our next step is to use <code>calls</code> to direct the program to each of our procedures.</p>
<hr>
<h3 id="call-ret">CALL/RET</h3>
<p>When we want to start executing a procedure, we can <code>call</code> it, and it will go through its instructions. The <code>call</code> instruction pushes (i.e., saves) the next instruction pointer <code>rip</code> to the stack and then jumps to the specified procedure.</p>
<p>Once the procedure is executed, we should end it with a <code>ret</code> instruction to return to the point we were at before jumping to the procedure. The <code>ret</code> instruction <code>pops</code> the address at the top of the stack into <code>rip</code>, so the program&#39;s next instruction is restored to what it was before jumping to the procedure.</p>
<p>The <code>ret</code> instruction plays an essential role in <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">Return-Oriented Programming (ROP)</a>, an exploitation technique usually used with Binary Exploitation.</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>call</code></td>
<td>push the next instruction pointer <code>rip</code> to the stack, then jumps to the specified procedure</td>
<td><code>call printMessage</code></td>
</tr>
<tr>
<td><code>ret</code></td>
<td>pop the address at <code>rsp</code> into <code>rip</code>, then jump to it</td>
<td><code>ret</code></td>
</tr>
</tbody>
</table>
<p>So with that, we can set up our calls at the beginning of our code to define the execution flow we want:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Fibonacci Sequence:"</span>, <span class="hljs-number">0x0a</span>

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">call</span> printMessage   <span class="hljs-comment">; print intro message</span>
    <span class="hljs-keyword">call</span> initFib        <span class="hljs-comment">; set initial Fib values</span>
    <span class="hljs-keyword">call</span> loopFib        <span class="hljs-comment">; calculate Fib numbers</span>
    <span class="hljs-keyword">call</span> Exit           <span class="hljs-comment">; Exit the program</span>
<span class="hljs-symbol">
printMessage:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>      <span class="hljs-comment">; rax: syscall number 1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>      <span class="hljs-comment">; rdi: fd 1 for stdout</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>,message <span class="hljs-comment">; rsi: pointer to message</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">20</span>     <span class="hljs-comment">; rdx: print length of 20 bytes</span>
    <span class="hljs-keyword">syscall</span>         <span class="hljs-comment">; call write syscall to the intro message</span>
    <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
initFib:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>    <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; increment rbx to 1</span>
    <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
loopFib:</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">10</span>        <span class="hljs-comment">; do rbx - 10</span>
    <span class="hljs-keyword">js</span> loopFib        <span class="hljs-comment">; jump if result is &lt;0</span>
    <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
Exit:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<p>This way, our code should execute the same instructions as before while having our code cleaner and more efficient. From now on, if we need to edit a specific procedure, we won&#39;t have to display the entire code, but only that procedure. We can also see that we did not use <code>ret</code> in our <code>Exit</code> procedure, as we don&#39;t want to return to where we were. We want to exit the code. We will almost always use a <code>ret</code>, and the <code>Exit</code> function is one of the few exceptions.</p>
<p>Note: It is important to understand the line-based execution flow of assembly. If we don&#39;t use a <code>ret</code> at the end of a procedure it will simply execute the next line. Likewise, had we returned at the end of our <code>Exit</code> function, we would simply go back and execute the next line, which would be the first line of <code>printMessage</code>.</p>
<p>Finally, we should also mention the <code>enter</code> and <code>leave</code> instructions, which are sometimes used with procedures to save and restore the addresses of <code>rsp</code> and <code>rbp</code> and allocate a specific stack space to be used by the procedure. We won&#39;t be needing to make use of them in this module, however.</p>
<hr>
<h2 id="functions">Functions</h2>
<hr>
<p>We should now understand the different branching and control instructions used to control the program&#39;s execution flow. We should also have a proper grasp of procedures and calls and how to utilize them for branching. So, let&#39;s now focus on calling functions.</p>
<hr>
<h3 id="functions-calling-convention">Functions Calling Convention</h3>
<p>Functions are a form of <code>procedures</code>. However, functions tend to be more complex and should be expected to use the stack and all registers fully. So, we can&#39;t simply call a function as we did with procedures. Instead, functions have a <code>Calling Convention</code> to properly set up before being called.</p>
<p>There are four main things we need to consider before calling a function:</p>
<ol>
<li><code>Save Registers</code> on the stack (<code>Caller Saved</code>)</li>
<li>Pass <code>Function Arguments</code> (like syscalls)</li>
<li>Fix <code>Stack Alignment</code></li>
<li>Get Function&#39;s <code>Return Value</code> (in <code>rax</code>)</li>
</ol>
<p>This is relatively similar to calling a syscall, and the only difference with syscalls is that we have to store the syscall number in <code>rax</code>, while we can call functions directly with <code>call function</code>. Furthermore, with syscall we don&#39;t have to worry about <code>Stack Alignment</code>.</p>
<p><strong>Writing Functions</strong></p>
<p>All of the above points are from a <code>caller</code> point of view, as we call a function. When it comes to writing a function, there are different points to consider, which are:</p>
<ol>
<li>Saving <code>Callee Saved</code> registers (<code>rbx</code> and <code>rbp</code>)</li>
<li>Get arguments from registers</li>
<li>Align the Stack</li>
<li>Return value in <code>rax</code></li>
</ol>
<p>As we can see, these points are relatively similar to the <code>caller</code> points. The <code>caller</code> is setting up things, and then the <code>callee</code> (i.e., receiver) should retrieve those things and use them. These points are usually made at the beginning, and the end of the function and are called a function&#39;s <code>prologue</code> and <code>epilogue</code>. They allow functions to be called without worrying about the current state of the stack or the registers.</p>
<p><code>In this module, we will only be calling other functions,</code> so we only have to focus on setting up a function call and won&#39;t go into writing functions.</p>
<hr>
<h3 id="using-external-functions">Using External Functions</h3>
<p>We want to print the current Fibonacci number at each iteration of the <code>loopFib</code> loop. Previously, we could not use a <code>write</code> syscall since it only accepts <code>ASCII</code> characters. We would have had to convert our Fibonacci number to <code>ASCII</code>, which is a bit complicated.</p>
<p>Luckily, there are external functions we can use to print the current number without having to convert it. The <code>libc</code> library of functions used for <code>C</code> programs provides many functionalities that we can utilize without rewriting everything from scratch. The <code>printf</code> function in <code>libc</code> accepts the printing format, so we can pass it the current Fibonacci number and tell it to print it as an integer, and it&#39;ll do the conversion automatically. Before we can use a function from <code>libc</code>, we have to import it first and then specify the <code>libc</code> library for dynamic linking when linking our code with <code>ld</code>.</p>
<hr>
<h3 id="importing-libc-functions">Importing libc Functions</h3>
<p>First, to import an external <code>libc</code> function, we can use the <code>extern</code> instruction at the beginning of our code, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">global  _start
<span class="hljs-keyword">extern</span>  <span class="hljs-built_in">printf</span>
</code></pre>
<p>Once this is done, we should be able to call the <code>printf</code> function. So, we can proceed with the <code>Functions Calling Convention</code> we discussed earlier.</p>
<hr>
<h3 id="saving-registers">Saving Registers</h3>
<p>Let&#39;s define a new procedure, <code>printFib</code>, to hold our function call instructions. The very first step is to save to the stack any registers we are using, which are <code>rax</code> and <code>rbx</code>, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-symbol">printFib:</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rax</span>        <span class="hljs-comment">; push registers to stack</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-comment">; function call</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rbx</span>         <span class="hljs-comment">; restore registers from stack</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rax</span>
    <span class="hljs-keyword">ret</span>
</code></pre>
<p>So, we can proceed with the second point, and pass the required arguments to <code>printf</code>.</p>
<hr>
<h3 id="function-arguments">Function Arguments</h3>
<p>We have already discussed how to pass function arguments in the syscall section. The same process applies to function arguments.</p>
<p>First, we need to find out what arguments are accepted by the <code>printf</code> function by using <code>man -s 3</code> for <code>library functions manual</code> (as we can see in <code>man man</code>):</p>
<p>&#x20; Functions</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ man -s <span class="hljs-number">3</span> <span class="hljs-built_in">printf</span>

...SNIP...
       <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;
</code></pre>
<p>As we can see, the function takes a pointer to the print format (shown with a <code>*</code>), and then the string(s) to be printed.</p>
<p>First, we can create a variable that contains the output format to pass it as the first argument. The <code>printf</code> man page also details various print formats. We want to print an integer, so we can use the <code>%d</code> format, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start
<span class="hljs-meta">extern</span>  printf

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Fibonacci Sequence:"</span>, <span class="hljs-number">0x0a</span>
    outFormat <span class="hljs-built_in">db</span>  <span class="hljs-string">"%d"</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x00</span>
</code></pre>
<p>Note: We ended the format with a null character <code>0x00</code>, as this is the string terminator in <code>printf</code>, and we must terminate any string with it.</p>
<p>This can be our first argument, and <code>rbx</code> as our second argument, which <code>printf</code> will place as <code>%d</code>. So, let&#39;s move both arguments to their respective registers, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-symbol">printFib:</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rax</span>            <span class="hljs-comment">; push registers to stack</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, outFormat  <span class="hljs-comment">; set 1st argument (Print Format)</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rbx</span>        <span class="hljs-comment">; set 2nd argument (Fib Number)</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rbx</span>             <span class="hljs-comment">; restore registers from stack</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rax</span>
    <span class="hljs-keyword">ret</span>
</code></pre>
<hr>
<h3 id="stack-alignment">Stack Alignment</h3>
<p>Whenever we want to make a <code>call</code> to a function, we must ensure that the <code>Top Stack Pointer (rsp)</code> is aligned by the <code>16-byte</code> boundary from the <code>_start</code> function stack.</p>
<p>This means that we have to push at least 16-bytes (or a multiple of 16-bytes) to the stack before making a call to ensure functions have enough stack space to execute correctly. This requirement is mainly there for processor performance efficiency. Some functions (like in <code>libc</code>) are programed to crash if this boundary is not fixed to ensure performance efficiency. If we assemble our code and break right after the second <code>push</code>, this is what we will see:</p>
<p>&#x20; gdb</p>
<pre><code>───────────────────────────────────────────────────────────────────────────────────────── stack ────
<span class="hljs-number">0x00007fffffffe3a0</span>│+<span class="hljs-number">0x0000</span>: <span class="hljs-number">0x0000000000000001</span>     ← $<span class="hljs-built_in">rsp</span>
<span class="hljs-number">0x00007fffffffe3a8</span>│+<span class="hljs-number">0x0008</span>: <span class="hljs-number">0x0000000000000000</span>
<span class="hljs-number">0x00007fffffffe3b0</span>│+<span class="hljs-number">0x0010</span>: <span class="hljs-number">0x00000000004010ad</span>  →  &lt;loopFib+<span class="hljs-number">5</span>&gt; <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>
<span class="hljs-number">0x00007fffffffe3b8</span>│+<span class="hljs-number">0x0018</span>: <span class="hljs-number">0x0000000000401044</span>  →  &lt;_start+<span class="hljs-number">20</span>&gt; <span class="hljs-keyword">call</span> <span class="hljs-number">0x4010bd</span> &lt;Exit&gt;
<span class="hljs-number">0x00007fffffffe3c0</span>│+<span class="hljs-number">0x0020</span>: <span class="hljs-number">0x0000000000000001</span>     ← $<span class="hljs-built_in">r13</span>
─────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
     <span class="hljs-number">0x401090</span> &lt;initFib+<span class="hljs-number">9</span>&gt;      <span class="hljs-keyword">ret</span>    
     <span class="hljs-number">0x401091</span> &lt;printFib+<span class="hljs-number">0</span>&gt;     <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rax</span>
     <span class="hljs-number">0x401092</span> &lt;printFib+<span class="hljs-number">1</span>&gt;     <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbx</span>
 →   <span class="hljs-number">0x40100e</span> &lt;printFib+<span class="hljs-number">2</span>&gt;     movabs <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0x403039</span>
</code></pre><p>We see that we have four 8-bytes pushed to the stack, making a total boundary of 32-bytes. This is due to two things:</p>
<ol>
<li>Each procedure <code>call</code> adds an 8-byte address to the stack, which is then removed with <code>ret</code></li>
<li>Each <code>push</code> adds 8-bytes to the stack as well</li>
</ol>
<p>So, we are inside <code>printFib</code> and inside <code>loopFib</code>, and have pushed <code>rax</code> and <code>rbx</code>, for a total of a 32-byte boundary. Since the boundary is a multiple of 16, <code>our stack is already aligned, and we don&#39;t have to fix anything.</code></p>
<p>If we were in a case where we wanted to bring the boundary up to 16, we can subtract bytes from <code>rsp</code>, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">rsp</span>, <span class="hljs-number">16</span>
    <span class="hljs-keyword">call</span> function
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rsp</span>, <span class="hljs-number">16</span>
</code></pre>
<p>This way, we are adding an extra 16-bytes to the top of the stack and then removing them after the call. If we had 8 bytes pushed, we can bring the boundary up to 16 by subtracting 8 from <code>rsp</code>.</p>
<p>This may be a bit confusing, but the critical thing to remember is that <code>we should have 16-bytes (or a multiple of 16) on top of the stack before making a call.</code> We can count the number of (un<code>pop</code>ed) <code>push</code> instructions and (un<code>ret</code>urned) <code>call</code> instructions, and we will get how many 8-bytes have been pushed to the stack.</p>
<hr>
<h3 id="function-call">Function Call</h3>
<p>Finally, we can issue <code>call printf</code>, and it should print the current Fibonacci number in the format we specified, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-symbol">printFib:</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rax</span>            <span class="hljs-comment">; push registers to stack</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, outFormat  <span class="hljs-comment">; set 1st argument (Print Format)</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rbx</span>        <span class="hljs-comment">; set 2nd argument (Fib Number)</span>
    <span class="hljs-keyword">call</span> printf         <span class="hljs-comment">; printf(outFormat, rbx)</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rbx</span>             <span class="hljs-comment">; restore registers from stack</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rax</span>
    <span class="hljs-keyword">ret</span>
</code></pre>
<p>Now we should have our <code>printFib</code> procedure ready. So, we can add it to the beginning of <code>loopFib</code>, such that it prints the current Fibonacci number at the beginning of each loop:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-symbol">loopFib:</span>
    <span class="hljs-keyword">call</span> printFib   <span class="hljs-comment">; print current Fib number</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>    <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>   <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">10</span>        <span class="hljs-comment">; do rbx - 10</span>
    <span class="hljs-keyword">js</span> loopFib        <span class="hljs-comment">; jump if result is &lt;0</span>
    <span class="hljs-keyword">ret</span>
</code></pre>
<p>Our final <code>fib.s</code> code should be as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start
<span class="hljs-meta">extern</span>  printf

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Fibonacci Sequence:"</span>, <span class="hljs-number">0x0a</span>
    outFormat <span class="hljs-built_in">db</span>  <span class="hljs-string">"%d"</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x00</span>

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">call</span> printMessage   <span class="hljs-comment">; print intro message</span>
    <span class="hljs-keyword">call</span> initFib        <span class="hljs-comment">; set initial Fib values</span>
    <span class="hljs-keyword">call</span> loopFib        <span class="hljs-comment">; calculate Fib numbers</span>
    <span class="hljs-keyword">call</span> Exit           <span class="hljs-comment">; Exit the program</span>
<span class="hljs-symbol">
printMessage:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>           <span class="hljs-comment">; rax: syscall number 1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>          <span class="hljs-comment">; rdi: fd 1 for stdout</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, message    <span class="hljs-comment">; rsi: pointer to message</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">20</span>          <span class="hljs-comment">; rdx: print length of 20 bytes</span>
    <span class="hljs-keyword">syscall</span>             <span class="hljs-comment">; call write syscall to the intro message</span>
    <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
initFib:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>        <span class="hljs-comment">; initialize rax to 0</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>        <span class="hljs-comment">; initialize rbx to 0</span>
    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">rbx</span>             <span class="hljs-comment">; increment rbx to 1</span>
    <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
printFib:</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rax</span>            <span class="hljs-comment">; push registers to stack</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, outFormat  <span class="hljs-comment">; set 1st argument (Print Format)</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rbx</span>        <span class="hljs-comment">; set 2nd argument (Fib Number)</span>
    <span class="hljs-keyword">call</span> printf         <span class="hljs-comment">; printf(outFormat, rbx)</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rbx</span>             <span class="hljs-comment">; restore registers from stack</span>
    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">rax</span>
    <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
loopFib:</span>
    <span class="hljs-keyword">call</span> printFib       <span class="hljs-comment">; print current Fib number</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>        <span class="hljs-comment">; get the next number</span>
    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rbx</span>       <span class="hljs-comment">; swap values</span>
    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-number">10</span>            <span class="hljs-comment">; do rbx - 10</span>
    <span class="hljs-keyword">js</span> loopFib            <span class="hljs-comment">; jump if result is &lt;0</span>
    <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
Exit:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<hr>
<h3 id="dynamic-linker">Dynamic Linker</h3>
<p>We can now assemble our code with <code>nasm</code>. When we link our code with <code>ld</code>, we should tell it to do dynamic linking with the <code>libc</code> library. Otherwise, it would not know how to fetch the imported <code>printf</code> function. We can do so with the <code>-lc --dynamic-linker /lib64/ld-linux-x86-64.so.2</code> flags, as follows:</p>
<p>&#x20; Functions</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ nasm -f elf64 fib.s &amp;&amp;  ld fib.o -o fib -lc --dynamic-linker /lib64/ld-linux-x86<span class="hljs-number">-64.</span>so<span class="hljs-number">.2</span> &amp;&amp; ./fib

<span class="hljs-number">1</span>
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">5</span>
<span class="hljs-number">8</span>
</code></pre>
<p>As we can see, <code>printf</code> made it very easy to print our Fibonacci number without worrying about converting it to the proper format, like we had to with the <code>write</code> syscall. Next, we need to go through another example of using external <code>libc</code> functions to understand how to call external functions properly.</p>
<hr>
<h2 id="libc-functions">Libc Functions</h2>
<hr>
<p>So far, we have only been printing Fibonacci numbers that are less than <code>10</code>. But this way, our program is static and will print the same output every time. To make it more dynamic, we can ask the user for the max Fibonacci number they want to print and then use it with <code>cmp</code>. Before we start, let&#39;s recall the function calling convention:</p>
<ol>
<li><code>Save Registers</code> on the Stack (<code>Caller Saved</code>)</li>
<li>Pass <code>Function Arguments</code> (like syscalls)</li>
<li>Fix <code>Stack Alignment</code></li>
<li>Get Functions&#39; <code>Return Value</code> (in <code>rax</code>)</li>
</ol>
<p>So, let&#39;s import our function and start with the calling convention steps.</p>
<hr>
<h3 id="importing-libc-functions">Importing libc Functions</h3>
<p>To do so, we can use the <code>scanf</code> function from <code>libc</code> to take user input and have it properly converted to an integer, which we will later use with <code>cmp</code>. First, we must import the <code>scanf</code>, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">global  _start
<span class="hljs-keyword">extern</span>  <span class="hljs-built_in">printf</span>, <span class="hljs-built_in">scanf</span>
</code></pre>
<p>We can now start writing a new procedure, <code>getInput</code>, so we can call it when we need to:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">getInput:
    ; call <span class="hljs-built_in">scanf</span>
</code></pre>
<hr>
<h3 id="saving-registers">Saving Registers</h3>
<p>As we are at the beginning of our program and have not yet used any register, we don&#39;t have to worry about saving registers to the Stack. So, we can proceed with the second point, and pass the required arguments to <code>scanf</code>.</p>
<hr>
<h3 id="function-arguments">Function Arguments</h3>
<p>Next, we need to know what arguments are accepted by <code>scanf</code>, as follows:</p>
<p>&#x20; Libc Functions</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ man -s <span class="hljs-number">3</span> <span class="hljs-built_in">scanf</span>

...SNIP...
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">scanf</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, ...)</span></span>;
</code></pre>
<p>We see that similarly to <code>printf</code>, <code>scanf</code> accepts an input format and the buffer we want to save the user input into. So, let&#39;s first add the <code>inFormat</code> variable:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Please input max Fn"</span>, <span class="hljs-number">0x0a</span>
    outFormat <span class="hljs-built_in">db</span>  <span class="hljs-string">"%d"</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x00</span>
    inFormat <span class="hljs-built_in">db</span>  <span class="hljs-string">"%d"</span>, <span class="hljs-number">0x00</span>
</code></pre>
<p>We also changed our intro message from <code>Fibonacci Sequence:</code> to <code>Please input max Fn</code>, to tell the user what input is expected from them.</p>
<p>Next, we must set a buffer space for the input storage. As we mentioned in the <code>Processor Architecture</code> section, uninitialized buffer space must be stored in the <code>.bss</code> memory segment. So, at the beginning of our assembly code, we must add it under the <code>.bss</code> label, and use <code>resb 1</code> to tell <code>nasm</code> to reserve 1 byte of buffer space, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-selector-tag">section</span> <span class="hljs-selector-class">.bss</span>
    userInput resb <span class="hljs-number">1</span>
</code></pre>
<p>We can now set our function arguments under our <code>getInput</code> procedure:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">getInput:
    mov rdi, inFormat   ; <span class="hljs-keyword">set</span> 1st <span class="hljs-comment">parameter (inFormat)</span>
    mov <span class="hljs-comment">rsi, userInput</span>  ; <span class="hljs-keyword">set</span> 2nd <span class="hljs-comment">parameter (userInput)</span>
</code></pre>
<hr>
<h3 id="stack-alignment">Stack Alignment</h3>
<p>Next, we have to ensure that a 16-bytes boundary aligns our Stack. We are currently inside the <code>getInput</code> procedure, so we have 1 <code>call</code> instruction and no <code>push</code> instructions, so we have an <code>8-byte</code> boundary. So, we can use <code>sub</code> to fix <code>rsp</code>, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">getInput:
    <span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">rsp</span>, 8
    </span>; call scanf
    add rsp, <span class="hljs-number">8</span>
</code></pre>
<p>We can <code>push rax</code> instead, and this will properly align the Stack as well. This way, our Stack should be perfectly aligned with a 16-byte boundary.</p>
<hr>
<h3 id="function-call">Function Call</h3>
<p>Now, we set the function arguments and <code>call scanf</code>, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-symbol">getInput:</span>
    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">rsp</span>, <span class="hljs-number">8</span>          <span class="hljs-comment">; align stack to 16-bytes</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, inFormat   <span class="hljs-comment">; set 1st parameter (inFormat)</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, userInput  <span class="hljs-comment">; set 2nd parameter (userInput)</span>
    <span class="hljs-keyword">call</span> scanf          <span class="hljs-comment">; scanf(inFormat, userInput)</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rsp</span>, <span class="hljs-number">8</span>          <span class="hljs-comment">; restore stack alignment</span>
    <span class="hljs-keyword">ret</span>
</code></pre>
<p>We will also add <code>call getInput</code> at <code>_start</code>, so that we go to this procedure right after printing the intro message, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">section .text
_start:
    <span class="hljs-keyword">call</span> printMessage   ; print intro message
    <span class="hljs-keyword">call</span> getInput       ; get max number
    <span class="hljs-keyword">call</span> initFib        ; <span class="hljs-keyword">set</span> <span class="hljs-keyword">initial</span> Fib <span class="hljs-keyword">values</span>
    <span class="hljs-keyword">call</span> loopFib        ; calculate Fib numbers
    <span class="hljs-keyword">call</span> <span class="hljs-keyword">Exit</span>           ; Exit the program
</code></pre>
<p>Finally, we have to make use of the user input. To do so, instead of using a static <code>10</code> when comparing in <code>cmp rbx, 10</code>, we will change it to <code>cmp rbx, [userInput]</code>, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">loopFib:
    ...<span class="hljs-type">SNIP</span>...
    cmp rbx,[userInput] ; <span class="hljs-keyword">do</span> rbx - userInput
    js loopFib            ; jump <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span> <span class="hljs-keyword">is</span> &lt;<span class="hljs-number">0</span>
    ret
</code></pre>
<p>Note: We used <code>[userInput]</code> instead of <code>userInput</code>, as we wanted to compare with the final value, and not with the pointer address.</p>
<p>With all of that done, our final complete code should look as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span>  _start
<span class="hljs-meta">extern</span>  printf, scanf

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Please input max Fn"</span>, <span class="hljs-number">0x0a</span>
    outFormat <span class="hljs-built_in">db</span>  <span class="hljs-string">"%d"</span>, <span class="hljs-number">0x0a</span>, <span class="hljs-number">0x00</span>
    inFormat <span class="hljs-built_in">db</span>  <span class="hljs-string">"%d"</span>, <span class="hljs-number">0x00</span>

<span class="hljs-meta">section</span> .bss
    userInput <span class="hljs-built_in">resb</span> <span class="hljs-number">1</span>

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">call</span> printMessage   <span class="hljs-comment">; print intro message</span>
    <span class="hljs-keyword">call</span> getInput       <span class="hljs-comment">; get max number</span>
    <span class="hljs-keyword">call</span> initFib        <span class="hljs-comment">; set initial Fib values</span>
    <span class="hljs-keyword">call</span> loopFib        <span class="hljs-comment">; calculate Fib numbers</span>
    <span class="hljs-keyword">call</span> Exit           <span class="hljs-comment">; Exit the program</span>
<span class="hljs-symbol">
printMessage:</span>
    ...SNIP...
<span class="hljs-symbol">
getInput:</span>
    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">rsp</span>, <span class="hljs-number">8</span>          <span class="hljs-comment">; align stack to 16-bytes</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, inFormat   <span class="hljs-comment">; set 1st parameter (inFormat)</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, userInput  <span class="hljs-comment">; set 2nd parameter (userInput)</span>
    <span class="hljs-keyword">call</span> scanf          <span class="hljs-comment">; scanf(inFormat, userInput)</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">rsp</span>, <span class="hljs-number">8</span>          <span class="hljs-comment">; restore stack alignment</span>
    <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
initFib:</span>
    ...SNIP...
<span class="hljs-symbol">
printFib:</span>
    ...SNIP...
<span class="hljs-symbol">
loopFib:</span>
    ...SNIP...
    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">rbx</span>,[userInput] <span class="hljs-comment">; do rbx - userInput</span>
    <span class="hljs-keyword">js</span> loopFib            <span class="hljs-comment">; jump if result is &lt;0</span>
    <span class="hljs-keyword">ret</span>
<span class="hljs-symbol">
Exit:</span>
    ...SNIP...
</code></pre>
<hr>
<h3 id="dynamic-linker">Dynamic Linker</h3>
<p>Let&#39;s assemble our code, link it, and try to print Fibonacci numbers up to <code>100</code>:</p>
<p>&#x20; Libc Functions</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ nasm -f elf64 fib<span class="hljs-selector-class">.s</span> &amp;&amp;  ld fib<span class="hljs-selector-class">.o</span> -o fib -lc --dynamic-linker /lib64/ld-linux-x86-<span class="hljs-number">64</span><span class="hljs-selector-class">.so</span>.<span class="hljs-number">2</span> &amp;&amp; ./fib

Please <span class="hljs-selector-tag">input</span> max Fn:
<span class="hljs-number">100</span>
<span class="hljs-number">1</span>
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
<span class="hljs-number">5</span>
<span class="hljs-number">8</span>
<span class="hljs-number">13</span>
<span class="hljs-number">21</span>
<span class="hljs-number">34</span>
<span class="hljs-number">55</span>
<span class="hljs-number">89</span>
</code></pre>
<p>We see that our code worked as expected and printed Fibonacci numbers less than the number we specified. With this, we can complete our module project and create a program that calculates and prints Fibonacci numbers based on an input we provide, using nothing but assembly.</p>
<p>Besides, we need to learn how to turn Assembly code into machine shellcode, which we can then use directly in our payloads in Binary Exploitation.</p>
<hr>
<h2 id="shellcodes">Shellcodes</h2>
<hr>
<p>We should have a very good understanding of the computer and processor architecture and how programs interact with this underlying architecture through what we have learned in this module. We should also be able to disassemble and debug binaries and get a good understanding of what machine instructions they are executing and what their general purpose is. Now we will learn about <code>shellcodes</code>, which is an essential concept for penetration testers.</p>
<hr>
<h3 id="what-is-a-shellcode">What is a Shellcode</h3>
<p>We know that each executable binary is made of machine instructions written in Assembly and then assembled into machine code. A <code>shellcode</code> is the hex representation of a binary&#39;s executable machine code. For example, let&#39;s take our <code>Hello World</code> program, which executes the following instructions:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span> _start

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Hello HTB Academy!"</span>

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, message
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">18</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">syscall</span>

    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<p>As we have seen in the first section, this <code>Hello World</code> program assembles the following shellcode:</p>
<p>Code: shellcode</p>
<pre><code class="lang-shellcode"><span class="hljs-number">48</span>be0020400000000000bf01000000ba12000000b8010000000f05b83c000000bf0<span class="hljs-number">00000000f05</span>
</code></pre>
<p>This shellcode should properly represent the machine instructions, and if passed to the processor memory, it should understand it and execute it properly.</p>
<hr>
<h3 id="use-in-pentesting">Use in Pentesting</h3>
<p>Having the ability to pass a shellcode directly to the processor memory and have it executed plays an essential role in <code>Binary Exploitation</code>. For example, with a buffer overflow exploit, we can pass a <code>reverse shell</code> shellcode, have it executed, and receive a reverse shell.</p>
<p>Modern <code>x86_64</code> systems may have protections against loading shellcodes into memory. This is why <code>x86_64</code> binary exploitation usually relies on <code>Return Oriented Programming (ROP)</code>, which also requires a good understanding of the assembly language and computer architecture covered in this module.</p>
<p>Furthermore, some attack techniques rely on infecting existing executables (like <code>elf</code> or <code>.exe</code>) or libraries (like <code>.so</code> or <code>.dll</code>) with shellcode, such that this shellcode is loaded into memory and executed once these files are run. Another advantage of using shellcodes in pentesting is the ability to directly execute code into memory without writing anything to the disk, which is very important for reducing our visibility and footprint on the remote server.</p>
<hr>
<h3 id="assembly-to-machine-code">Assembly to Machine Code</h3>
<p>To understand how shellcodes are generated, we must first understand how each instruction is converted into a machine code. Each <code>x86</code> instruction and each register has its own <code>binary</code> machine code (usually represented in <code>hex</code>), which represents the binary code passed directly to the processor to tell it what instruction to execute (through the Instruction Cycle.)</p>
<p>Furthermore, common combinations of instructions and registers have their own machine code as well. For example, the <code>push rax</code> instruction has the machine code <code>50</code>, while <code>push rbx</code> has the machine code <code>53</code>, and so on. When we assemble our code with <code>nasm</code>, it converts our assembly instructions to their respective machine code so that the processor can understand them.</p>
<p>Remember: Assembly language is made for human readability, and the processor cannot understand it without being converted into machine code. We will use <code>pwntools</code> to assemble and disassemble our machine code, as it is an essential tool for Binary Exploitation, and this is an excellent opportunity to start learning it. First, we can install <code>pwntools</code> with the following command (it should be already installed in PwnBox):</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ sudo pip3 install pwntools
</code></pre>
<p>Now, we can use <code>pwn asm</code> to assemble any assembly code into its shellcode, as follows:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ pwn asm <span class="hljs-string">'push rax'</span>  -c <span class="hljs-string">'amd64'</span>
   <span class="hljs-number">0</span>:    <span class="hljs-number">50</span>                       push   eax
</code></pre>
<p>Note: We used the <code>-c &#39;amd64&#39;</code> flag to ensure the tool properly interprets our assembly code for <code>x86_64</code></p>
<p>As we can see, we get <code>50</code>, which is the same machine code for <code>push rax</code>. Likewise, we can convert hex machine code or shellcode into its corresponding assembly code, as follows:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ pwn disasm <span class="hljs-string">'50'</span> -c <span class="hljs-string">'amd64'</span>
   <span class="hljs-number">0</span>:    <span class="hljs-number">50</span>                       push   eax
</code></pre>
<p>We can read more about <code>pwntools</code> assembly and disassembly features <a href="https://docs.pwntools.com/en/stable/asm.html">here</a>, and about the <code>pwntools</code> command-line tools <a href="https://docs.pwntools.com/en/stable/commandline.html">here</a>.</p>
<hr>
<h3 id="extract-shellcode">Extract Shellcode</h3>
<p>Now that we understand how each assembly instruction is converted into machine code (and vice-versa), let&#39;s see how to extract the shellcode from any binary.</p>
<p>A binary&#39;s shellcode represents its executable <code>.text</code> section only, as shellcodes are meant to be directly executable. To extract the <code>.text</code> section with <code>pwntools</code>, we can use the <code>ELF</code> library to load an <code>elf</code> binary, which would allow us to run various functions on it. So, let&#39;s run the <code>python3</code> interpreter to understand better how to use it. First, we&#39;ll have to import <code>pwntools</code>, and then we can read the <code>elf</code> binary, as follows:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ python3

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *
<span class="hljs-meta">&gt;&gt;&gt; </span>file = ELF(<span class="hljs-string">'helloworld'</span>)
</code></pre>
<p>Now, we can run various <code>pwntools</code> functions on it, which we can read more about <a href="https://docs.pwntools.com/en/stable/elf/elf.html">here</a>. We need to dump machine code from the executable <code>.text</code> section, which we can do with the <code>section()</code> function, as follows:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session"><span class="hljs-meta">&gt;&gt;</span>&gt; file.section(<span class="hljs-string">".text"</span>).hex()
<span class="hljs-string">'48be0020400000000000bf01000000ba12000000b8010000000f05b83c000000bf000000000f05'</span>
</code></pre>
<p>Note: We added &#39;<code>hex()</code>&#39; to encode the shellcode in hex, instead of printing it in raw bytes.</p>
<p>We see that we were very easily able to extract the binary&#39;s shellcode. Let&#39;s turn this into a Python script so that we can quickly use it to extract the shellcode of any binary:</p>
<p>Code: python</p>
<pre><code class="lang-python"><span class="hljs-meta">#!/usr/bin/python3</span>

<span class="hljs-keyword">import</span> sys
from pwn <span class="hljs-keyword">import</span> *

context(os=<span class="hljs-string">"linux"</span>, arch=<span class="hljs-string">"amd64"</span>, log_level=<span class="hljs-string">"error"</span>)

file = ELF(sys.argv[<span class="hljs-number">1</span>])
shellcode = file.section(<span class="hljs-string">".text"</span>)
print(shellcode.hex())
</code></pre>
<p>We can copy the above script to <code>shellcoder.py</code>, and then pass it any binary file&#39;s name as an argument, and it&#39;ll extract it&#39;s shellcode:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ python3 shellcoder.py helloworld

<span class="hljs-number">48</span>be0020400000000000bf01000000ba12000000b8010000000f05b83c000000bf000000000f05
</code></pre>
<p>Another (somewhat less reliable) method to extract the shellcode would be through <code>objdump</code>, which we&#39;ve used in a previous section. We can write the following <code>bash</code> script into <code>shellcoder.sh</code> and use it to extract the shellcode if we can&#39;t use the first script:</p>
<p>Code: bash</p>
<pre><code class="lang-bash"><span class="hljs-meta">#!/bin/bash
</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $(objdump <span class="hljs-_">-d</span> <span class="hljs-variable">$1</span> |grep <span class="hljs-string">"^ "</span> |cut <span class="hljs-_">-f</span>2); <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> -n <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span>; <span class="hljs-built_in">echo</span>;
</code></pre>
<p>Again, we can try running it on <code>helloworld</code> to get its shellcode, as follows:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ ./shellcoder.sh helloworld

<span class="hljs-number">48</span>be0020400000000000bf01000000ba12000000b8010000000f05b83c000000bf000000000f05
</code></pre>
<hr>
<h3 id="loading-shellcode">Loading Shellcode</h3>
<p>Now that we have a shellcode, let&#39;s try to run it, allowing us to test any shellcode we have prepared before using it in Binary Exploitation. The shellcode we extracted above does not meet the <code>Shellcoding Requirements</code> we&#39;ll discuss in the next section, and so it won&#39;t run. To demonstrate how to run shellcodes, we&#39;ll use the following (<code>fixed</code>) shellcode, that meets all <code>Shellcoding Requirements</code>:</p>
<p>Code: shellcode</p>
<pre><code class="lang-shellcode"><span class="hljs-number">4831d</span>b66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05
</code></pre>
<p>To run our shellcode with <code>pwntools</code>, we can use the <code>run_shellcode</code> function and pass it our shellcode, as follows:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ python3

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *
<span class="hljs-meta">&gt;&gt;&gt; </span>context(os=<span class="hljs-string">"linux"</span>, arch=<span class="hljs-string">"amd64"</span>, log_level=<span class="hljs-string">"error"</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>run_shellcode(unhex(<span class="hljs-string">'4831db66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05'</span>)).interactive()

Hello HTB Academy!
</code></pre>
<p>We used <code>unhex()</code> on the shellcode to convert it back to binary.</p>
<p>As we can see, our shellcode successfully ran and printed the string <code>Hello HTB Academy!</code>. In contrast, if we run the previous shellcode (which did not meet <code>Shellcoding Requirements</code>), it will not run:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session"><span class="hljs-meta">&gt;&gt;</span>&gt; run_shellcode(unhex(<span class="hljs-string">'b801000000bf0100000048be0020400000000000ba120000000f05b83c000000bf000000000f05'</span>)).interactive()
</code></pre>
<p>Once again, to make it easy to run our shellcodes, let&#39;s turn the above into a Python script:</p>
<p>Code: python</p>
<pre><code class="lang-python"><span class="hljs-meta">#!/usr/bin/python3</span>

<span class="hljs-keyword">import</span> sys
from pwn <span class="hljs-keyword">import</span> *

context(os=<span class="hljs-string">"linux"</span>, arch=<span class="hljs-string">"amd64"</span>, log_level=<span class="hljs-string">"error"</span>)

run_shellcode(unhex(sys.argv[<span class="hljs-number">1</span>])).interactive()
</code></pre>
<p>We can copy the above script to <code>loader.py</code>, pass our shellcode as an argument, and run it to execute our shellcode:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ python3 loader.py <span class="hljs-string">'4831db66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05'</span>

Hello HTB Academy!
</code></pre>
<p>As we can see, we were able to load and run our shellcode successfully.</p>
<hr>
<h3 id="debugging-shellcode">Debugging Shellcode</h3>
<p>Finally, let&#39;s see how we can debug our shellcode with <code>gdb</code>. If we are loading the machine code directly into memory, how would we run it with <code>gdb</code>? There are many ways to do so, and we&#39;ll go through some of them here.</p>
<p>We can always run our shellcode with <code>loader.py</code>, and then attach its process to <code>gdb</code> with <code>gdb -p PID</code>. However, this will only work if our process does not exit before we attach to it. So, we will instead build our shellcode to an <code>elf</code> binary and then use this binary with <code>gdb</code> like we&#39;ve been doing throughout the module.</p>
<p><strong>Pwntools</strong></p>
<p>We can use <code>pwntools</code> to build an <code>elf</code> binary from our shellcode using the <code>ELF</code> library, and then the <code>save</code> function to save it to a file:</p>
<p>Code: python</p>
<pre><code class="lang-python"><span class="hljs-selector-tag">ELF</span><span class="hljs-selector-class">.from_bytes</span>(unhex(<span class="hljs-string">'4831db66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05'</span>))<span class="hljs-selector-class">.save</span>(<span class="hljs-string">'helloworld'</span>)
</code></pre>
<p>To make it easier to use, we can turn the above into a script and write it to <code>assembler.py</code>:</p>
<p>Code: python</p>
<pre><code class="lang-python"><span class="hljs-meta">#!/usr/bin/python3</span>

<span class="hljs-keyword">import</span> sys, os, stat
from pwn <span class="hljs-keyword">import</span> *

context(os=<span class="hljs-string">"linux"</span>, arch=<span class="hljs-string">"amd64"</span>, log_level=<span class="hljs-string">"error"</span>)

ELF.from_bytes(unhex(sys.argv[<span class="hljs-number">1</span>])).save(sys.argv[<span class="hljs-number">2</span>])
os.chmod(sys.argv[<span class="hljs-number">2</span>], stat.S_IEXEC)
</code></pre>
<p>We can now run <code>assembler.py</code>, pass the shellcode as the first argument, and the file name as the second argument, and it&#39;ll assemble the shellcode into an executable:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ python assembler.py <span class="hljs-string">'4831db66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05'</span> <span class="hljs-string">'helloworld'</span>
</code></pre>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ ./helloworld

Hello HTB Academy!
</code></pre>
<p>As we can see, it built the <code>helloworld</code> binary with the file name we specified. We can now run it with <code>gdb</code>, and use <code>b *0x401000</code> to break at the default binary entry point:</p>
<p>&#x20; gdb</p>
<pre><code>$ gdb -q helloworld
gef➤  b *<span class="hljs-number">0x401000</span>
gef➤  r
Breakpoint <span class="hljs-number">1</span>, <span class="hljs-number">0x0000000000401000</span> <span class="hljs-keyword">in</span> ?? ()
...SNIP...
─────────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
●→   <span class="hljs-number">0x401000</span>                  <span class="hljs-keyword">xor</span>    <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>
     <span class="hljs-number">0x401003</span>                  <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">bx</span>, <span class="hljs-number">0x2179</span>
     <span class="hljs-number">0x401007</span>                  <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rbx</span>
</code></pre><p><strong>GCC</strong></p>
<p>There are other methods to build our shellcode into an <code>elf</code> executable. We can add our shellcode to the following <code>C</code> code, write it to a <code>helloworld.c</code>, and then build it with <code>gcc</code> (hex bytes must be escaped with <code>\x</code>):</p>
<p>Code: c</p>
<pre><code class="lang-c">#include &lt;stdio.h&gt;

int main()
{
    int (*ret)() = (int (*)()) "<span class="hljs-symbol">\x</span>48<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>db<span class="hljs-symbol">\x</span>66<span class="hljs-symbol">\x</span>bb<span class="hljs-symbol">\.</span>..SNIP...<span class="hljs-symbol">\x</span>3c<span class="hljs-symbol">\x</span>40<span class="hljs-symbol">\x</span>30<span class="hljs-symbol">\x</span>ff<span class="hljs-symbol">\x</span>0f<span class="hljs-symbol">\x</span>05";
    ret();
}
</code></pre>
<p>Then, we can compile our <code>C</code> code with <code>gcc</code>, and run it with <code>gdb</code>:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ gcc helloworld<span class="hljs-selector-class">.c</span> -o helloworld
root@htb[/htb]$ gdb -<span class="hljs-selector-tag">q</span> helloworld
</code></pre>
<p>However, this method is not very reliable for a few reasons. First, it will wrap the entire binary in <code>C</code> code, so the binary will not contain our shellcode, but will contain various other <code>C</code> functions and libraries. This method may also not always compile, depending on the existing memory protections, so we may have to add flags to bypass memory protections, as follows:</p>
<p>&#x20; Shellcodes</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[/htb]$ gcc helloworld.c -o helloworld -fno-stack-protector -z execstack -Wl,--omagic -g --<span class="hljs-keyword">static</span>
root<span class="hljs-meta">@htb</span>[<span class="hljs-regexp">/htb]$ ./</span>helloworld

Hello HTB Academy!
</code></pre>
<p>With this, we should have a good understanding of the basics of shellcodes. We can now create our own shellcodes for our next steps.</p>
<hr>
<h3 id="exercise-shellcode">Exercise Shellcode</h3>
<p>4831db536a0a48b86d336d307279217d5048b833645f316e37305f5048b84854427b6c303464504889e64831c0b0014831ff40b7014831d2b2190f054831c0043c4030ff0f05</p>
<hr>
<h2 id="shellcoding-techniques">Shellcoding Techniques</h2>
<hr>
<p>As we have seen in the previous section, our <code>Hello World</code> assembly code had to be modified to produce a working shellcode. So, in this section, we&#39;ll go through some of the techniques and tricks we can use to work around any issues found in our assembly code.</p>
<hr>
<h3 id="shellcoding-requirements">Shellcoding Requirements</h3>
<p>As we briefly mentioned in the previous section, not all binaries give working shellcodes that can be loaded directly to the memory and run. This is because there are specific requirements a shellcode must meet. Otherwise, it won&#39;t be properly disassembled on runtime into its correct assembly instructions.</p>
<p>To better understand this, let&#39;s try to disassemble the shellcode we extracted in the previous section from the <code>Hello World</code> program, using the same <code>pwn disasm</code> tool we previously used:</p>
<p>&#x20;&#x20;</p>
<pre><code>$ pwn disasm '48be0020400000000000bf01000000ba12000000b8010000000f05b83c000000bf000000000f05' -c 'amd64'
   0:   <span class="hljs-number"> 48 </span>be<span class="hljs-number"> 00 </span>20<span class="hljs-number"> 40 </span>00<span class="hljs-number"> 00 </span>    movabs rsi,  0x402000
   7:   <span class="hljs-number"> 00 </span>00 00
   a:    bf<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00           mov    edi,  0x1
   f:    ba<span class="hljs-number"> 12 </span>00<span class="hljs-number"> 00 </span>00           mov    edx,  0x12
  14:    b8<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00           mov    eax,  0x1
  19:    0f<span class="hljs-number"> 05 </span>                   syscall
  1b:    b8 3c<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>          mov    eax,  0x3c
  20:    bf<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00           mov    edi,  0x0
  25:    0f<span class="hljs-number"> 05 </span>                   syscall
</code></pre><p>We can see that the instructions are relatively similar to the <code>Hello World</code> assembly code we had before, but they are not identical. We see that there&#39;s an empty line of instructions, which could potentially break the code. Furthermore, our <code>Hello World</code> string is nowhere to be seen. We also see many red <code>00</code>&#39;s, which we&#39;ll get into in a bit.</p>
<p>This is what will happen if our assembly code is not <code>shellcode compliant</code> and does not meet the <code>Shellcoding Requirements</code>. To be able to produce a working shellcode, there are three main <code>Shellcoding Requirements</code> our assembly code must meet:</p>
<ol>
<li>Does not contain variables</li>
<li>Does not refer to direct memory addresses</li>
<li>Does not contain any NULL bytes <code>00</code></li>
</ol>
<p>So, let&#39;s start with the <code>Hello World</code> program we saw in the previous section, and go through each of the above points and fix them:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span> _start

<span class="hljs-meta">section</span> .data
    message <span class="hljs-built_in">db</span> <span class="hljs-string">"Hello HTB Academy!"</span>

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, message
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">18</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">syscall</span>

    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-number">0</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<hr>
<h3 id="remove-variables">Remove Variables</h3>
<p>A shellcode is expected to be directly executable once loaded into memory, without loading data from other memory segments, like <code>.data</code> or <code>.bss</code>. This is because the <code>text</code> memory segments are not <code>writable</code>, so we cannot write any variables. In contrast, the <code>data</code> segment is not executable, so we cannot write executable code.</p>
<p>So, to execute our shellcode, we must load it in the <code>text</code> memory segment and lose the ability to write any variables. <code>Hence, our entire shellcode must be under &#39;.text&#39; in the assembly code.</code></p>
<p>Note: Some older shellcoding techniques (like the jmp-call-pop technique) no longer work with modern memory protections, as many of them rely on writing variables to the <code>text</code> memory segment, which, as we just discussed, is no longer possible.</p>
<p>There are many techniques we can use to avoid using variables, like:</p>
<ol>
<li>Moving immediate strings to registers</li>
<li>Pushing strings to the Stack, and then use them</li>
</ol>
<p>In the above code, we may move our string to <code>rsi</code>, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">    <span class="hljs-attribute">mov</span> rsi, <span class="hljs-string">'Academy!'</span>
</code></pre>
<p>However, a 64-bit register can only hold 8 bytes, which may not be enough for larger strings. So, our other option is to rely on the Stack by pushing our string 16-bytes at a time (in reverse order), and then using <code>rsp</code> as our string pointer, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">    <span class="hljs-keyword">push</span> <span class="hljs-string">'y!'</span>
    <span class="hljs-keyword">push</span> <span class="hljs-string">'B Academ'</span>
    <span class="hljs-keyword">push</span> <span class="hljs-string">'Hello HT'</span>
    mov rsi, rsp
</code></pre>
<p>However, this would exceed the allowed bounds of immediate strings <code>push</code>, which is a <code>dword</code> (4-bytes) at a time. So, we will instead move our string to <code>rbx</code>, and then push <code>rbx</code> to the Stack, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-string">'y!'</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-string">'B Academ'</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-string">'Hello HT'</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rsp</span>
</code></pre>
<p>Note: Whenever we push a string to the stack, we have to push a <code>00</code> before it to terminate the string. However, we don&#39;t have to worry about that in this case, since we can specify the print length for the <code>write</code> syscall.</p>
<p>We can now apply these changes to our code, assemble it and run it to see if it works:</p>
<p>&#x20; Shellcoding Techniques</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ./assembler<span class="hljs-selector-class">.sh</span> helloworld<span class="hljs-selector-class">.s</span>

Hello HTB Academy!
</code></pre>
<p>We see that it works as expected, without needing to use any variables. We can check it with <code>gdb</code> to see how it looks at the breakpoint:</p>
<p>&#x20; gdb</p>
<pre><code>$ gdb -q ./helloworld
─────────────────────────────────────────────────────────────────────────────────────── registers ────
$<span class="hljs-built_in">rax</span>   : <span class="hljs-number">0x1</span>               
$<span class="hljs-built_in">rbx</span>   : <span class="hljs-number">0x5448206f6c6c6548</span> (<span class="hljs-string">"Hello HT"</span>?)
$<span class="hljs-built_in">rcx</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rdx</span>   : <span class="hljs-number">0x12</span>              
$<span class="hljs-built_in">rsp</span>   : <span class="hljs-number">0x00007fffffffe3b8</span>  →  <span class="hljs-string">"Hello HTB Academy!"</span>
$<span class="hljs-built_in">rbp</span>   : <span class="hljs-number">0x0</span>               
$<span class="hljs-built_in">rsi</span>   : <span class="hljs-number">0x00007fffffffe3b8</span>  →  <span class="hljs-string">"Hello HTB Academy!"</span>
$<span class="hljs-built_in">rdi</span>   : <span class="hljs-number">0x1</span>               
─────────────────────────────────────────────────────────────────────────────────────────── stack ────
<span class="hljs-number">0x00007fffffffe3b8</span>│+<span class="hljs-number">0x0000</span>: <span class="hljs-string">"Hello HTB Academy!"</span>     ← $<span class="hljs-built_in">rsp</span>, $<span class="hljs-built_in">rsi</span>
<span class="hljs-number">0x00007fffffffe3c0</span>│+<span class="hljs-number">0x0008</span>: <span class="hljs-string">"B Academy!"</span>
<span class="hljs-number">0x00007fffffffe3c8</span>│+<span class="hljs-number">0x0010</span>: <span class="hljs-number">0x0000000000002179</span> (<span class="hljs-string">"y!"</span>?)
───────────────────────────────────────────────────────────────────────────────────── code:x86:<span class="hljs-number">64</span> ────
→   <span class="hljs-number">0x40102e</span> &lt;_start+<span class="hljs-number">46</span>&gt;      <span class="hljs-keyword">syscall</span> 
──────────────────────────────────────────────────────────────────────────────────────────────────────
</code></pre><p>As we can notice, the string was built up gradually in the Stack, and when we moved <code>rsp</code> to <code>rsi</code> it contained our entire string.</p>
<hr>
<h3 id="remove-addresses">Remove Addresses</h3>
<p>We are now not using any addresses in our above code since we removed the only address reference when we removed our only variable. However, we may see references in many cases, especially with <code>calls</code> or <code>loops</code> and such. So, we must ensure that our shellcode will know how to make the call with whatever environment it runs in.</p>
<p>To be able to do so, we cannot reference direct memory address (i.e. <code>call 0xffffffffaa8a25ff</code>), and instead only make calls to labels (i.e. <code>call loopFib</code>) or relative memory addresses (i.e., <code>call 0x401020</code>). We discussed rip-relative addressing in the <code>gdb</code> section.</p>
<p>Luckily, throughout this module, we have only been making <code>calls</code> to labels to ensure that we learn how to write code that is easily shellcoded. If we are making a <code>call</code> to a label, <code>nasm</code> will automatically change this label into a relative address, which should work with shellcodes.</p>
<p>If we ever had any calls or references to direct memory addresses, we can fix that by:</p>
<ol>
<li>Replacing with calls to labels or rip-relative addresses (for <code>calls</code> and <code>loops</code>)</li>
<li>Push to the Stack and use <code>rsp</code> as the address (for <code>mov</code> and other assembly instructions)</li>
</ol>
<p>If we are efficient while writing our assembly code, we may not have to fix these types of issues.</p>
<hr>
<h3 id="remove-null">Remove NULL</h3>
<p>NULL characters (or <code>0x00</code>) are used as string terminators in assembly and machine code, and so if they are encountered, they will cause issues and may lead the program to terminate early. So, we must ensure that our shellcode does not contain any NULL bytes <code>00</code>. If we go back to our <code>Hello World</code> shellcode disasembly, we noticed many red <code>00</code> in it:</p>
<p>&#x20; pwn</p>
<pre><code>$ pwn disasm '48be0020400000000000bf01000000ba12000000b8010000000f05b83c000000bf000000000f05' -c 'amd64'
   0:   <span class="hljs-number"> 48 </span>be<span class="hljs-number"> 00 </span>20<span class="hljs-number"> 40 </span>00<span class="hljs-number"> 00 </span>    movabs rsi,  0x402000
   7:   <span class="hljs-number"> 00 </span>00 00
   a:    bf<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00           mov    edi,  0x1
   f:    ba<span class="hljs-number"> 12 </span>00<span class="hljs-number"> 00 </span>00           mov    edx,  0x12
  14:    b8<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00           mov    eax,  0x1
  19:    0f<span class="hljs-number"> 05 </span>                   syscall
  1b:    b8 3c<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>          mov    eax,  0x3c
  20:    bf<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00           mov    edi,  0x0
  25:    0f<span class="hljs-number"> 05 </span>                   syscall
</code></pre><p>This commonly happens when moving a small integer into a large register, so the integer gets padded with an extra <code>00</code> to fit the larger register&#39;s size.</p>
<p>For example, in our code above, when we use <code>mov rax, 1</code>, it will be moving <code>00 00 00 01</code> into <code>rax</code>, such that the number size would match the register size. We can see this when we assemble the above instruction:</p>
<p>&#x20; Shellcoding Techniques</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ pwn asm <span class="hljs-string">'mov rax, 1'</span> -c <span class="hljs-string">'amd64'</span>

<span class="hljs-number">48</span>c7c001000000
</code></pre>
<p>To avoid having these NULL bytes, <code>we must use registers that match our data size.</code> For the previous example, we can use the more efficient instruction <code>mov al, 1</code>, as we have been learning throughout the module. However, before we do so, we must first zero out the <code>rax</code> register with <code>xor rax, rax</code>, to ensure our data does not get mixed with older data. Let&#39;s see the shellcode for both of these instructions:</p>
<p>&#x20; Shellcoding Techniques</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ pwn <span class="hljs-keyword">asm</span> <span class="hljs-string">'xor rax, rax'</span> -c <span class="hljs-string">'amd64'</span>

<span class="hljs-number">4831</span>c0
$ pwn <span class="hljs-keyword">asm</span> <span class="hljs-string">'mov al, 1'</span> -c <span class="hljs-string">'amd64'</span>

b001
</code></pre>
<p>As we can see, not only does our new shellcode not contain any NULL bytes, but it is also shorter, which is a very desired thing in shellcodes.</p>
<p>We can start with the new instruction we added earlier, <code>mov rbx, &#39;y!&#39;</code>. We see that this instruction is moving 2-bytes into an 8-byte register. So, to fix it, we will first zero-out <code>rbx</code>, and then use the 2-byte (i.e. 16-bit) register <code>bx</code>, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, <span class="hljs-string">'y!'</span>
</code></pre>
<p>These new instructions should not contain any NULL bytes in their shellcode. Let&#39;s apply the same to the rest of our code, as follows:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm">    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-built_in">rdi</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dil</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-built_in">rdx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, <span class="hljs-number">18</span>
    <span class="hljs-keyword">syscall</span>

    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">dil</span>, <span class="hljs-built_in">dil</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<p>We see that we applied this technique in three places and used the 8-bit register for each.</p>
<p>Tip: If we ever need to move <code>0</code> to a register, we can zero-out that register, like we did for <code>rdi</code> above. Likewise, if we even need to <code>push 0</code> to the stack (e.g. for String Termination) we can zero-out any register, and then push that register to the stack.</p>
<p>If we apply all of the above, we should have the following assembly code:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span> _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, <span class="hljs-string">'y!'</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-string">'B Academ'</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rbx</span>, <span class="hljs-string">'Hello HT'</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rbx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rsp</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-built_in">rdi</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dil</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-built_in">rdx</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, <span class="hljs-number">18</span>
    <span class="hljs-keyword">syscall</span>

    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">rax</span>, <span class="hljs-built_in">rax</span>
    <span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>, <span class="hljs-number">60</span>
    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">dil</span>, <span class="hljs-built_in">dil</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<p>Finally, We can assemble our code and run it:</p>
<p>&#x20; Shellcoding Techniques</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ ./assembler<span class="hljs-selector-class">.sh</span> helloworld<span class="hljs-selector-class">.s</span>

Hello HTB Academy!
</code></pre>
<p>As we can see, our code works as expected.</p>
<hr>
<h3 id="shellcoding">Shellcoding</h3>
<p>We can now try to extract the shellcode of our new <code>helloworld</code> program, using our previous <code>shellcoder.py</code> script:</p>
<p>&#x20; Shellcoding Techniques</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ python3 shellcoder.py helloworld

<span class="hljs-number">4831</span>db66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05
</code></pre>
<p>This shellcode looks much better. But does it contain any NULL bytes? Difficult to tell. So, let&#39;s add the following line at the end of <code>shellcoder.py</code>, which would tell us if our code contains any NULL bytes and also tells us the size of our shellcode:</p>
<p>Code: python</p>
<pre><code class="lang-python">    <span class="hljs-built_in">print</span>(<span class="hljs-string">"%d bytes - Found NULL byte"</span> % <span class="hljs-built_in">len</span>(shellcode)) <span class="hljs-keyword">if</span> [i <span class="hljs-keyword">for</span> i in shellcode <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>] <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">"%d bytes - No NULL bytes"</span> % <span class="hljs-built_in">len</span>(shellcode))
</code></pre>
<p>Let&#39;s run our updated script, to see if our shellcode contains any NULL bytes:</p>
<p>&#x20; Shellcoding Techniques</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ python3 shellcoder.py helloworld

<span class="hljs-number">4831</span>db66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05
<span class="hljs-number">61</span> <span class="hljs-keyword">bytes</span> - No <span class="hljs-literal">NULL</span> <span class="hljs-keyword">bytes</span>
</code></pre>
<p>As we can see, the <code>No NULL bytes</code> tells us that our shellcode is <code>NULL-byte free</code>.</p>
<p>Try running the script on the previous <code>Hello World</code> program to see whether it did contain any NULL bytes. Finally, we reach the moment of truth, and try to run our shellcode with our <code>loader.py</code> script to see if it runs successfully:</p>
<p>&#x20; Shellcoding Techniques</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ python3 loader.py <span class="hljs-string">'4831db66bb79215348bb422041636164656d5348bb48656c6c6f204854534889e64831c0b0014831ff40b7014831d2b2120f054831c0043c4030ff0f05'</span>

Hello HTB Academy!
</code></pre>
<p>As we can see, we have successfully created a working shellcode for our <code>Hello World</code> program.</p>
<hr>
<ol>
<li>\
Page 23</li>
<li>Shellcoding Tools</li>
</ol>
<h2 id="shellcoding-tools">Shellcoding Tools</h2>
<hr>
<p>We should now be able to modify our code and make it <code>shellcode</code> compatible, such that it meets all <code>Shellcoding Requirements</code>. This understanding is crucial for crafting our own shellcodes and minimizing their size, which may become very handy when dealing with Binary Exploitation, especially when we don&#39;t have a lot of room for a large shellcode.</p>
<p>In certain other cases, we may not need to write our own shellcode every time, as a similar shellcode may already exist, or we can use tools to generate our shellcode, so we don&#39;t have to reinvent the wheel.</p>
<p>We will come across many common shellcodes through Binary Exploitation, like a <code>Reverse Shell</code> shellcode or a <code>/bin/sh</code> shellcode. We can find many shellcodes that perform these functions, which we may be able to use with minimal or no modification. We can also use tools to generate both of these shellcodes.</p>
<p><code>For either of these, we must be sure to use a shellcode that matches our target Operating System and Processor Architecture.</code></p>
<hr>
<h3 id="shell-shellcode">Shell Shellcode</h3>
<p>Before we continue with tools and online resources, let&#39;s try to craft our own <code>/bin/sh</code> shellcode. To do so, we can use the <code>execve</code> syscall with syscall number <code>59</code>, which allows us to execute a system application:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root<span class="hljs-meta">@htb</span>[/htb]$ man -s <span class="hljs-number">2</span> execve

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;
</code></pre>
<p>As we can see, the <code>execve</code> syscall accepts 3 arguments. We need to execute <code>/bin/sh /bin/sh</code>, which would drop us in a <code>sh</code> shell. So, our final function will be:</p>
<p>Code: c</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-string">"/bin//sh"</span>, [<span class="hljs-string">"/bin//sh"</span>], NULL)</span></span>
</code></pre>
<p>So, we&#39;ll set our arguments as:</p>
<ol>
<li><code>rax</code> -&gt; <code>59</code> (<code>execve</code> syscall number)</li>
<li><code>rdi</code> -&gt; <code>[&#39;/bin//sh&#39;]</code> (pointer to program to execute)</li>
<li><code>rsi</code> -&gt; <code>[&#39;/bin//sh&#39;]</code> (list of pointers for arguments)</li>
<li><code>rdx</code> -&gt; <code>NULL</code> (no environment variables)</li>
</ol>
<p>Note: We added an extra <code>/</code> in &#39;<code>/bin//sh</code>&#39; so that the total character count is 8, which fills up a 64-bit register, so we don&#39;t have to worry about clearing the register beforehand or dealing with any leftovers. Any extra slashes are ignored in Linux, so this is a handy trick to even the total character count when needed, and it is used a lot in binary exploitation.</p>
<p>Using the same concepts we learned for calling a syscall, the following assembly code should execute the syscall we need:</p>
<p>Code: nasm</p>
<pre><code class="lang-nasm"><span class="hljs-meta">global</span> _start

<span class="hljs-meta">section</span> .text
<span class="hljs-symbol">_start:</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rax</span>, <span class="hljs-number">59</span>         <span class="hljs-comment">; execve syscall number</span>
    <span class="hljs-keyword">push</span> <span class="hljs-number">0</span>              <span class="hljs-comment">; push NULL string terminator</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-string">'/bin//sh'</span> <span class="hljs-comment">; first arg to /bin/sh</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rdi</span>            <span class="hljs-comment">; push to stack </span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdi</span>, <span class="hljs-built_in">rsp</span>        <span class="hljs-comment">; move pointer to ['/bin//sh']</span>
    <span class="hljs-keyword">push</span> <span class="hljs-number">0</span>              <span class="hljs-comment">; push NULL string terminator</span>
    <span class="hljs-keyword">push</span> <span class="hljs-built_in">rdi</span>            <span class="hljs-comment">; push second arg to ['/bin//sh']</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rsi</span>, <span class="hljs-built_in">rsp</span>        <span class="hljs-comment">; pointer to args</span>
    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-number">0</span>          <span class="hljs-comment">; set env to NULL</span>
    <span class="hljs-keyword">syscall</span>
</code></pre>
<p>As we can see, we pushed two (NULL-terminated) <code>&#39;/bin//sh&#39;</code> strings and then moved their pointers to <code>rdi</code> and <code>rsi</code>. We should know by now that the above assembly code will not produce a working shellcode since it contains NULL bytes.</p>
<p><code>Try to remove all NULL bytes from the above assembly code to produce a working shellcode.</code></p>
<details>

<summary>Click to show the answer</summary>

<code>nasm</code>

</details>

<p>Once we fix our code, we can run <code>shellcoder.py</code> on it, and have a shellcode with no NULL bytes:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ python3 shellcoder.py sh

b03b4831d25248bf2f62696e2f2f7368574889e752574889e60f05
<span class="hljs-number">27</span> <span class="hljs-keyword">bytes</span> - No <span class="hljs-literal">NULL</span> <span class="hljs-keyword">bytes</span>
</code></pre>
<p>Try running the above shellcode with <code>loader.py</code> to see if it works and drops us in a shell. Now let&#39;s try to get another shellcode for <code>/bin/sh</code>, using shellcode generation tools.</p>
<hr>
<h3 id="shellcraft">Shellcraft</h3>
<p>Let&#39;s start with our usual tools, <code>pwntools</code>, and use its <code>shellcraft</code> library, which generates a shellcode for various <code>syscalls</code>. We can list <code>syscalls</code> the tool accepts as follows:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ pwn shellcraft -l <span class="hljs-string">'amd64.linux'</span>

..<span class="hljs-selector-class">.SNIP</span>...
amd64<span class="hljs-selector-class">.linux</span><span class="hljs-selector-class">.sh</span>
</code></pre>
<p>We see the <code>amd64.linux.sh</code> syscall, which would drop us into a shell like our above shellcode. We can generate its shellcode as follows:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ pwn shellcraft amd64<span class="hljs-selector-class">.linux</span><span class="hljs-selector-class">.sh</span>

<span class="hljs-number">6</span>a6848b82f62696e2f2f2f73504889e768726901018134240101010131f6566a085e4801e6564889e631d26a3b580f05
</code></pre>
<p>Note that this shellcode is not as optimized and short as our shellcode. We can run the shellcode by adding the <code>-r</code> flag:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ pwn shellcraft amd64<span class="hljs-selector-class">.linux</span><span class="hljs-selector-class">.sh</span> -r

$ whoami

root
</code></pre>
<p>And it works as expected. Furthermore, we can use the <code>Python3</code> interpreter to unlock <code>shellcraft</code> fully and use advanced syscalls with arguments. First, we can list all available syscalls with <code>dir(shellcraft)</code>, as follows:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ python3

&gt;&gt;&gt; <span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *
&gt;&gt;&gt; context(os=<span class="hljs-string">"linux"</span>, arch=<span class="hljs-string">"amd64"</span>, log_level=<span class="hljs-string">"error"</span>)
&gt;&gt;&gt; dir(shellcraft)

[...SNIP... <span class="hljs-string">'execve'</span>, <span class="hljs-string">'exit'</span>, <span class="hljs-string">'exit_group'</span>, ... SNIP...]
</code></pre>
<p>Let&#39;s use the <code>execve</code> syscall like we did above to drop in a shell, as follows:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session"><span class="hljs-meta">&gt;&gt;</span>&gt; syscall = shellcraft.execve(path=<span class="hljs-string">'/bin/sh'</span>,argv=[<span class="hljs-string">'/bin/sh'</span>]) <span class="hljs-comment"># syscall and args</span>
<span class="hljs-meta">&gt;&gt;</span>&gt; asm(syscall).hex() <span class="hljs-comment"># print shellcode</span>

<span class="hljs-string">'48b801010101010101015048b82e63686f2e726901483104244889e748b801010101010101015048b82e63686f2e7269014831042431f6566a085e4801e6564889e631d26a3b580f05'</span>
</code></pre>
<p>We can find a complete list of <code>x86_64</code> accepted syscalls and their arguments on <a href="https://docs.pwntools.com/en/stable/shellcraft/amd64.html">this link</a>. We can now try running this shellcode with <code>loader.py</code>:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ python3 loader.py <span class="hljs-string">'48b801010101010101015048b82e63686f2e726901483104244889e748b801010101010101015048b82e63686f2e7269014831042431f6566a085e4801e6564889e631d26a3b580f05'</span>

$ whoami

root
</code></pre>
<p>And it works as expected.</p>
<hr>
<h3 id="msfvenom">Msfvenom</h3>
<p>Let&#39;s try <code>msfvenom</code>, which is another common tool we can use for shellcode generation. Once again, we can list various available payloads for <code>Linux</code> and <code>x86_64</code> with:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ msfvenom <span class="hljs-_">-l</span> payloads | grep <span class="hljs-string">'linux/x64'</span>

linux/x64/<span class="hljs-built_in">exec</span>                                      Execute an arbitrary <span class="hljs-built_in">command</span>
...SNIP...
</code></pre>
<p>The <code>exec</code> payload allows us to execute a command we specify. Let&#39;s pass &#39;<code>/bin/sh/</code>&#39; for the <code>CMD</code>, and test the shellcode we get:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ msfvenom -p <span class="hljs-string">'linux/x64/exec'</span> <span class="hljs-keyword">CMD</span><span class="bash">=<span class="hljs-string">'sh'</span> <span class="hljs-_">-a</span> <span class="hljs-string">'x64'</span> --platform <span class="hljs-string">'linux'</span> <span class="hljs-_">-f</span> <span class="hljs-string">'hex'</span>
</span>
No encoder specified, outputting raw payload
Payload size: <span class="hljs-number">48</span> bytes
Final size of hex file: <span class="hljs-number">96</span> bytes
<span class="hljs-number">6</span>a3b589948bb2f62696e2f736800534889e7682d6300004889e652e80300000073680056574889e60f05
</code></pre>
<p>Note that this shellcode is also not as optimized and short as our shellcode. Let&#39;s try running this shellcode with our <code>loader.py</code> script:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ python3 loader.py <span class="hljs-string">'6a3b589948bb2f62696e2f736800534889e7682d6300004889e652e80300000073680056574889e60f05'</span>

$ whoami

root
</code></pre>
<p>This shellcode works as well. Try testing other types of syscalls and payloads in <code>shellcraft</code> and <code>msfvenom</code></p>
<hr>
<h3 id="shellcode-encoding">Shellcode Encoding</h3>
<p>Another great benefit of using these tools is to encode our shellcodes without manually writing our encoders. Encoding shellcodes can become a handy feature for systems with anti-virus or certain security protections. However, it must be noted that shellcodes encoded with common encoders may be easy to detect.</p>
<p>We can use <code>msfvenom</code> to encode our shellcodes as well. We can first list available encoders:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ msfvenom -l encoders

Framework Encoders [--encoder &lt;value&gt;]
======================================
    Name                          Rank       Description
    ----                          ----       -----------
    <span class="hljs-keyword">cmd</span><span class="bash">/brace                     low        Bash Brace Expansion Command Encoder
</span>    <span class="hljs-keyword">cmd</span><span class="bash">/<span class="hljs-built_in">echo</span>                      good       Echo Command Encoder
</span>
&lt;SNIP&gt;
</code></pre>
<p>Then we can pick one for <code>x64</code>, like <code>x64/xor</code>, and use it with the <code>-e</code> flag, as follows:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ msfvenom -p <span class="hljs-string">'linux/x64/exec'</span> CMD=<span class="hljs-string">'sh'</span> -a <span class="hljs-string">'x64'</span> --<span class="hljs-keyword">platform</span> <span class="hljs-string">'linux'</span> -f <span class="hljs-string">'hex'</span> -e <span class="hljs-string">'x64/xor'</span>

Found <span class="hljs-number">1</span> compatible encoders
Attempting <span class="hljs-keyword">to</span> encode payload <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> iterations <span class="hljs-keyword">of</span> x64/<span class="hljs-keyword">xor</span>
x64/<span class="hljs-keyword">xor</span> succeeded <span class="hljs-keyword">with</span> size <span class="hljs-number">87</span> (iteration=<span class="hljs-number">0</span>)
x64/<span class="hljs-keyword">xor</span> chosen <span class="hljs-keyword">with</span> <span class="hljs-keyword">final</span> size <span class="hljs-number">87</span>
Payload size: <span class="hljs-number">87</span> bytes
<span class="hljs-keyword">Final</span> size <span class="hljs-keyword">of</span> hex file: <span class="hljs-number">174</span> bytes
<span class="hljs-number">4831</span>c94881e9faffffff488d05efffffff48bbf377c2ea294e325c48315827482df8ffffffe2f4994c9a7361f51d3e9a19ed99414e61147a90aac74a4e32147a9190022a4e325c801fc2bc7e06bbbafc72c2ea294e325c
</code></pre>
<p>Let&#39;s try running the encoded shellcode to see if it runs:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session"><span class="hljs-selector-tag">root</span>@<span class="hljs-keyword">htb</span>[/<span class="hljs-keyword">htb</span>]$ python3 loader.py 
<span class="hljs-string">'4831c94881e9faffffff488d05efffffff48bbf377c2ea294e325c48315827482df8ffffffe2f4994c9a7361f51d3e9a19ed99414e61147a90aac74a4e32147a9190022a4e325c801fc2bc7e06bbbafc72c2ea294e325c'</span>

$ whoami

root
</code></pre>
<p>As we can see, the encoded shellcode works as well while being a little bit less detectable by security monitoring tools.</p>
<p>Tip: We can encode our shellcode multiple times with the <code>-i COUNT</code> flag, and specify the number of iterations we want.</p>
<p>We see that the encoded shellcode is always significantly larger than the non-encoded one since encoding a shellcode adds a built-in decoder for runtime decoding. It may also encode each byte multiple times, which increases its size at every iteration.</p>
<p>If we had a custom shellcode that we wrote, we could use <code>msfvenom</code> to encode it as well, by writing its bytes to a file and then passing it to <code>msfvenom</code> with <code>-p -</code>, as follows:</p>
<p>&#x20; Shellcoding Tools</p>
<pre><code class="lang-shell-session">root@htb[/htb]$ python3 -c <span class="hljs-string">"import sys; sys.stdout.buffer.write(bytes.fromhex('b03b4831d25248bf2f62696e2f2f7368574889e752574889e60f05'))"</span> &gt; <span class="hljs-built_in">shell</span>.bin
root@htb[/htb]$ msfvenom -p - -<span class="hljs-keyword">a</span> <span class="hljs-string">'x64'</span> <span class="hljs-comment">--platform 'linux' -f 'hex' -e 'x64/xor' &lt; shell.bin</span>

Attempting <span class="hljs-built_in">to</span> <span class="hljs-built_in">read</span> payload <span class="hljs-built_in">from</span> STDIN...
Found <span class="hljs-number">1</span> compatible encoders
Attempting <span class="hljs-built_in">to</span> encode payload <span class="hljs-keyword">with</span> <span class="hljs-number">1</span> iterations <span class="hljs-keyword">of</span> x64/xor
x64/xor succeeded <span class="hljs-keyword">with</span> size <span class="hljs-number">71</span> (iteration=<span class="hljs-number">0</span>)
x64/xor chosen <span class="hljs-keyword">with</span> final size <span class="hljs-number">71</span>
Payload size: <span class="hljs-number">71</span> <span class="hljs-keyword">bytes</span>
Final size <span class="hljs-keyword">of</span> hex <span class="hljs-built_in">file</span>: <span class="hljs-number">142</span> <span class="hljs-keyword">bytes</span>
<span class="hljs-number">4831</span>c94881e9fcffffff488d05efffffff48bb5a63e4e17d0bac1348315827482df8ffffffe2f4ea58acd0af59e4ac75018d8f5224df7b0d2b6d062f5ce49abc6ce1e17d0bac13
</code></pre>
<p>As we can see, our payload was encoded and became much larger as well.</p>
<hr>
<h3 id="shellcode-resources">Shellcode Resources</h3>
<p>Finally, we can always search online resources like <a href="http://shell-storm.org/shellcode/">Shell-Storm</a> or <a href="https://www.exploit-db.com/shellcodes">Exploit DB</a> for existing shellcodes.</p>
<p>For example, if we search <a href="http://shell-storm.org/shellcode/">Shell-Storm</a> for a <code>/bin/sh</code> shellcode on <code>Linux/x86_64</code>, we will find several examples of varying sizes, like this <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">27-bytes shellcode</a>. We can search <a href="https://www.exploit-db.com/shellcodes">Exploit DB</a> for the same, and we find a more optimized <a href="https://www.exploit-db.com/shellcodes/47008">22-bytes shellcode</a>, which can be helpful if our Binary Exploitation only had around 22-bytes of overflow space. We can also search for encoded shellcodes, which are bound to be larger.</p>
<p>The shellcode we wrote above is 27-bytes long as well, so it looks to be a very optimized shellcode. With all of that, we should be comfortable with writing, generating, and using shellcodes.</p>
<hr>
